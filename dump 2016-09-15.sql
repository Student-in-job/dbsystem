-- MySQL dump 10.13  Distrib 5.5.41, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: elearning
-- ------------------------------------------------------
-- Server version	5.5.41-0ubuntu0.14.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `accept_task`
--

DROP TABLE IF EXISTS `accept_task`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `accept_task` (
  `accept_task_id` int(11) NOT NULL AUTO_INCREMENT,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `accept_task_date` datetime NOT NULL,
  `accept_task_pass` int(1) NOT NULL DEFAULT '0',
  `user_has_course` int(11) NOT NULL,
  `task` int(11) NOT NULL,
  `accept_task_deleted` int(1) DEFAULT '0',
  PRIMARY KEY (`accept_task_id`),
  KEY `fk_mark_user_has_course1` (`user_has_course`),
  KEY `fk_mark_task1` (`task`),
  CONSTRAINT `fk_mark_task1` FOREIGN KEY (`task`) REFERENCES `task` (`task_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `fk_mark_user_has_course1` FOREIGN KEY (`user_has_course`) REFERENCES `user_has_course` (`user_has_course_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `accept_task`
--

LOCK TABLES `accept_task` WRITE;
/*!40000 ALTER TABLE `accept_task` DISABLE KEYS */;
INSERT INTO `accept_task` VALUES (1,'2016-09-14 14:07:57','2016-09-14 19:07:57',1,1,1,0),(2,'2016-09-14 14:09:06','2016-09-14 19:09:06',1,1,1,0),(3,'2016-09-14 14:09:50','2016-09-14 19:09:50',0,1,2,0),(4,'2016-09-14 14:13:52','2016-09-14 19:13:52',0,1,2,0),(5,'2016-09-14 14:16:50','2016-09-14 19:16:50',1,1,2,0),(6,'2016-09-14 14:17:47','2016-09-14 19:17:47',1,1,3,0),(7,'2016-09-14 14:20:51','2016-09-14 19:20:51',0,1,4,0),(8,'2016-09-14 14:37:33','2016-09-14 19:37:33',0,1,4,0),(9,'2016-09-14 14:39:29','2016-09-14 19:39:29',0,1,5,0),(10,'2016-09-15 03:54:43','2016-09-15 08:54:43',1,4,4,0);
/*!40000 ALTER TABLE `accept_task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `accept_test`
--

DROP TABLE IF EXISTS `accept_test`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `accept_test` (
  `accept_test_id` int(11) NOT NULL AUTO_INCREMENT,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `accept_test_date` datetime NOT NULL,
  `accept_test_ball` int(11) DEFAULT NULL,
  `user_has_course` int(11) NOT NULL,
  `test` int(11) NOT NULL,
  `accept_test_deleted` int(1) DEFAULT '0',
  PRIMARY KEY (`accept_test_id`),
  KEY `fk_accept_test_user_has_course1` (`user_has_course`),
  KEY `fk_accept_test_task1` (`test`),
  CONSTRAINT `fk_accept_test_task1` FOREIGN KEY (`test`) REFERENCES `test` (`test_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `fk_accept_test_user_has_course1` FOREIGN KEY (`user_has_course`) REFERENCES `user_has_course` (`user_has_course_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `accept_test`
--

LOCK TABLES `accept_test` WRITE;
/*!40000 ALTER TABLE `accept_test` DISABLE KEYS */;
INSERT INTO `accept_test` VALUES (1,'2016-09-14 14:04:28','2016-09-14 19:04:28',6,1,2,0),(2,'2016-09-14 14:05:58','2016-09-14 19:05:58',7,2,2,0),(3,'2016-09-14 14:07:08','2016-09-14 19:07:08',2,3,2,0),(4,'2016-09-15 04:00:14','2016-09-15 09:00:14',NULL,4,2,0);
/*!40000 ALTER TABLE `accept_test` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `area`
--

DROP TABLE IF EXISTS `area`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `area` (
  `area_id` int(11) NOT NULL AUTO_INCREMENT,
  `area_name` varchar(20) NOT NULL,
  `area_deleted` int(1) NOT NULL DEFAULT '0',
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`area_id`),
  UNIQUE KEY `area_name` (`area_name`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `area`
--

LOCK TABLES `area` WRITE;
/*!40000 ALTER TABLE `area` DISABLE KEYS */;
INSERT INTO `area` VALUES (1,'MySQL',0,'2016-09-08 11:17:04'),(2,'PostgreSQL',0,'2016-09-08 11:17:04'),(3,'Oracle',0,'2016-09-08 11:17:04'),(4,'Azure',0,'2016-09-08 11:17:04'),(5,'mongoDB',0,'2016-09-08 11:17:04'),(6,'MariaDB',0,'2016-09-08 11:17:04'),(7,'cassandra',0,'2016-09-08 11:17:04'),(8,'Titan',0,'2016-09-07 11:17:04'),(9,'H2',0,'2016-09-06 11:17:04'),(10,'BaseX',0,'2016-09-06 11:17:04'),(11,'Berkeley DB',0,'2016-09-06 11:17:04'),(12,'CouchDB',0,'2016-09-06 11:17:04'),(13,'SQLite',0,'2016-09-06 11:17:04'),(14,'Neo4j',0,'2016-09-06 11:17:04'),(15,'Ingres',0,'2016-09-06 11:17:04');
/*!40000 ALTER TABLE `area` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comments`
--

DROP TABLE IF EXISTS `comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comments` (
  `comment_id` int(11) NOT NULL AUTO_INCREMENT,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `comment_text` text NOT NULL,
  `user` int(11) NOT NULL,
  `course` int(11) NOT NULL,
  `commen_datetime` datetime NOT NULL,
  `commen_deleted` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`comment_id`),
  KEY `fk_comment_user1` (`user`),
  KEY `fk_comment_course1` (`course`),
  CONSTRAINT `fk_comment_course1` FOREIGN KEY (`course`) REFERENCES `course` (`course_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `fk_comment_user1` FOREIGN KEY (`user`) REFERENCES `user` (`user_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comments`
--

LOCK TABLES `comments` WRITE;
/*!40000 ALTER TABLE `comments` DISABLE KEYS */;
/*!40000 ALTER TABLE `comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `course`
--

DROP TABLE IF EXISTS `course`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `course` (
  `course_id` int(11) NOT NULL AUTO_INCREMENT,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `course_start_date` date NOT NULL,
  `course_end_date` date NOT NULL,
  `program` int(11) NOT NULL,
  `course_public` varchar(45) NOT NULL,
  `course_deleted` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`course_id`),
  KEY `fk_course_program1` (`program`),
  CONSTRAINT `fk_course_program1` FOREIGN KEY (`program`) REFERENCES `program` (`program_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `course`
--

LOCK TABLES `course` WRITE;
/*!40000 ALTER TABLE `course` DISABLE KEYS */;
INSERT INTO `course` VALUES (1,'2016-09-14 14:03:57','2016-09-14','2016-09-29',1,'0',0),(2,'2016-09-14 14:05:52','2016-09-14','2016-09-29',1,'0',0),(3,'2016-09-14 14:07:02','2016-09-14','2016-09-29',1,'0',0),(4,'2016-09-15 03:54:05','2016-09-15','2016-09-30',1,'0',0);
/*!40000 ALTER TABLE `course` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `externe`
--

DROP TABLE IF EXISTS `externe`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `externe` (
  `externe_id` int(11) NOT NULL AUTO_INCREMENT,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `user` int(11) NOT NULL,
  `program` int(11) NOT NULL,
  `externe_datetime` datetime NOT NULL,
  PRIMARY KEY (`externe_id`),
  KEY `fk_externe_user1` (`user`),
  KEY `fk_externe_program1` (`program`),
  CONSTRAINT `fk_externe_program1` FOREIGN KEY (`program`) REFERENCES `program` (`program_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `fk_externe_user1` FOREIGN KEY (`user`) REFERENCES `user` (`user_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `externe`
--

LOCK TABLES `externe` WRITE;
/*!40000 ALTER TABLE `externe` DISABLE KEYS */;
/*!40000 ALTER TABLE `externe` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `externe_has_task`
--

DROP TABLE IF EXISTS `externe_has_task`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `externe_has_task` (
  `externe` int(11) NOT NULL,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `task` int(11) NOT NULL,
  `externe_has_task_datetime` datetime NOT NULL,
  `externe_has_task_accept` varchar(10) NOT NULL,
  PRIMARY KEY (`externe`,`task`),
  KEY `fk_externe_has_task_task1` (`task`),
  CONSTRAINT `fk_externe_has_task_externe1` FOREIGN KEY (`externe`) REFERENCES `externe` (`externe_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `fk_externe_has_task_task1` FOREIGN KEY (`task`) REFERENCES `task` (`task_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `externe_has_task`
--

LOCK TABLES `externe_has_task` WRITE;
/*!40000 ALTER TABLE `externe_has_task` DISABLE KEYS */;
/*!40000 ALTER TABLE `externe_has_task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `externe_has_test`
--

DROP TABLE IF EXISTS `externe_has_test`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `externe_has_test` (
  `externe` int(11) NOT NULL,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `test` int(11) NOT NULL,
  `externe_has_test_datetime` datetime NOT NULL,
  `externe_has_test_ball` int(11) NOT NULL,
  PRIMARY KEY (`externe`,`test`),
  KEY `fk_externe_has_test1_test1` (`test`),
  CONSTRAINT `fk_externe_has_test1_externe1` FOREIGN KEY (`externe`) REFERENCES `externe` (`externe_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `fk_externe_has_test1_test1` FOREIGN KEY (`test`) REFERENCES `test` (`test_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `externe_has_test`
--

LOCK TABLES `externe_has_test` WRITE;
/*!40000 ALTER TABLE `externe_has_test` DISABLE KEYS */;
/*!40000 ALTER TABLE `externe_has_test` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `files`
--

DROP TABLE IF EXISTS `files`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `files` (
  `files_id` int(11) NOT NULL AUTO_INCREMENT,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `files_name` varchar(100) NOT NULL,
  `files_title` varchar(100) NOT NULL,
  `material` int(11) NOT NULL,
  `files_type` varchar(10) DEFAULT NULL,
  `files_deleted` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`files_id`),
  KEY `fk_files_program1` (`material`),
  CONSTRAINT `fk_files_program1` FOREIGN KEY (`material`) REFERENCES `material` (`material_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `files`
--

LOCK TABLES `files` WRITE;
/*!40000 ALTER TABLE `files` DISABLE KEYS */;
INSERT INTO `files` VALUES (1,'2016-09-14 06:10:09','lecture 1. Introduction to DBMS.pptx','Презентация к лекцие',1,'document',1),(2,'2016-09-14 06:36:27','lecture 2. Database system architecture.pptx','Презентация к лекцие',2,'document',1),(3,'2016-09-14 06:37:33','lecture 3. Entity-Relationaship modelling.pptx','Презентация к лекцие',3,'document',1),(4,'2016-09-14 06:38:03','lecture 4. Relational model.pptx','Презентация к лекцие',4,'document',1),(5,'2016-09-14 06:38:41','lecture 5. Relational algebra and relational calculus.pptx','Презентация к лекцие',5,'document',1),(6,'2016-09-14 06:39:27','lecture 6. Database Planning, Design and Administration.pptx','Презентация к лекцие',6,'document',1),(7,'2016-09-14 06:39:58','lecture 7. Normalization.pptx','Презентация к лекцие',7,'document',1),(8,'2016-09-14 06:40:28','lecture 8. Introduction to SQL.pptx','Презентация к лекцие',8,'document',1),(9,'2016-09-14 06:40:54','lecture 8. Introduction to SQL_1.pptx','Презентация к лекцие',9,'document',1),(10,'2016-09-14 06:41:30','lecture 9. SQL. Data manipulation.pptx','Презентация к лекцие',9,'document',1),(11,'2016-09-14 06:41:57','lecture 11. Transaction management. Query Processing and Optimization.pptx','Презентация к лекцие',10,'document',1),(12,'2016-09-14 06:43:28','lecture 11. Transaction management. Query Processing and Optimization_1.pptx','Презентация к лекцие',11,'document',1),(13,'2016-09-14 06:44:23','lecture 12. Database Administration and Security.pptx','Презентация к лекцие',12,'document',1),(14,'2016-09-14 06:44:53','lecture 13. The Database Connectivity.pptx','Презентация к лекцие',13,'document',1),(15,'2016-09-14 11:52:41','Untitled 1.doc','Лекция 1: Введение в MySQL',14,'document',0),(16,'2016-09-14 12:17:47','Untitled 1.doc','Введение в PostgreSQL',15,'document',0),(17,'2016-09-14 12:42:10','Untitled 1.doc','Резервное копирование и восстановление',16,'document',0),(18,'2016-09-14 13:13:00','Untitled 1.doc','Настройка и оптимизация MySQL сервера',17,'document',0),(19,'2016-09-15 15:13:56','lecture 1. Introduction to DBMS.pptx','Презентация',1,'document',0),(20,'2016-09-15 15:14:37','lecture 2. Database system architecture.pptx','Презентация',2,'document',0),(21,'2016-09-15 15:17:46','lecture 3. Entity-Relationaship modelling.pptx','Презентация',3,'document',0),(22,'2016-09-15 15:18:54','lecture 4. Relational model.pptx','Презентация',4,'document',0),(23,'2016-09-15 15:19:33','lecture 5. Relational algebra and relational calculus.pptx','Презентация',5,'document',0),(24,'2016-09-15 15:20:44','lecture 6. Database Planning, Design and Administration.pptx','Презентация',6,'document',0),(25,'2016-09-15 15:21:34','lecture 7. Normalization.pptx','Презентация',7,'document',0),(26,'2016-09-15 15:22:30','lecture 8. Introduction to SQL.pptx','Презентация',8,'document',0),(27,'2016-09-15 15:27:44','lecture 10. SQL. Data Definition.pptx','Презентация',10,'document',0),(28,'2016-09-15 15:37:39','lecture 12. Database Administration and Security.pptx','Презентация',12,'document',0),(29,'2016-09-15 15:38:32','lecture 13. The Database Connectivity.pptx','Презентация',13,'document',0),(30,'2016-09-15 15:40:06','lecture 11. Transaction management. Query Processing and Optimization.pptx','Презентация',11,'document',0),(31,'2016-09-15 15:40:58','lecture 9. SQL. Data manipulation.pptx','Презентация',9,'document',0),(32,'2016-09-15 15:42:47','11.docx','Лекция',9,'document',0),(33,'2016-09-15 15:53:09','er_db.mp4','Реляционные базы данных. Понятие отношения. Нормализация',1,'video',0),(34,'2016-09-15 16:07:32','whot_is_database.mp4','Что такое база данных MySQL',1,'video',0);
/*!40000 ALTER TABLE `files` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `material`
--

DROP TABLE IF EXISTS `material`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `material` (
  `material_id` int(11) NOT NULL AUTO_INCREMENT,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `material_name` varchar(50) NOT NULL,
  `material_day` int(3) NOT NULL,
  `material_type` varchar(10) NOT NULL,
  `material_file` text,
  `program` int(11) NOT NULL,
  `material_text` text NOT NULL,
  `material_deleted` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`material_id`),
  KEY `fk_material_program1` (`program`),
  CONSTRAINT `fk_material_program1` FOREIGN KEY (`program`) REFERENCES `program` (`program_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `material`
--

LOCK TABLES `material` WRITE;
/*!40000 ALTER TABLE `material` DISABLE KEYS */;
INSERT INTO `material` VALUES (1,'2016-09-14 06:09:35','Лекция 1. Введение в базы данных.',1,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>Обзор</li>\r\n<li>История баз данных</li>\r\n<li>Файловые системы</li>\r\n</ol>\r\n<p>&nbsp;</p>\r\n<p><strong>Ключевые слова: база данных, файловые системы, СУБД.</strong></p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Обзор.</strong></p>\r\n<p>Исторически сложившееся развитие вычислительных систем обусловило необходимость хранения в электронном (машиночитаемом) виде все большего количества информации. Одновременно с совершенствованием и дальнейшим развитием вычислительных систем росли объемы информации, подлежащей обработке и хранению. Сложности, возникшие при решении на практике задач структурированного хранения и эффективной обработки возрастающих объемов информации, стимулировали исследования в соответствующих областях. Задачи хранения и обработки данных были формализованы. Была создана теоретическая база для решения задач такого класса, результатом реализации на практике которой стали системы, предназначенные для организации обработки, хранения и предоставления доступа к информации. Позже такие системы стали называть системами баз данных.</p>\r\n<p>Одновременно с развитием систем баз данных, происходило интенсивное развитие средств вычислительной техники, используемой для работы с большими объемами информации. Вычислительная мощность и, особенно, объемы запоминающих устройств первых вычислительных систем были недостаточны для хранения и обработки информации в объемах, необходимых на практике.</p>\r\n<p>По мере развития систем баз данных, менялись принципы организации данных в них: первоначально данные представлялись на основе иерархической, а в последствии сетевой модели. В конце 1970-х &ndash; начале 1980-х годов начали появляться первые реляционные продукты. В настоящее время системы баз данных на основе реляционной модели занимают лидирующее положение, несмотря на заявления многих исследователей о скором переходе к объектно-ориентированным системам. В настоящее время объектно-ориентированные системы, тем не менее, развиваются, хотя темпы их развития и сдерживаются медленным принятием соответствующих стандартов. Кроме того, многие коммерческие реляционные системы приобретают объектно-ориентированные черты. На основании этого, можно предположить, что в будущем объектно-ориентированные системы будут постепенно вытеснять реляционные.</p>\r\n<p>В настоящее время ведутся исследования в следующих направлениях:</p>\r\n<ol>\r\n<li>дедуктивные системы;</li>\r\n<li>экспертные системы;</li>\r\n<li>расширяемые системы;</li>\r\n<li>объектно-ориентированные системы;</li>\r\n<li></li>\r\n</ol>\r\n<p><strong>История развития баз данных</strong></p>\r\n<p>История развития СУБД насчитывает более 30 лет. В 1968 году была введена в эксплуатацию первая промышленная СУБД система IMS фирмы IBM. В 1975 году появился первый стандарт ассоциации по языкам систем обработки данных &mdash; Conference of Data System Languages (CODASYL), который определил ряд фундаментальных понятий в теории систем баз данных, которые и до сих пор являются основополагающими для сетевой модели данных.</p>\r\n<p>В дальнейшее развитие теории баз данных большой вклад был сделан американским математиком Э. Ф. Коддом, который является создателем реляционной модели данных. В 1981 году Э. Ф. Кодд получил за создание реляционной модели и реляционной алгебры престижную премию Тьюринга Американской ассоциации по вычислительной технике.</p>\r\n<p>Менее двух десятков лет прошло с этого момента, но стремительное развитие вычислительной техники, изменение ее принципиальной роли в жизни общества, обрушившийся бум персональных ЭВМ и, наконец, появление мощных рабочих станций и сетей ЭВМ повлияло также и на развитие технологии баз данных. Можно выделить четыре этапа в развитии данного направления в обработке данных. Однако необходимо заметить, что все же нет жестких временных ограничений в этих этапах: они плавно переходят один в другой и даже сосуществуют параллельно, но тем не менее выделение этих этапов позволит более четко охарактеризовать отдельные стадии развития технологии баз данных, подчеркнуть особенности, специфичные для конкретного этапа.</p>\r\n<p>Первый этап развития СУБД связан с организацией баз данных на больших машинах типа IBM 360/370, ЕС-ЭВМ и мини-ЭВМ типа PDP11 (фирмы Digital Equipment Corporation &mdash; DEC), разных моделях HP (фирмы Hewlett Packard).</p>\r\n<p>Базы данных хранились во внешней памяти центральной ЭВМ, пользователями этих баз данных были задачи, запускаемые в основном в пакетном режиме. Интерактивный режим доступа обеспечивался с помощью консольных терминалов, которые не обладали собственными вычислительными ресурсами (процессором, внешней памятью) и служили только устройствами ввода-вывода для центральной ЭВМ. Программы доступа к БД писались на различных языках и запускались как обычные числовые программы. Мощные операционные системы обеспечивали возможность условно параллельного выполнения всего множества задач. Эти системы можно было отнести к системам распределенного доступа, потому что база данных была централизованной, хранилась на устройствах внешней памяти одной центральной ЭВМ, а доступ к ней поддерживался от многих пользователей-задач.</p>\r\n<p>Особенности этого этапа развития выражаются в следующем:</p>\r\n<ul>\r\n<li>Все СУБД базируются на мощных мультизадачных операционных системах (MVS, SVM, RTE, OSRV, RSX, UNIX), поэтому в основном поддерживается работа с централизованной базой данных в режиме распределенного многопользовательского доступа.</li>\r\n<li>Функции управления распределением ресурсов в основном осуществляются операционной системой (ОС).</li>\r\n<li>Поддерживаются языки низкого уровня манипулирования данными, ориентированные на навигационные методы доступа к данным.</li>\r\n<li>Значительная роль отводится администрированию данных.</li>\r\n<li>Проводятся серьезные работы по обоснованию и формализации реляционной модели данных, и была создана первая система (System R), реализующая идеологию реляционной модели данных.</li>\r\n<li>Проводятся теоретические работы по оптимизации запросов и управлению распределенным доступом к централизованной БД, было введено понятие транзакции.</li>\r\n<li>Результаты научных исследований открыто обсуждаются в печати, идет мощный поток общедоступных публикаций, касающихся всех аспектов теории и практики баз данных, и результаты теоретических исследований активно внедряются в коммерческие СУБД.</li>\r\n<li>Появляются первые языки высокого уровня для работы с реляционной моделью данных. Однако отсутствуют стандарты для этих первых языков.</li>\r\n</ul>\r\n<p>Персональные компьютеры стремительно ворвались в нашу жизнь и буквально перевернули наше представление о месте и роли вычислительной техники в жизни общества. Теперь компьютеры стали ближе и доступнее каждому пользователю. Исчез благоговейный страх рядовых пользователей перед непонятными и сложными языками программирования. Появилось множество программ, предназначенных для работы неподготовленных пользователей. Эти программы были просты в использовании и интуитивно понятны: это прежде всего различные редакторы текстов, электронные таблицы и другие. Простыми и понятными стали операции копирования файлов и перенос информации с одного компьютера на другой, распечатка текстов, таблиц и других документов. Системные программисты были отодвинуты на второй план. Каждый пользователь мог себя почувствовать полным хозяином этого мощного и удобного устройства, Позволяющего автоматизировать многие аспекты деятельности. И, конечно, это сказалось и на работе с базами данных. Появились программы, которые назывались системами управления базами данных и позволяли хранить значительные объемы информации, они имели удобный интерфейс для заполнения данных, встроенные средства для генерации различных отчетов. Эти программы позволяли автоматизировать многие учетные функции, которые раньше велись вручную. Постоянное снижение цен на персональные компьютеры сделало их доступными не только для организаций и фирм, но и для отдельных пользователей. Компьютеры стали инструментом для ведения документации и собственных учетных функций. Это все сыграло как положительную, так и отрицательную роль в области развития баз данных. Кажущаяся простота и доступность персональных компьютеров и их программного обеспечения породила множество дилетантов. Эти разработчики, считая себя знатоками, стали проектировать недолговечные базы данных, которые не учитывали многих особенностей объектов реального мира. Много было создано систем-однодневок, которые не отвечали законам развития и взаимосвязи реальных объектов. Однако доступность персональных компьютеров заставила пользователей из многих областей знаний, которые ранее не применяли вычислительную технику в своей деятельности, обратиться к ним. И спрос на развитые удобные программы обработки данных заставлял поставщиков программного обеспечения поставлять все новые системы, которые принято называть настольными (desktop) СУБД. Значительная конкуренция среди поставщиков заставляла совершенствовать эти системы, предлагая новые возможности, улучшая интерфейс и быстродействие систем, снижая их стоимость. Наличие на рынке большого числа СУБД, выполняющих сходные функции, потребовало разработки методов экспорта - импорта данных для этих систем и открытия форматов хранения данных.</p>\r\n<p>Но и в этот период появлялись любители, которые вопреки здравому смыслу разрабатывали собственные СУБД, используя стандартные языки программирования. Это был тупиковый вариант, потому что дальнейшее развитие показало, что перенести данные из нестандартных форматов в новые СУБД было гораздо труднее, а в некоторых случаях требовало таких трудозатрат, что легче было бы все разработать заново, но данные все равно надо было переносить на новую более перспективную СУБД. И это тоже было результатом недооценки тех функций, которые должна была выполнять СУБД.</p>\r\n<p>Особенности этого этапа следующие:</p>\r\n<ul>\r\n<li>Все СУБД были рассчитаны на создание БД в основном с монопольным доступом. И это понятно. Компьютер персональный, он не был подсоединен к сети, и база данных на нем создавалась для работы одного пользователя. В редких случаях предполагалась последовательная работа нескольких пользователей, например, сначала оператор, который вводил бухгалтерские документы, а потом главбух, который определял проводки, соответствующие первичным документам.</li>\r\n<li>Большинство СУБД имели развитый и удобный пользовательский интерфейс. В большинстве существовал интерактивный режим работы с БД как в рамках описания БД, так и в рамках проектирования запросов. Кроме того, большинство СУБД предлагали развитый и удобный инструментарий для разработки готовых приложений без программирования. Инструментальная среда состояла из готовых элементов приложения в виде шаблонов экранных форм, отчетов, этикеток (Labels), графических конструкторов запросов, которые достаточно просто могли быть собраны в единый комплекс.</li>\r\n<li>Во всех настольных СУБД поддерживался только внешний уровень представления реляционной модели, то есть только внешний табличный вид структур данных.</li>\r\n<li>При наличии высокоуровневых языков манипулирования данными типа реляционной алгебры и SQL в настольных СУБД поддерживались низкоуровневые языки манипулирования данными на уровне отдельных строк таблиц.</li>\r\n<li>В настольных СУБД отсутствовали средства поддержки ссылочной и структурной целостности базы данных. Эти функции должны были выполнять приложения, однако скудость средств разработки приложений иногда не позволяла это сделать, и в этом случае эти функции должны были выполняться пользователем, требуя от него дополнительного контроля при вводе и изменении информации, хранящейся в БД.</li>\r\n<li>Наличие монопольного режима работы фактически привело к вырождению функций администрирования БД и в связи с этим &mdash; к отсутствию инструментальных средств администрирования БД.</li>\r\n<li>И, наконец, последняя и в настоящий момент весьма положительная особенность &mdash; это сравнительно скромные требования к аппаратному обеспечению со стороны настольных СУБД. Вполне работоспособные приложения, разработанные, например, на Clipper, работали на PC 286.</li>\r\n<li>В принципе, их даже трудно назвать полноценными СУБД. Яркие представители этого семейства &mdash; очень широко использовавшиеся до недавнего времени СУБД Dbase (DbaseIII+, DbaselV), FoxPro, Clipper, Paradox.</li>\r\n</ul>\r\n<p><strong>Файловые системы.</strong></p>\r\n<p>Историческим шагом явился переход к использованию централизованных систем управления файлами. С точки зрения прикладной программы файл - это именованная область внешней памяти, в которую можно записывать и из которой можно считывать данные. Правила именования файлов, способ доступа к данным, хранящимся в файле, и структура этих данных зависят от конкретной системы управления файлами и, возможно, от типа файла. Система управления файлами берет на себя распределение внешней памяти, отображение имен файлов в соответствующие адреса во внешней памяти и обеспечение доступа к данным.</p>\r\n<p>Первая развитая файловая система была разработана фирмой IBM для ее серии 360. К настоящему времени она очень устарела, и мы не будем рассматривать ее подробно. Заметим лишь, что в этой системе поддерживались как чисто последовательные, так и индексно-последовательные файлы, а реализация во многом опиралась на возможности только появившихся к этому времени контроллеров управления дисковыми устройствами. Если учесть к тому же, что понятие файла в OS/360 было выбрано как основное абстрактное понятие, которому соответствовал любой внешний объект, включая внешние устройства, то работать с файлами на уровне пользователя было очень неудобно. Требовался целый ряд громоздких и перегруженных деталями конструкций. Все это хорошо знакомо программистам среднего и старшего поколения, которые прошли через использование отечественных аналогов компьютеров IBM.</p>\r\n<p><strong>Структуры файлов</strong><strong>.</strong></p>\r\n<p>Дальше мы будем говорить о более современных организациях файловых систем. Начнем со структур файлов. Прежде всего, практически во всех современных компьютерах основными устройствами внешней памяти являются магнитные диски с подвижными головками, и именно они служат для хранения файлов. Такие магнитные диски представляют собой пакеты магнитных пластин (поверхностей), между которыми на одном рычаге двигается пакет магнитных головок. Шаг движения пакета головок является дискретным, и каждому положению пакета головок логически соответствует цилиндр магнитного диска. На каждой поверхности цилиндр \"высекает\" дорожку, так что каждая поверхность содержит число дорожек, равное числу цилиндров. При разметке магнитного диска (специальном действии, предшествующем использованию диска) каждая дорожка размечается на одно и то же количество блоков таким образом, что в каждый блок можно записать по максимуму одно и то же число байтов. Таким образом, для произведения обмена с магнитным диском на уровне аппаратуры нужно указать номер цилиндра, номер поверхности, номер блока на соответствующей дорожке и число байтов, которое нужно записать или прочитать от начала этого блока.</p>\r\n<p><strong>Именование файлов</strong><strong>.</strong></p>\r\n<p>Остановимся коротко на способах именования файлов. Все современные файловые системы поддерживают многоуровневое именование файлов за счет поддержания во внешней памяти дополнительных файлов со специальной структурой - каталогов. Каждый каталог содержит имена каталогов и/или файлов, содержащихся в данном каталоге. Таким образом, полное имя файла состоит из списка имен каталогов плюс имя файла в каталоге, непосредственно содержащем данный файл. Разница между способами именования файлов в разных файловых системах состоит в том, с чего начинается эта цепочка имен.</p>\r\n<p>В этом отношении имеются два крайних варианта. Во многих системах управления файлами требуется, чтобы каждый архив файлов (полное дерево справочников) целиком располагался на одном дисковом пакете (или логическом диске, разделе физического дискового пакета, представляемом с помощью средств операционной системы как отдельный диск). В этом случае полное имя файла начинается с имени дискового устройства, на котором установлен соответствующий диск.</p>\r\n<p><strong>Защита файлов</strong><strong>.</strong></p>\r\n<p>Поскольку файловые системы являются общим хранилищем файлов, принадлежащих, вообще говоря, разным пользователям, системы управления файлами должны обеспечивать авторизацию доступа к файлам. В общем виде подход состоит в том, что по отношению к каждому зарегистрированному пользователю данной вычислительной системы для каждого существующего файла указываются действия, которые разрешены или запрещены данному пользователю. Существовали попытки реализовать этот подход в полном объеме. Но это вызывало слишком большие накладные расходы как по хранению избыточной информации, так и по использованию этой информации для контроля правомочности доступа.</p>\r\n<p><strong>Режим многопользовательского доступа.</strong></p>\r\n<p>Исторически в файловых системах применялся следующий подход. В операции открытия файла (первой и обязательной операции, с которой должен начинаться сеанс работы с файлом) помимо прочих параметров указывался режим работы (чтение или изменение). Если к моменту выполнения этой операции от имени некоторой программы A файл уже находился в открытом состоянии от имени некоторой другой программы B (правильнее говорить \"процесса\", но мы не будем вдаваться в терминологические тонкости), причем существующий режим открытия был несовместимым с желаемым режимом (совместимы только режимы чтения), то в зависимости от особенностей системы программе A либо сообщалось о невозможности открытия файла в желаемом режиме, либо она блокировалась до тех пор, пока программа B не выполнит операцию закрытия файла.</p>\r\n<p><a name=\"_Toc286843595\"></a><strong>Понятие БД и СУБД</strong><strong>.</strong></p>\r\n<p><strong><em>Система баз данных</em></strong> &ndash; это компьютеризированная система основная задача которой&nbsp; &ndash; хранение информации и предоставление доступа к ней по требованию.</p>\r\n<p>&nbsp;</p>\r\n<table width=\"100%\">\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p>Прикладные программисты</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<table width=\"100%\">\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p>Конечные пользователи</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<table width=\"100%\">\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p>Система управления базами данных</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<table width=\"100%\">\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p>База данных</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>&nbsp;</p>\r\n<p>Рис. 1.1 Система баз данных.</p>\r\n<p>Система баз данных включает в себя (рис 1.1):</p>\r\n<ol>\r\n<li>данные, непосредственно сохраняемые в базе данных;</li>\r\n<li>аппаратное обеспечение;</li>\r\n<li>программное обеспечение;</li>\r\n<li>пользователей:</li>\r\n<li>прикладные программисты;</li>\r\n<li>конечные пользователи;</li>\r\n<li>администраторы баз данных.</li>\r\n</ol>\r\n<p>Данные в базе данных являются интегрированными и, как правило, общими. Понятие интегрированных данных подразумевает возможность представления базы данных как объединение нескольких отдельных файлов данных, полностью или частично не перекрывающихся. Понятие общие подразумевает возможность использования отдельных областей данных, в базе данных несколькими различными пользователями.</p>\r\n<p>К <strong><em>аппаратному обеспечению</em></strong> системы относятся накопители для хранения информации, вместе с устройствами ввода-вывода, контролерами устройств и т.д.; вычислительная техника, используемая для поддержки работы ПО системы.</p>\r\n<p><strong><em>Программное обеспечение</em></strong> является промежуточным слоем между собственно физической базой данных и пользователями системы и называется диспетчером базы данных или системой управления базами данных, СУБД (DBMS). Все запросы пользователей обрабатываются СУБД.</p>\r\n<p><strong><em>СУБД</em></strong> &ndash; это специализированное программное обеспечение, предоставляющее пользователю базы данных возможность работать с ней, не вникая в детали хранения информации на уровне программного обеспечения.</p>\r\n<p><strong><em>Прикладные программисты</em></strong> &ndash; отвечают за написание прикладных программ, использующих базу данных.</p>\r\n<p><strong><em>Конечные пользователи</em></strong> &ndash; работают с базой данных непосредственно, через рабочую станцию или терминал. Конечный пользователь может получить доступ к базе данных используя соответствующее прикладное ПО.</p>\r\n<p><strong><em>Администраторы базы данных</em></strong> &ndash; технические специалисты, осуществляющие создание БД, технический контроль работы СУБД и др. операции. Администраторы базы данных отвечают за реализацию решений администратора данных. Администратор данных решает, какие данные необходимо хранить в БД, обеспечивает поддержание порядка при обслуживании и использовании хранимых в БД данных.</p>\r\n<p>Функции администратора базы данных:</p>\r\n<p>Определение концептуальной схемы. Администратор БД определяет какие именно данные необходимо сохранять в БД. Этот процесс обычно называют логическим (или концептуальным) проектированием БД. После определения содержимого БД на абстрактном уровне, администратор БД создает соответствующую концептуальную схему, с помощью концептуального ЯОД.</p>\r\n<p>Определение внутренней схемы. Администратор БД решает, как данные должны быть представлены в хранимой БД. Этот процесс называют физическим проектированием. После завершения физического проектирования администратор БД с помощью внутреннего ЯОД должен создать соответствующую структуру хранения, а также определить отображение между внутренней и концептуальной схемой.</p>\r\n<p>Взаимодействие с пользователями. Администратор БД обеспечивает пользователей необходимыми им данными. Для этого администратор БД должен написать (или оказать пользователям помощь в написании) необходимых внешних схем. Кроме этого необходимо определить отображение между внешней и концептуальной схемами.</p>\r\n<ol>\r\n<li>Определение правил безопасности и целостности.</li>\r\n<li>Определение процедур резервного копирования и восстановления.</li>\r\n<li>Управление производительностью и реагирование на изменяющиеся требования.</li>\r\n</ol>\r\n<p>База данных состоит из некоторого набора постоянных данных, которые используются прикладными системами какого-либо предприятия. Под словом \"постоянные\" подразумеваются данные, которые отличаются от других, более изменчивых данных, таких, как промежуточные данные и вообще все транзитные данные. \"Постоянные\" данные на самом деле могут недолго оставаться таковыми, поскольку данные в БД должны отражать об изменчивых объектах реального мира и отношениях между ними.</p>\r\n<p>Использование баз данных для хранения информации позволяет организовать централизованное управление данными, что обеспечивает следующие преимущества:</p>\r\n<ol>\r\n<li>возможность сокращения избыточности;</li>\r\n<li>возможность устранения (до некоторой степени) противоречивости;</li>\r\n<li>возможность общего доступа к данным;</li>\r\n<li>возможность соблюдения стандартов;</li>\r\n<li>возможность введения ограничений для обеспечения безопасности</li>\r\n<li>возможность обеспечения целостности данных;</li>\r\n<li>возможность сбалансировать противоречивые требования;</li>\r\n<li>возможность обеспечения независимости данных. Поскольку программное обеспечение отделяется от данных, хранимых БД, изменения, вносимые в структуру БД, в большинстве случаев не приводят к необходимости внесения радикальных изменений в программное обеспечение.</li>\r\n</ol>\r\n<p>&nbsp;</p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Как развивались базы данных?</li>\r\n<li>Что такое файловая система?</li>\r\n<li>Какие проблемы возникают при многопользовательском доступе?</li>\r\n<li>Что такое СУБД?</li>\r\n<li>Какие есть пользователи баз данных?</li>\r\n<li>Какие преимущества использования баз данных?</li>\r\n</ol>\r\n<p>&nbsp;</p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'Обзор\r\nИстория баз данных\r\nФайловые системы',0),(2,'2016-09-14 06:36:18','Лекция 2. Архитектура систем баз данных.',2,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>Три уровня архитектуры</li>\r\n<li>Внешний уровень</li>\r\n<li>Концептуальный уровень</li>\r\n<li>Внутренний уровень</li>\r\n<li>Системы управления базами данных</li>\r\n</ol>\r\n<p>&nbsp;</p>\r\n<p><strong>Ключевые слова: архитектура, пользователь, представление, функции СУБД.</strong></p>\r\n<p>&nbsp;</p>\r\n<p>Существует 3 уровня архитектуры СУБД:</p>\r\n<ol>\r\n<li>Внутренний уровень - наиболее близкий к физическому хранению. Он связан со способами хранения информации на физических устройствах хранения;</li>\r\n<li>Внешний уровень - наиболее близкий к пользователям. Он связан со способами представления данных для отдельных пользователей;</li>\r\n<li>Концептуальный уровень - является промежуточным между двумя первыми. Этот уровень связан с обобщенными представлениями пользователей, в отличие от внешнего уровня, связанного с индивидуальными представлениями пользователей.</li>\r\n</ol>\r\n<p><strong>Внешний уровень &ndash; внешнее представление.</strong></p>\r\n<p><strong><em>Внешний уровень</em></strong> &ndash; индивидуальный уровень пользователя. Пользователь может быть, как прикладным программистом, так и конечным пользователем с любым уровнем профессиональной подготовки. Каждый пользователь имеет свой язык общения с СУБД. Для программиста - это какой-либо язык программирования, для пользователя - язык запросов или язык, основанный на формах и меню. Любой из этих языков включает подъязык данных, т.е. множество операторов всего языка, связанное только с объектами и операциями баз данных. Т.о. подъязык данных встроен в базовый язык пользователя, который также обеспечивает на связанные с БД возможности.</p>\r\n<p>Представление отдельного пользователя о БД на внешнем уровне архитектуры называют внешним представлением. Т.о. внешнее представление &ndash; это содержимое БД, каким его видит отдельный пользователь. Например, сотрудник отдела кадров видит БД как набор записей о сотрудниках плюс набор записей о подразделениях. В общем случае внешнее представление состоит из множества экземпляров каждого типа внешней записи, которые не обязательно совпадают с хранимыми записями. Подъязык данных пользователя определен в терминах внешних записей. Каждое внешнее представление определяется средствами внешней схемы, которая, в основном, состоит из определений каждого типа записей во внешнем представлении.</p>\r\n<p><strong>Концептуальный уровень &ndash; концептуальное представление.</strong></p>\r\n<p><strong><em>Концептуальное представление </em></strong>&ndash; это представление всей информации БД в несколько более абстрактной форме по сравнению с физическим способом хранения данных. Концептуальное представление представляет данные такими, какими они есть на самом деле, а не такими, какими их вынужден видеть пользователь в рамках определенного языка. Концептуальное представление состоит из множества экземпляров каждого типа концептуальной записи, хотя в некоторых системах в способы концептуального представления данных могут быть другими - например, в виде объектов и связей между ними. Концептуальное представление определяется средствами концептуальной схемы, которая состоит из определений каждого типа концептуальных записей. При определении концептуальной схемы используется концептуальный язык определения данных, определения которого относятся только к содержанию информации. Концептуальное представление, т.о. обеспечивает независимость данных от способа их хранения.</p>\r\n<p><strong>Внутренний уровень &ndash; внутреннее представление.</strong></p>\r\n<p><strong><em>Внутреннее представление</em></strong> &ndash; это представление нижнего уровня всей БД. Оно состоит из множества экземпляров каждого типа внутренней записи. Внутренняя запись соответствует хранимой записи. Внутреннее представление не связано с физическим уровнем и в нем не рассматриваются физические записи. Внутреннее представление предполагает существование бесконечного линейного адресного пространства. Подробности отображения этого пространства на физические устройства хранения не включены в общую архитектуру из-за сильной зависимости от системы.</p>\r\n<p>Внутреннее представление описывается с помощью внутренней схемы, которая описывается с помощью внутреннего языка определения данных.</p>\r\n<p>Между тремя уровнями представлений имеются два уровня отображений. Отображения концептуального уровня на внутренний и внешний уровень на концептуальный. Отображения сохраняют независимость данных случае внесения в структуру БД изменений.</p>\r\n<p><strong>Функции СУБД.</strong></p>\r\n<ol>\r\n<li>Определение данных. СУБД должна допускать определения данных (внешние схемы, концептуальную и внутреннюю схемы, соответствующие отображения). Для этого СУБД включает в себя языковый процессор для различных языков определений данных.</li>\r\n<li>Обработка данных. СУБД должна обрабатывать запросы пользователя на выборку, а также модификацию данных. Для этого СУБД включает в себя компоненты процессора языка обработки данных.</li>\r\n<li>Безопасность и целостность данных. СУБД должна контролировать запросы и пресекать попытки нарушения правил безопасности и целостности.</li>\r\n<li>Восстановление данных и дублирование. СУБД должна обеспечить восстановление данных после сбоев.</li>\r\n<li>Словарь данных. СУБД должна обеспечить функцию словаря данных. Сам словарь можно считать системной базой данных, которая содержит данные о данных пользовательской БД, т.е. содержит определения других объектов системы. Словарь интегрирован в определяемую им БД и, поэтому, содержит описание самого себя.</li>\r\n<li>Производительность. СУБД должна выполнять свои функции с максимальной производительностью.</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Какие уровни архитектуры СУБД вы знаете?</li>\r\n<li>Какие промежуточные уровни существуют между 3-мя основными?</li>\r\n<li>Какие функции несет СУБД?</li>\r\n</ol>\r\n<p>&nbsp;</p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'Три уровня архитектуры\r\nВнешний уровень\r\nКонцептуальный уровень\r\nВнутренний уровень\r\nСистемы управления базами данных',0),(3,'2016-09-14 06:37:24','Лекция 3. Модели данных. ERP',3,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>Модели данных.</li>\r\n<li>Семантическое моделирование данных, ER-диаграммы</li>\r\n<li>Понятие сущности, атрибута и связи</li>\r\n<li>Три типа бинарных связей</li>\r\n<li>Диаграммы сущность-связь</li>\r\n</ol>\r\n<p>&nbsp;</p>\r\n<p><strong>Ключевые слова: модель данных, сущность, атрибут, сущность-связь</strong></p>\r\n<p>&nbsp;</p>\r\n<p><strong>Общие сведения об инфологическом моделировании</strong></p>\r\n<p>В базе данных отображается какая-то часть реального мира. Естественно, что полнота ее описания будет зависеть от целей создаваемой информационной системы.</p>\r\n<p>Для того чтобы база данных адекватно отражала предметную область, проектировщик базы данных должен хорошо представлять себе все нюансы, присущие данной предметной области (ПО), и уметь отобразить их в базе данных. Предметная область должна быть предварительно описана. Для этого в принципе может использоваться и естественный язык, но его применение имеет много недостатков, основными из них являются громоздкость описания и неоднозначность его трактовки. Поэтому обычно для этих целей используют искусственные формализованные языковые средства. В связи с этим под <strong><em>инфологической моделью</em></strong> (ИЛМ) понимают описание предметной области, выполненное с использованием специальных языковых средств, не зависящих от используемых в дальнейшем программных средств.</p>\r\n<p>Инфологическая модель должна строиться вне зависимости от того, будете ли вы в дальнейшем использовать какую-либо СУБД или пользоваться другими программными средствами для реализации своей информационной системы.</p>\r\n<p><strong>Требования, предъявляемые к инфологической модели</strong></p>\r\n<p>Основным требованием к ИЛМ, вытекающим из ее назначения, является требование адекватного отображения предметной области. ИЛМ должна быть непротиворечивой.</p>\r\n<p>Несмотря на то, что реальный мир, отображаемый в ИЛМ, является по своей природе бесконечным, инфологическая модель является конечной, что обеспечивается четким ограничением предметной области. ИЛМ должна в связи с этим обладать свойством легкой расширяемости, обеспечивающим ввод новых данных без изменения ранее определенных. То же самое можно сказать и об удалении данных. В связи с большой размерностью реальных инфологических моделей должна обеспечиваться возможность композиции и декомпозиции модели.</p>\r\n<p>Инфологическая модель должна легко восприниматься разными категориями пользователей. Желательно, чтобы ИЛМ строил специалист, работающий в этой предметной области, а не проектировщик систем машинной обработки данных или хотя бы проверить сделанное описание, чтобы убедиться, что специфика предметной области воспринята правильно. Инфологическая модель должна также легко и однозначно восприниматься всеми специалистами, которые в дальнейшем участвуют в процессе проектирования баз данных и программного обеспечения.</p>\r\n<p>Она является ядром системы проектирования. ИЛМ содержит необходимую и достаточную информацию для дальнейшего проектирования автоматизированной системы обработки информации.</p>\r\n<p><strong>Компоненты инфологической модели</strong></p>\r\n<p>Инфологическая модель предметной области включает в себя ряд компонентов (рис. 3.1). Центральной компонентой мифологической модели является описание объектов предметной области и связей между ними (ER-модель).</p>\r\n<table width=\"100%\">\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p>Инфологическая модель</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<table width=\"100%\">\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p>Описание объектов и связей между ними (ER-модель)</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<table width=\"100%\">\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p>Описание информационных потребностей пользователя</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<table width=\"100%\">\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p>Алгоритмические связи показателей</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<table width=\"100%\">\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p>Лингвистические отношения</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<table width=\"100%\">\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p>Ограничение целостности</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>Построение модели &ldquo;ОБЪЕКТ &ndash;СВОЙСТВО&ndash;ОТНОШЕНИЕ&rdquo;</strong></p>\r\n<p>Для описания ИЛМ используются как языки аналитического (описательного) типа, так и графические средства в дальнейшем применяется графический способ отображения модели &ldquo;объект&mdash;свойство&mdash;отношение&rdquo;. В предметной области в процессе ее обследования и анализа выделяют классы объектов. Классом объектов называют совокупность объектов, обладающих одинаковым набором свойств. Например, если в качестве предметной области рассмотреть вуз, то в ней можно выделить следующие классы объектов: учащиеся, преподаватели, аудитории и т. д. Объекты могут быть реальными, как названные выше, а могут быть и абстрактными, как, например, предметы, которые изучают студенты.</p>\r\n<p>При отражении в информационной системе каждый объект представляется своим идентификатором, который отличает один объект класса от другого, а каждый класс объектов представляется именем этого класса. Так, для объектов класса &ldquo;ИЗУЧАЕМЫЕ ПРЕДМЕТЫ&rdquo; идентификатором каждого объекта будет &ldquo;НАЗВАНИЕ ПРЕДМЕТА&rdquo;. Идентификатор должен быть уникальным.</p>\r\n<p>Каждый объект обладает определенным набором свойств. Для объектов одного класса набор этих свойств одинаков, а их значения, естественно, могут различаться. Например, для объектов класса &ldquo;СТУДЕНТ&rdquo; таким набором свойств, описывающим объекты класса, может быть &ldquo;ГОД РОЖДЕНИЯ&rdquo;, &ldquo;ПОЛ&rdquo; и др.</p>\r\n<p>При описании предметной области надо изобразить каждый из существующих классов объектов и набор свойств, фиксируемый для объектов данного класса.</p>\r\n<p>Будем использовать для отображения объектов и их свойств следующие обозначения (рис. 3.2).</p>\r\n<p>&nbsp;</p>\r\n<p>Каждому классу объектов в инфологической модели присваивается уникальное имя.</p>\r\n<p>При построении инфологической модели желательно дать словесную интерпретацию каждой сущности, особенно если возможно неоднозначное толкование понятия.</p>\r\n<p>При описании предметной области надо отразить связи между объектом и характеризующими его свойствами. Это изображается просто в виде линии, соединяющей обозначение объекта и его свойств.</p>\r\n<p>Связь между объектом и его свойством может быть различной. Объект может обладать только одним значением какого-то свойства. Например, каждый человек может иметь только одну дату рождения. Назовем такие свойства единичными. Для других свойств возможно существование одновременно нескольких значений у одного объекта. Пусть, например, при описании &ldquo;СОТРУДНИКА&rdquo; фиксируется в качестве его свойства &ldquo;ИНОСТРАННЫЙ ЯЗЫК&rdquo;, которым он владеет. Так как сотрудник может знать несколько иностранных языков, то такое свойство будем называть&nbsp; множественным. При изображении связи между объектом и его свойствами для единичных свойств будем использовать одинарную стрелку, а для множественных свойств &mdash; двойную.</p>\r\n<p>Кроме того, некоторые свойства являются постоянными, их значение не может измениться с течением времени. Назовем такие свойства&nbsp;&nbsp; статическими, а те свойства, значение которых может изменяться со временем, будем называть динамическими.</p>\r\n<p>Другой характеристикой связи между объектом и его свойством является признак того, присутствует ли это свойство у всех объектов данного класса либо отсутствует у некоторых объектов. Например, для отдельных служащих может иметь место свойство &ldquo;УЧЕНАЯ СТЕПЕНЬ&rdquo;, а другие объекты этого класса могут не обладать, указанным свойством. Назовем такие свойства условными.</p>\r\n<p>В инфологической модели отображаются не отдельные экземпляры объектов, а классы объектов. Когда в ИЛМ изображено обозначение объекта, то ясно, что речь идет о классе объектов, обладающих описанными свойствами. Поэтому в инфологическую модель в большинстве случаев можно в явном виде не вводить еще и обозначение для класса объектов. Явное изображение класса объектов необходимо только в том случае, если в ПО для данного класса объектов фиксируются не только характеристики, относящиеся к отдельным объектам этого класса, но и какие-то интегральные характеристики, относящиеся ко всему классу в целом. Например, если для класса объектов &ldquo;СОТРУДНИКИ ПРЕДПРИЯТИЯ&rdquo; фиксируется не только возраст каждого из сотрудников, но и средний возраст всех сотрудников, то в инфологической модели необходимо отразить не только объект &ldquo;СОТРУДНИК&rdquo;, но и класс объектов &ldquo;СОТРУДНИКИ&rdquo;. Для отображения класса объектов можно использовать какое-то специфическое обозначение или такое же, которое используется для объектов.</p>\r\n<p><a name=\"_Toc286846098\"></a><strong>Семантическое моделирование данных, ER-диаграммы</strong></p>\r\n<p>Широкое распространение реляционных СУБД и их использование в самых разнообразных приложениях показывает, что реляционная модель данных достаточна для моделирования предметных областей. Однако проектирование реляционной базы данных в терминах отношений на основе кратко рассмотренного нами механизма нормализации часто представляет собой очень сложный и неудобный для проектировщика процесс.</p>\r\n<p>При этом проявляется ограниченность реляционной модели данных в следующих аспектах:</p>\r\n<ul>\r\n<li>Модель не предоставляет достаточных средств для представления смысла данных. Семантика реальной предметной области должна независимым от модели способом представляться в голове проектировщика. В частности, это относится к упоминавшейся нами проблеме представления ограничений целостности.</li>\r\n<li>Для многих приложений трудно моделировать предметную область на основе плоских таблиц. В ряде случаев на самой начальной стадии проектирования проектировщику приходится производить насилие над собой, чтобы описать предметную область в виде одной (возможно, даже ненормализованной) таблицы.</li>\r\n<li>Хотя весь процесс проектирования происходит на основе учета зависимостей, реляционная модель не предоставляет каких-либо средств для представления этих зависимостей.</li>\r\n<li>Несмотря на то, что процесс проектирования начинается с выделения некоторых существенных для приложения объектов предметной области (\"сущностей\") и выявления связей между этими сущностями, реляционная модель данных не предлагает какого-либо аппарата для разделения сущностей и связей.</li>\r\n</ul>\r\n<p>На использовании разновидностей ER-модели основано большинство современных подходов к проектированию баз данных (главным образом, реляционных). Модель была предложена Ченом (Chen) в 1976 г. Моделирование предметной области базируется на использовании графических диаграмм, включающих небольшое число разнородных компонентов. В связи с наглядностью представления концептуальных схем баз данных ER-модели получили широкое распространение в системах CASE, поддерживающих автоматизированное проектирование реляционных баз данных. Среди множества разновидностей ER-моделей одна из наиболее развитых применяется в системе CASE фирмы ORACLE. Ее мы и рассмотрим. Более точно, мы сосредоточимся на структурной части этой модели.</p>\r\n<p>Основными понятиями ER-модели являются сущность, связь и атрибут.</p>\r\n<p><strong><em>Сущность</em></strong> &ndash; это реальный или представляемый объект, информация о котором должна сохраняться и быть доступна. В диаграммах ER-модели сущность представляется в виде прямоугольника, содержащего имя сущности. При этом имя сущности - это имя типа, а не некоторого конкретного экземпляра этого типа. Для большей выразительности и лучшего понимания имя сущности может сопровождаться примерами конкретных объектов этого типа.</p>\r\n<p>Ниже изображена сущность АЭРОПОРТ с примерными объектами Шереметьево и Хитроу:</p>\r\n<p>Рис 3.4 Пример сущности.</p>\r\n<p>Каждый экземпляр сущности должен быть отличим от любого другого экземпляра той же сущности (это требование в некотором роде аналогично требованию отсутствия кортежей-дубликатов в реляционных таблицах).</p>\r\n<p><strong><em>Связь</em></strong> &ndash; это графически изображаемая ассоциация, устанавливаемая между двумя сущностями. Эта ассоциация всегда является бинарной и может существовать между двумя разными сущностями или между сущностью и ей же самой (рекурсивная связь). В любой связи выделяются два конца (в соответствии с существующей парой связываемых сущностей), на каждом из которых указывается имя конца связи, степень конца связи (сколько экземпляров данной сущности связывается), обязательность связи (т.е. любой ли экземпляр данной сущности должен участвовать в данной связи).</p>\r\n<p>Связь представляется в виде линии, связывающей две сущности или ведущей от сущности к ней же самой. При это в месте \"стыковки\" связи с сущностью используются трехточечный вход в прямоугольник сущности, если для этой сущности в связи могут использоваться много (many) экземпляров сущности, и одноточечный вход, если в связи может участвовать только один экземпляр сущности. Обязательный конец связи изображается сплошной линией, а необязательный - прерывистой линией.</p>\r\n<p>Как и сущность, связь &ndash; это типовое понятие, все экземпляры обеих пар связываемых сущностей подчиняются правилам связывания.</p>\r\n<p>В изображенном ниже примере связь между сущностями БИЛЕТ и ПАССАЖИР связывает билеты и пассажиров. При том конец сущности с именем \"для\" позволяет связывать с одним пассажиром более одного билета, причем каждый билет должен быть связан с каким-либо пассажиром. Конец сущности с именем \"имеет\" означает, что каждый билет может принадлежать только одному пассажиру, причем пассажир не обязан иметь хотя бы один билет.</p>\r\n<p>Рис 3.5 пример связи</p>\r\n<p>Лаконичной устной трактовкой изображенной диаграммы является следующая:</p>\r\n<ul>\r\n<li>Каждый БИЛЕТ предназначен для одного и только одного ПАССАЖИРА;</li>\r\n<li>Каждый ПАССАЖИР может иметь один или более БИЛЕТОВ.</li>\r\n<li>На следующем примере изображена рекурсивная связь, связывающая сущность ЧЕЛОВЕК с ней же самой. Конец связи с именем \"сын\" определяет тот факт, что у одного отца может быть более чем один сын. Конец связи с именем \"отец\" означает, что не у каждого человека могут быть сыновья.</li>\r\n</ul>\r\n<p>Рис 3.6 Реккурсивная связь</p>\r\n<p>Лаконичной устной трактовкой изображенной диаграммы является следующая:</p>\r\n<ul>\r\n<li>Каждый ЧЕЛОВЕК является сыном одного и только одного ЧЕЛОВЕКА;</li>\r\n<li>Каждый ЧЕЛОВЕК может являться отцом для одного или более ЛЮДЕЙ (\"ЧЕЛОВЕКОВ\").</li>\r\n</ul>\r\n<p><strong><em>Атрибутом сущности</em></strong> является любая деталь, которая служит для уточнения, идентификации, классификации, числовой характеристики или выражения состояния сущности. Имена атрибутов заносятся в прямоугольник, изображающий сущность, под именем сущности и изображаются малыми буквами, возможно, с примерами.</p>\r\n<p><a name=\"_Toc286846099\"></a><strong>Три типа бинарных связей</strong></p>\r\n<p>На рис. 3.7 показаны три типа бинарных связей. В связи 1:1 (&laquo;один к одному&raquo;) одиночный экземпляр сущности одного типа связан с одиночным экземпляром сущности другого типа. На рис. 3.7, а связь СЛУЖЕБНЫЙ_АВТОМОБИЛЬ связывает одиночную сущность класса СОТРУДНИК с одиночной сущностью класса АВТОМОБИЛЬ. В соответствии с этой диаграммой, ни за одним сотрудником не закреплено более одного автомобиля, и ни один автомобиль не закреплен более чем за одним сотрудником.</p>\r\n<p>Рис 3.7 Три типа бинарных связей.</p>\r\n<p>На рис. 3.7, б изображен второй тип связи, 1:N (&laquo;один к N&raquo; или &laquo;один ко многим&raquo;), В этой связи, которая называется ОБЩЕЖИТИЕ-ЖИЛЕЦ, единичный экземпляр сущности класса ОБЩЕЖИТИЕ связан со многими экземплярами сущности класса СТУДЕНТ. В соответствии с этим рисунком, в общежитии проживает много студентов, но каждый студент живет только в одном общежитии.</p>\r\n<p>Позиция, в которой стоят 1 и N, имеет значение. Единица стоит на той стороне связи, где располагается ОБЩЕЖИТИЕ, а N стоит на той стороне связи, где располагается СТУДЕНТ. Если бы 1 и N располагались наоборот, и связь записывалась бы как N:l, получилось бы, что в общежитии живет один студент, причем каждый студент живет в нескольких общежитиях. Это, разумеется, не так. На рис.7, в показан третий тип бинарной связи, N:M (читается &laquo;N к М&raquo; или &laquo;многие ко многим&raquo;). Эта связь называется СТУДЕНТ-КЛУБ, и она связывает экземпляры сущностей класса СТУДЕНТ с экземплярами сущностей класса КЛУБ. Один студент может быть членом нескольких клубов, а в одном клубе может состоять много студентов.</p>\r\n<p>Числа внутри ромба, символизирующего связь, обозначают максимальное количество сущностей на каждой стороне связи. Эти ограничения называются максимальными кардинальными числами, а совокупность из двух таких ограничений для обеих сторон связи называется максимальной кардинальностью (maximum cardinality) связи. Например, о связи, изображенной на рис. 3.3, б, говорят, что она обладает максимальной кардинальностью 1:N. Кардинальные числа могут иметь и другие значения, а не только 1 и N. Например, связь между сущностями БАСКЕТБОЛЬНАЯ КОМАНДА и ИГРОК может иметь кардинальность 1:5, что говорит нам о том, что в баскетбольной команде может быть не более пяти игроков.</p>\r\n<p>Связи трех типов, представленных на рис. 7, называются иногда связями типа &laquo;ИМЕЕТ&raquo;, или связями обладания (HAS-A relationships). Такой термин используется потому, что одна сущность имеет (has) связь с другой сущностью. Например: сотрудник имеет автомобиль, студент имеет общежитие, клуб имеет студентов.</p>\r\n<p><a name=\"_Toc286846100\"></a><strong>Более сложные элементы ER-модели</strong></p>\r\n<p>Мы остановились только на самых основных и наиболее очевидных понятиях ER-модели данных. К числу более сложных элементов модели относятся следующие:</p>\r\n<ul>\r\n<li>Подтипы и супертипы сущностей. Как в языках программирования с развитыми типовыми системами (например, в языках объектно-ориентированного программирования), вводится возможность наследования типа сущности, исходя из одного или нескольких супертипов. Интересные нюансы связаны с необходимостью графического изображения этого механизма.</li>\r\n<li>Связи \"many-to-many\". Иногда бывает необходимо связывать сущности таким образом, что с обоих концов связи могут присутствовать несколько экземпляров сущности (например, все члены кооператива сообща владеют имуществом кооператива). Для этого вводится разновидность связи \"многие-со-многими\".</li>\r\n<li>Уточняемые степени связи. Иногда бывает полезно определить возможное количество экземпляров сущности, участвующих в данной связи (например, служащему разрешается участвовать не более, чем в трех проектах одновременно). Для выражения этого семантического ограничения разрешается указывать на конце связи ее максимальную или обязательную степень.</li>\r\n<li>Каскадные удаления экземпляров сущностей. Некоторые связи бывают настолько сильными (конечно, в случае связи \"один-ко-многим\"), что при удалении опорного экземпляра сущности (соответствующего концу связи \"один\") нужно удалить и все экземпляры сущности, соответствующие концу связи \"многие\". Соответствующее требование \"каскадного удаления\" можно сформулировать при определении сущности.</li>\r\n<li>Домены. Как и в случае реляционной модели данных бывает полезна возможность определения потенциально допустимого множества значений атрибута сущности (домена).</li>\r\n</ul>\r\n<p><a name=\"_Toc286846101\"></a><strong>Диаграммы сущность-связь</strong></p>\r\n<p>Схемы, изображенные на рис. 3.8, называются диаграммами &laquo;сущность&mdash;связь&raquo;, или ER-диаграммами (entity-relationship diagrams, ER-diagrams). Такие диаграммы стандартизированы, но не слишком жестко. В соответствии с этим стандартом, классы сущностей обозначаются прямоугольниками, связи обозначаются ромбами, а максимальное кардинальное число каждой связи указывается внутри ромба1. Имя сущности указывается внутри прямоугольника, а имя связи указывается рядом с ромбом.</p>\r\n<p>Рис 3.8 Пример диаграммы &laquo;сущность-связь&raquo;</p>\r\n<p>&nbsp;</p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Что такое сущность?</li>\r\n<li>Что такое связь?</li>\r\n<li>Зачем применяется моделирование?</li>\r\n<li>Сколько типов бинарных связей вы знаете?</li>\r\n<li>Какие более сложные элементы схемы сущность-связь вы знаете?</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'Модели данных.\r\nСемантическое моделирование данных, ER-диаграммы\r\nПонятие сущности, атрибута и связи\r\nТри типа бинарных связей\r\nДиаграммы сущность-связь',0),(4,'2016-09-14 06:37:57','Лекция 4.  Реляционная модель.',4,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>История реляционной модели.</li>\r\n<li>Термины реляционной модели</li>\r\n<li>Преимущества и недостатки реляционной модели.</li>\r\n<li>Свойства отношений в реляционных базах данных</li>\r\n</ol>\r\n<p>&nbsp;</p>\r\n<p><strong>Ключевые слова: декартово произведение, домен, кортеж, отношение, объединение, пересечение, разность.</strong></p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p>Теоретической основой этой модели стала теория отношений, основу которой заложили два логика &mdash; американец Чарльз Содерс Пирс (1839-1914) и немец Эрнст Шредер (1841-1902). В руководствах по теории отношений было показано, что множество отношений замкнуто относительно некоторых специальных операций, то есть образует вместе с этими операциями абстрактную алгебру. Это важнейшее свойство отношений было использовано в реляционной модели для разработки языка манипулирования данными, связанного с исходной алгеброй.</p>\r\n<p>Будучи математиком по образованию Э.Кодд предложил использовать для обработки данных аппарат теории множеств (объединение, пересечение, разность, декартово произведение). Он показал, что любое представление данных сводится к совокупности двумерных таблиц особого вида, известного в математике как отношение &ndash; relation.</p>\r\n<p>Предложения Кодда были настолько эффективны для систем баз данных, что за эту модель он был удостоен престижной премии Тьюринга в области теоретических основ вычислительной техники.</p>\r\n<p>В настоящее время основным предметом критики реляционных СУБД является не их недостаточная эффективность, а следующие недостатки:</p>\r\n<ol>\r\n<li>присущая этим системам некоторая ограниченность (прямое следствие простоты) при использовании в так называемых нетрадиционных областях (наиболее распространенными примерами являются системы автоматизации проектирования), в которых требуются предельно сложные структуры данных.</li>\r\n<li>невозможность адекватного отражения семантики предметной области. Другими словами, возможности представления знаний о семантической специфике предметной области в реляционных системах очень ограничены. Современные исследования в области постреляционных систем главным образом посвящены именно устранению этих недостатков.</li>\r\n</ol>\r\n<p>Наименьшая единица данных реляционной модели &ndash; это отдельное атомарное (неразложимое) для данной модели значение данных. Так, в одной предметной области фамилия, имя и отчество могут рассматриваться как единое значение, а в другой &ndash; как три различных значения.</p>\r\n<p><strong><em>Доменом</em></strong> называется множество атомарных значений одного и того же типа. Наиболее правильной интуитивной трактовкой понятия домена является понимание домена как допустимого потенциального множества значений данного типа. Например, домен \"Имена\" в нашем примере определен на базовом типе строк символов, но в число его значений могут входить только те строки, которые могут изображать имя (в частности, такие строки не могут начинаться с мягкого знака).</p>\r\n<p>Следует отметить также семантическую нагрузку понятия домена: данные считаются сравнимыми только в том случае, когда они относятся к одному домену. В нашем примере значения доменов \"Номера пропусков\" и \"Номера групп\" относятся к типу целых чисел, но не являются сравнимыми. Заметим, что в большинстве реляционных СУБД понятие домена не используется, хотя в Oracle V.7 оно уже поддерживается.</p>\r\n<p>Вхождение домена в отношение принято называть <strong><em>атрибутом</em></strong>.</p>\r\n<p><strong><em>Схема отношения</em></strong> &ndash; это именованное множество пар {имя атрибута, имя домена (или типа, если понятие домена не поддерживается)}&nbsp;&nbsp;&nbsp;</p>\r\n<p><strong><em>Кортеж</em></strong>, соответствующий данной схеме отношения, &ndash; это множество пар {имя атрибута, значение}, которое содержит одно вхождение каждого имени атрибута, принадлежащего схеме отношения. \"Значение\" является допустимым значением домена данного атрибута (или типа данных, если понятие домена не поддерживается). Тем самым, степень или \"арность\" кортежа, т.е. число элементов в нем, совпадает с \"арностью\" соответствующей схемы отношения. Попросту говоря, кортеж - это набор именованных значений заданного типа.</p>\r\n<p><strong><em>Ключ (key)</em></strong> &mdash; это группа из одного или более атрибутов, которая уникальным образом идентифицирует строку. Рассмотрим отношение СЕКЦИЯ (рис. 5.3), имеющее атрибуты НомерСтудента, Секция и Плата. Строка этого отношения содержит информацию о том, что студент посещает определенную секцию за определенную плату.&nbsp;</p>\r\n<p><strong><em>Отношение</em></strong> &ndash; это множество кортежей, соответствующих одной схеме отношения. Иногда, чтобы не путаться, говорят \"отношение-схема\" и \"отношение-экземпляр\", иногда схему отношения называют заголовком отношения, а отношение как набор кортежей - телом отношения. На самом деле, понятие схемы отношения ближе всего к понятию структурного типа данных в языках программирования. Было бы вполне логично разрешать отдельно определять схему отношения, а затем одно или несколько отношений с данной схемой.</p>\r\n<p>Обычным житейским представлением отношения является двумерная таблица. Каждая строка в таблице содержит данные, относящиеся к некоторой вещи или какой-то ее части. Каждый столбец таблицы описывает какой-либо атрибут этой вещи. Иногда строки называются кортежами (tuples), а столбцы &mdash; атрибутами (attributes).</p>\r\n<p>Вышеупомянутые и некоторые другие математические понятия явились теоретической базой для создания реляционных СУБД, разработки соответствующих языковых средств и программных систем, обеспечивающих их высокую производительность, и создания основ теории проектирования баз данных. Однако для массового пользователя реляционных СУБД можно с успехом использовать неформальные эквиваленты этих понятий:</p>\r\n<ul>\r\n<li>Отношение &ndash; Таблица (иногда Файл);</li>\r\n<li>Кортеж &ndash; Строка (иногда Запись);</li>\r\n<li>Атрибут &ndash; Столбец, Поле.</li>\r\n</ul>\r\n<p><strong><em>Реляционная база данных</em></strong> &ndash; это совокупность отношений, содержащих всю информацию, которая должна храниться в БД. Однако пользователи могут воспринимать такую базу данных как совокупность таблиц.</p>\r\n<p>Преимущества реляционнной модели:</p>\r\n<ul>\r\n<li>Эта модель данных отображает информацию в наиболее простой для пользователя форме</li>\r\n<li>Основана на развитом математи-ческом аппарате, который позволяет достаточно лаконично описать основные операции над данными.</li>\r\n<li>Позволяет создавать языки манипулирования данными не процедурного типа.</li>\r\n<li>Манипулирование данными на уровне выходной БД и возможность изменения.</li>\r\n</ul>\r\n<p>Недостатки реляционной модели:</p>\r\n<ul>\r\n<li>Самый медленный доступ к данным.</li>\r\n<li>Трудоемкость разработки</li>\r\n</ul>\r\n<p>Чтобы таблица была отношением, она должна удовлетворять определенным ограничениям:</p>\r\n<ol>\r\n<li>Во-первых, значения в ячейках таблицы должны быть одиночными &mdash; ни повторяющиеся группы, ни массивы не допускаются</li>\r\n<li>Строки имеют фиксированное число полей (столбцов) и значений (множественные поля и повторяющиеся группы недопустимы). Иначе говоря, в каждой позиции таблицы на пересечении строки и столбца всегда имеется в точности одно значение или ничего.</li>\r\n<li>Строки таблицы обязательно отличаются друг от друга хотя бы единственным значением, что позволяет однозначно идентифицировать любую строку такой таблицы.</li>\r\n<li>Все записи в столбце должны быть одного типа Например, если третий столбец первой строки таблицы содержит номер сотрудника, то и во всех остальных строках таблицы третий столбец также должен содержать номер сотрудника. Каждый столбец имеет уникальное имя; порядок столбцов в таблице несуществен. Наконец, в отношении не может быть двух одинаковых строк, и порядок строк не имеет значения.</li>\r\n<li>Полное информационное содержание базы данных представляется в виде явных значений данных и такой метод представления является единственным.</li>\r\n<li>При выполнении операций с таблицей ее строки и столбцы можно обрабатывать в любом порядке безотносительно к их информационному содержанию. Этому способствует наличие имен таблиц и их столбцов, а также возможность выделения любой их строки или любого набора строк с указанными признаками (например, рейсов с пунктом назначения \"Париж\" и временем прибытия до 12 часов).</li>\r\n</ol>\r\n<p>Предложив реляционную модель данных, Э.Ф.Кодд создал и инструмент для удобной работы с отношениями &ndash; реляционную алгебру. Каждая операция этой алгебры использует одну или несколько таблиц (отношений) в качестве ее операндов и продуцирует в результате новую таблицу, т.е. позволяет \"разрезать\" или \"склеивать\" таблицы (рис. 4.1).</p>\r\n<p>&nbsp;</p>\r\n<p>Рис. 4.1 Некоторые операции реляционной алгебры.</p>\r\n<p>На рис. 4.2 представлен пример отношения. Отношение имеет семь строк, в каждой из которых четыре столбца. Если бы мы расположили столбцы в ином порядке (скажем, поместив Табельный Номер в крайний левый столбец) или переставили бы строки (например, по возрастанию значения столбца Возраст), мы получили бы эквивалентное отношение.</p>\r\n<p>Рис. 4.2 Пример отношения &laquo;Сотрудник&raquo;.</p>\r\n<p><strong>Свойства отношений.</strong></p>\r\n<p>Реляционное отношение обладает следующими свойствами.</p>\r\n<ul>\r\n<li>В отношении нет одинаковых кортежей.</li>\r\n<li>Кортежи отношения не упорядочены (сверху вниз).</li>\r\n<li>Атрибуты отношения не упорядочены (слева направо).</li>\r\n<li>Все значения атрибутов атомарны (скалярны, неделимы).</li>\r\n</ul>\r\n<p><strong>Отсутствие в отношении одинаковых кортежей.</strong></p>\r\n<p>Это свойство следует из того факта, что тело отношения &ndash; это математическое множество (кортежей). В классической теории множеств по определению множество не содержит одинаковых элементов.</p>\r\n<p>Это свойство является одним из примеров отмечаемой выше неэквивалентности понятий отношение и таблица. Таблица (в общем случае) может содержать одинаковые строки и, следовательно, таблица, содержащая одинаковые строки, не может быть отношением по определению.</p>\r\n<p>Важным следствием того, что в отношении нет одинаковых строк-кортежей, является то, что в отношении всегда существует по крайней мере один потенциальный ключ. Действительно, так как кортежи уникальны, то обязательно комбинация всех или части атрибутов будет обладать свойством уникальности, и, следовательно, может служить ключом отношения, однозначно идентифицирующим кортежи.</p>\r\n<p><strong>Кортежи отношения не упорядочены (сверху вниз).</strong></p>\r\n<p>Это свойство также следует из того, что тело отношения &ndash; это математическое множество, а простые множества в математике не упорядочены. Так, в отношении, представленном на рис. 6.1, кортежи могли быть расположены в любом другом порядке, и, тем не менее, это все равно было бы то же самое отношение. Исходя из сказанного, к отношению не применимы такие понятия, как первый кортеж, последний кортеж, десятый кортеж, следующий или предыдущий кортеж и т. д. Другими словами, в отношении отсутствует позиционной адресация кортежей.</p>\r\n<p>&nbsp;</p>\r\n<p>Обращение к конкретному кортежу, его идентификация могут быть осуществлены только по ключу отношения.</p>\r\n<p>Это свойство также служит иллюстрацией не эквивалентности понятий отношение и таблица. В отличие от отношения, строки в таблице всегда упорядочены &ndash; есть первая строка, вторая, последняя и т. д.</p>\r\n<p><strong>Атрибуты отношения не упорядочены (слева направо).</strong></p>\r\n<p>Это свойство следует из того факта, что заголовок отношения также определен как простое математическое множество, а именно: множество пар&nbsp; &lt;имя‑атрибута: имя-домена&gt;.</p>\r\n<p>Исходя из этого, если в представленной на рис. 4.3 таблице те же атрибуты были бы расставлены в каком-либо другом порядке, то это все равно было бы то же самое отношение. Поэтому не существует таких понятий, как первый атрибут, последний атрибут, следующий или предыдущий атрибут и т. д. Атрибут всегда адресуется или определятся по его имени, а не по расположению в отношении.</p>\r\n<p>Рис.&nbsp; 4.3. Отношение и его компоненты</p>\r\n<p>По этому пункту понятия отношение и таблица также не совпадают. Столбцы обычной таблицы, в отличие от атрибутов отношения, всегда упорядочены слева направо.</p>\r\n<p><strong>Значения всех атрибутов являются атомарными.</strong></p>\r\n<p>В реляционной модели домены, на которых определены атрибуты отношения, и из которых &laquo;черпаются&raquo; фактические значения атрибутов, могут содержать только атомарные (неделимые, скалярные) значения. Другими словами на пересечении столбца и строки таблицы, представляющей отношение, должно быть в точности одно значение, а не набор значений или какая либо сложная (составная) структура значений.</p>\r\n<p>Отношение, удовлетворяющее этому условию, называется нормализованным, или представленным в первой нормальной форме (другие нормальные формы будут обсуждаться позже, в следующих разделах).</p>\r\n<p>Из сказанного следует, что реляционная модель рассматривает только нормализованные отношения, хотя отношение, понимаемое в математическом смысле, в общем случае может быть и ненормализованным. В качестве значений атрибутов ненормализованного отношения могут использоваться и более сложные структуры значений, например другие отношения.</p>\r\n<p>Примером ненормализованного отношения может служить приведенная на рисунке 4.4 таблица Отношение&ensp;1. Как следует из вышесказанного, в реляционной модели отношения такого вида являются недопустимыми. Следует, однако, заметить, что это ограничение ни в коем смысле не ограничивает нас с точки зрения самой возможности отражения необходимой информации. Так вся информация, представленная в ненормализованном отношении Отношение&ensp;1, может быть полностью представлена в виде нормализованного отношения Отношение&ensp;2.</p>\r\n<p>Рис. 4.4. Пример&nbsp;ненормализованного и нормализованного отношений</p>\r\n<p>С математической точки зрения требование использования только нормализованных отношений позволяет (за счет более простой их структуры) упростить операторы для работы с отношениями и уменьшить их количество, не ограничивая возможности адекватного отображения информационного содержания предметной области, так как для любого ненормализованного отношения существует эквивалентная ему нормализованная форма.</p>\r\n<p>Созданы языки манипулирования данными, позволяющие реализовать все операции реляционной алгебры и практически любые их сочетания. Среди них наиболее распространены SQL (Structured Query Language &ndash; структуризованный язык запросов) и QBE (Quere-By-Example &ndash; запросы по образцу). Оба относятся к языкам очень высокого уровня, с помощью которых пользователь указывает, какие данные необходимо получить, не уточняя процедуру их получения.</p>\r\n<p>С помощью единственного запроса на любом из этих языков можно соединить несколько таблиц во временную таблицу и вырезать из нее требуемые строки и столбцы (селекция и проекция).</p>\r\n<p><a name=\"_Toc286848066\"></a><strong>Получение реляционной схемы из ER-схемы</strong></p>\r\n<p><strong>Шаг 1.</strong> Каждая простая сущность превращается в таблицу. Простая сущность - сущность, не являющаяся подтипом и не имеющая подтипов. Имя сущности становится именем таблицы.</p>\r\n<p><strong>Шаг 2.</strong> Каждый атрибут становится возможным столбцом с тем же именем; может выбираться более точный формат. Столбцы, соответствующие необязательным атрибутам, могут содержать неопределенные значения; столбцы, соответствующие обязательным атрибутам, - не могут.</p>\r\n<p><strong>Шаг 3.</strong> Компоненты уникального идентификатора сущности превращаются в первичный ключ таблицы. Если имеется несколько возможных уникальных идентификатора, выбирается наиболее используемый. Если в состав уникального идентификатора входят связи, к числу столбцов первичного ключа добавляется копия уникального идентификатора сущности, находящейся на дальнем конце связи (этот процесс может продолжаться рекурсивно). Для именования этих столбцов используются имена концов связей и/или имена сущностей.</p>\r\n<p><strong>Шаг 4.</strong> Связи многие-к-одному (и один-к-одному) становятся внешними ключами. Т.е. делается копия уникального идентификатора с конца связи \"один\", и соответствующие столбцы составляют внешний ключ. Необязательные связи соответствуют столбцам, допускающим неопределенные значения; обязательные связи - столбцам, не допускающим неопределенные значения.</p>\r\n<p><strong>Шаг 5.</strong> Индексы создаются для первичного ключа (уникальный индекс), внешних ключей и тех атрибутов, на которых предполагается в основном базировать запросы.</p>\r\n<p><strong>Шаг 6.</strong> Если в концептуальной схеме присутствовали подтипы, то возможны два способа:</p>\r\n<ul>\r\n<li>все подтипы в одной таблице (а)</li>\r\n<li>для каждого подтипа - отдельная таблица (б)</li>\r\n</ul>\r\n<p>При применении способа (а) таблица создается для наиболее внешнего супертипа, а для подтипов могут создаваться представления. В таблицу добавляется по крайней мере один столбец, содержащий код ТИПА; он становится частью первичного ключа.</p>\r\n<p>При использовании метода (б) для каждого подтипа первого уровня (для более нижних - представления) супертип воссоздается с помощью представления UNION (из всех таблиц подтипов выбираются общие столбцы - столбцы супертипа).</p>\r\n<table width=\"100%\">\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p><strong>Все в одной таблице</strong></p>\r\n</td>\r\n<td>\r\n<p><strong>Таблица - на подтип</strong></p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n<p><em>Преимущества</em></p>\r\n</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n<p>Все хранится вместе<br /> Легкий доступ к супертипу и подтипам<br /> Требуется меньше таблиц</p>\r\n</td>\r\n<td>\r\n<p>Более ясны правила подтипов<br /> Программы работают только с нужными таблицами</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n<p><em>Недостатки</em></p>\r\n</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n<p>Слишком общее решение<br /> Требуется дополнительная логика работы с разными наборами столбцов и разными ограничениями<br /> Потенциальное узкое место (в связи с блокировками)<br /> Столбцы подтипов должны быть необязательными<br /> В некоторых СУБД для хранения неопределенных значений требуется дополнительная память</p>\r\n</td>\r\n<td>\r\n<p>Слишком много таблиц<br /> Смущающие столбцы в представлении UNION<br /> Потенциальная потеря производительности при работе через UNION<br /> Над супертипом невозможны модификации</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>Шаг 7.</strong> Имеется два способа работы при наличии исключающих связей:</p>\r\n<ul>\r\n<li>общий домен (а)</li>\r\n<li>явные внешние ключи (б)</li>\r\n</ul>\r\n<p>Если остающиеся внешние ключи все в одном домене, т.е. имеют общий формат (способ (а)), то создаются два столбца: идентификатор связи и идентификатор сущности. Столбец идентификатора связи используется для различения связей, покрываемых дугой исключения. Столбец идентификатора сущности используется для хранения значений уникального идентификатора сущности на дальнем конце соответствующей связи.</p>\r\n<p>Если результирующие внешние ключи не относятся к одному домену, то для каждой связи, покрываемой дугой исключения, создаются явные столбцы внешних ключей; все эти столбцы могут содержать неопределенные значения.</p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Что такое реляционная модель?</li>\r\n<li>Что такое домен?</li>\r\n<li>Что такое отношение?</li>\r\n<li>Чем отношение отличается от таблицы?</li>\r\n<li>Какими преимуществами и недостатками обладает реляционная модель?</li>\r\n<li>Как производтся перевод модели сущность-связь в реляционную модель?</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'История реляционной модели.\r\nТермины реляционной модели\r\nПреимущества и недостатки реляционной модели.\r\nСвойства отношений в реляционных базах данных',0),(5,'2016-09-14 06:38:34','Лекция 5.  Реляционная алгебра исчисление',5,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>Реляционная алгебра.</li>\r\n<li>Операции над множествами.</li>\r\n<li>Реляционное исчисление.</li>\r\n<li>Исчисление кортежей и исчисление доменов</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Ключевые слова: множество, реляционная алгебра, исчисление, отношение, оператор, предикат.</strong></p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><a name=\"_Toc286848067\"></a><strong>Обзор реляционной алгебры.</strong></p>\r\n<p>Третья часть реляционной модели, манипуляционная часть, утверждает, что доступ к реляционным данным осуществляется при помощи реляционной алгебры или эквивалентного ему реляционного исчисления.</p>\r\n<p>В реализациях конкретных реляционных СУБД сейчас не используется в чистом виде ни реляционная алгебра, ни реляционное исчисление. Фактическим стандартом доступа к реляционным данным стал язык SQL (Structured Query Language). Язык SQL представляет собой смесь операторов реляционной алгебры и выражений реляционного исчисления, использующий синтаксис, близкий к фразам английского языка и расширенный дополнительными возможностями, отсутствующими в реляционной алгебре и реляционном исчислении. Вообще, язык доступа к данным называется реляционно полным, если он по выразительной силе не уступает реляционной алгебре (или, что то же самое, реляционному исчислению), т.е. любой оператор реляционной алгебры может быть выражен средствами этого языка. Именно таким и является язык SQL.</p>\r\n<p><strong>Замкнутость реляционной алгебры.</strong></p>\r\n<p>Реляционная алгебра представляет собой набор операторов, использующих отношения в качестве аргументов, и возвращающие отношения в качестве результата. Таким образом, реляционный оператор&nbsp; выглядит как функция с отношениями в качестве аргументов:</p>\r\n<p>Реляционная алгебра является замкнутой, т.к. в качестве аргументов в реляционные операторы можно подставлять другие реляционные операторы, подходящие по типу:</p>\r\n<p>Таким образом, в реляционных выражениях можно использовать вложенные выражения сколь угодно сложной структуры.</p>\r\n<p>Каждое отношение обязано иметь уникальное имя в пределах базы данных. Имя отношения, полученного в результате выполнения реляционной операции, определяется в левой части равенства. Однако можно не требовать наличия имен от отношений, полученных в результате реляционных выражений, если эти отношения подставляются в качестве аргументов в другие реляционные выражения. Такие отношения будем называть&nbsp;неименованными отношениями. Неименованные отношения реально не существуют в базе данных, а только вычисляются в момент вычисления значения реляционного оператора.</p>\r\n<p><strong>Теоретико-множественные операции реляционной алгебры</strong><strong>.</strong></p>\r\n<p>Реляционная алгебра в том виде, в котором она была определена Эдгаром Коддом, состоит из восьми операторов, составляющих две группы по четыре оператора.</p>\r\n<ol>\r\n<li>Традиционные операции над множествами: объединение, пересечение, разность и<br /> декартово произведение (все они модифицированы с учетом того, что их операндами являются отношения, а не произвольные множества).</li>\r\n<li>Специальные реляционные операции: выборка, проекция, соединение и деление.</li>\r\n</ol>\r\n<p><strong>Объединение (union)</strong> &ndash; возвращает отношение, содержащее все кортежи, которые принадлежат либо одному из двух заданных отношений, либо им обоим</p>\r\n<p><strong><em>Пересечение (intersect)</em></strong> &ndash; возвращает отношение, содержащее все кортежи, которые принадлежат одновременно двум заданным отношениям</p>\r\n<p><strong><em>Разность (minus)</em></strong> &ndash; возвращает отношение, содержащее все кортежи, которые принадлежат первому из двух заданных отношений и не принадлежат второму</p>\r\n<p><strong><em>Произведение (times)</em></strong> &ndash; возвращает отношение, содержащее все возможные кортежи, которые являются сочетанием двух кортежей, принадлежащих соответственно двум заданным отношениям</p>\r\n<p><strong><em>Выборка </em></strong>&ndash; возвращает отношение, содержащее все кортежи из заданного отношения, которые удовлетворяют указанным условиям. Операцию выборки также иногда называют операцией ограничения, поэтому далее в этой книге будет также употребляться термин ограничение, если подразумевается данная алгебраическая операция</p>\r\n<p><strong><em>Проекция </em></strong>&ndash; Возвращает отношение, содержащее все кортежи (подкортежи) заданного отношения, которые остались в этом отношении после исключения из него некоторых атрибутов</p>\r\n<p><strong><em>Соединение </em></strong><em>&ndash; в</em>озвращает отношение, содержащее все возможные кортежи, которые представляют собой комбинацию атрибутов двух кортежей, принадлежащих двум заданным отношениям, при условии, что в этих двух комбинируемых кортежах присутствуют одинаковые значения в одном или нескольких общих для исходных отношений атрибутах (причем эти общие значения в результирующем кортеже появляются один раз, а не дважды)</p>\r\n<p><strong>Произведение &ndash; </strong>Возвращает отношение, содержащее все возможные кортежи, которые являются сочетанием двух кортежей, принадлежащих соответственно двум заданным отношениям</p>\r\n<p><strong>Свойства реляционных операций.</strong></p>\r\n<p>Пусть А, В и С &ndash; произвольные реляционные выражения (дающие совместимые по типу отношения).&nbsp; Тогда для операции объединения:</p>\r\n<ul>\r\n<li><strong>(A UNION В) UNION С &equiv; А UNION (В UNION С)</strong> &ndash; (свойство ассоциативности)</li>\r\n<li><strong>А UNION B &equiv; В UNION A</strong> &ndash; (свойство коммутативности).</li>\r\n</ul>\r\n<p>Аналогично свойства ассоциативности и коммутативности определяются для остальных операций.</p>\r\n<p><strong>Реляционное исчисление.</strong></p>\r\n<p>Реляционное исчисление &ndash; декларативный теоретический язык запросов, реализованный на основе исчисления предикатов первого порядка (высказываний в виде функции), которым должны удовлетворять искомые кортежи или домены отношений.</p>\r\n<p>Запрос к БД, выполненный с использованием реляционного исчисления, содержит описание желаемого результата, для которого может существовать несколько способов его вычисления, представленных выражениями реляционной алгебры или непосредственно командами СУБД. Преимуществом реляционного исчисления перед реляционной алгеброй можно считать то, что пользователю не требуется самому строить алгоритм выполнения запроса, Программа СУБД (при достаточной ее интеллектуальности) сама строит эффективный алгоритм.</p>\r\n<p>Существует два варианта исчислений: исчисление, кортежей и исчисление, доменов. В первом случае для описания отношений используются переменные, допустимыми значениями которых являются кортежи отношения, а во втором случае - элементы домена.</p>\r\n<p><strong>Реляционное исчисление основанное на кортежах (исчисление кортежей).</strong></p>\r\n<p>В исчислении кортежей, как и в процедурных языках программирования, сначала нужно описать используемые переменные, а затем записать выражения запроса к данным.</p>\r\n<p>Описательную часть исчисления можно представить в виде:</p>\r\n<p>RANGE OF &lt;переменная&gt; IS &lt;список&gt;.</p>\r\n<p>Конструкция RANGE указывает идентификатор переменной кортежа (переменная) и область ее допустимых значений - список - последовательность одного или более элементов: x1, ..., xn, каждый из которых является либо отношением, либо выражением над отношением (порядок записи выражений описывается далее). При этом в любой момент переменная принимает в качестве значения только один из кортежей списка отношений.</p>\r\n<p>Схемы отношений списка должны быть эквивалентными. Область допустимых значений переменной образуется путем объеди&lt;нения значений всех элементов списка.</p>\r\n<p>Использование переменных:</p>\r\n<p>RANGE OF Var1 IS Table1, Table2</p>\r\n<p>Область определения переменной Var1 включает в себя все значения из отношения, которое является объединением отношений Table1 и Table2.</p>\r\n<p>Выражением реляционного исчисления кортежей называется конструкция вида&nbsp;&lt;целевой_список &gt; WHERE &lt;WFF&gt;</p>\r\n<p>Значением выражения является отношение, тело (множество кортежей) которого должно удовлетворять WFF (well formulated formula - правильно построенная формула), а схема (набор атрибутов и их имена) определяется целевым списком. Целевой список по существу определяет операцию проекции, а формула WFF - селекцию кортежей.</p>\r\n<p>В паре &lt;переменная&gt;.&lt;атрибут&gt; первая составляющая служит для указания переменной кортежа (определенной конструкцией RANGE), а вторая - для определения атрибута отношения, на котором изменяется переменная кортежа. Необязательная часть &laquo;AS &lt;атрибут&gt;&raquo; используется для переименования атрибута целевого отношения. Если она отсутствует, то имя атрибута целевого отношения наследуется от соответствующего имени атрибута исходного отношения.</p>\r\n<p>Употребление в качестве элемента целевого отношения имени переменной равносильно перечислению в списке всех атрибутов соответствующего отношения.</p>\r\n<p>Правильно построенная формула (<em>Well-Formed Formula, WFF</em>) служат для выражения условий, накладываемых на кортежные переменные. Основой WFF являются простые сравнения, представляющие собой операции сравнения скалярных значений (значений атрибутов переменных или констант).</p>\r\n<p>Простые условия представляют собой операции сравнения скалярных значений. Приведем некоторые из них:</p>\r\n<p>ИмяПеременной.ИмяАтрибута = СкалярноеЗначение</p>\r\n<p>ИмяПеременнойА.ИмяАтрибутаБ = ИмяПеременнойВ.ИмяАтрибутаГ</p>\r\n<p>ИмяПеременной.ИмяАтрибута &lt;&gt; СкалярноеЗначение</p>\r\n<p>ИмяПеременнойА.ИмяАтрибутаБ &lt; ИмяПеременнойВ.ИмяАтрибутаГ</p>\r\n<p>Более сложные варианты WFF строятся с помощью логических связок NOT, AND, OR и IF ... THEN. Так, если &lt;формула&gt; - WFF, а &lt;сравнение&gt; - простое сравнение, топеречисленные ниже выражения являются WFF:</p>\r\n<p>NOT &lt;формула&gt;</p>\r\n<p>&lt;сравнение&gt; AND &lt;формула&gt;</p>\r\n<p>&lt;сравнение&gt; OR &lt;формула&gt;</p>\r\n<p>IF &lt;сравнение&gt; THEN &lt;формула&gt;.</p>\r\n<p>Допускается построение WFF с помощью кванторов. Если &lt;формула&gt; - это WFF, в которой участвует &lt;переменная&gt;, то перечисленные конструкции также являются WFF.</p>\r\n<p>EXISTS &lt;переменная&gt; (&lt;формула&gt;)</p>\r\n<p>FORALL &lt;переменная&gt; (&lt;формула&gt;.</p>\r\n<p>В первом случае WFF означает: \"Существует по крайней мере одно такое значение &lt;переменной&gt;, что вычисление &lt;формулы&gt; дает значение ИСТИНА\".</p>\r\n<p>Во втором случае WFF означает: \"Для всех значений переменной &lt;переменной&gt; вычисление &lt;формулы&gt; дает значение ИСТИНА\".</p>\r\n<p>Переменные, входящие в WFF, могут быть свободными или связанными. Все переменные, входящие в WFF, при построении которой не использовались кванторы, являются свободными. Фактически, это означает, что если для какого-то набора значений свободных кортежных переменных при вычислении WFF получено значение ИСТИНА, то эти значения кортежных переменных могут входить в результирующее отношение.</p>\r\n<p>Если же имя переменной использовано сразу после квантора при построении WFF вида&nbsp;EXISTS &lt;переменная&gt; (&lt;формула&gt;)&nbsp;или&nbsp;FORALL &lt;переменная&gt; (&lt;формула&gt;), то в этой WFF и во всех WFF, построенных с ее участием, &lt;переменная&gt; - это связанная переменная. Это означает, что такая переменная не видна за пределами минимальной WFF, связавшей эту переменную. При вычислении значения такой WFF используется не одно значение связанной переменной, а вся ее область определения.</p>\r\n<p>Рассмотрим использование кванторов. Пусть Var1 и Var2 - две кортежные переменные, определенные на отношении Table1. Тогда, WFF:</p>\r\n<p>EXISTS Var2 (Var1.Table1_field1 &gt; Var2.Table1_field1)&nbsp;для текущего кортежа переменной Var1 принимает значение true в том и только в том случае, если во всем отношении Table1 найдется кортеж (связанный с переменной Var2) такой, что значение его атрибута Table1_field1 удовлетворяет внутреннему условию сравнения.</p>\r\n<p>FORALL Var2 (Var1.Table1_field1 &gt; Var2.Table1_field1)&nbsp;для текущего кортежа переменной Var1 принимает значение true в том и только в том случае, если для всех кортежей отношения Table1 (связанных с переменной Var2) значения атрибута Table1_field1 удовлетворяют условию сравнения.</p>\r\n<p>На самом деле, правильнее говорить не о свободных и связанных переменных, а о свободных и связанных вхождениях переменных. Легко видеть, что если переменная var является связанной в WFF form, то во всех WFF, включающих данную, может использоваться имя переменной var, которая может быть свободной или связанной, но в любом случае не имеет никакого отношения к вхождению переменной var в WFF form.</p>\r\n<p>Приведем пример использования двух связанных вхождений переменных:</p>\r\n<p>EXISTS Var2 (Var1.Table1_field2 = Var2.Table1_field2) AND FORALL Var2 (Var1.Table1_field1 &gt; Var2.Table1_field1)</p>\r\n<p>Здесь мы имеем два связанных вхождения переменной Var2 с совершенно разным смыслом.</p>\r\n<p>Описанное исчисление не обладает вычислительной полнотой, так как не позволяет выполнять вычисления. Добавление вычислительных функций в исчисление можно реализовать путем расширения определения операндов сравнения и элементов целевого списка таким образом, чтобы они допускали использование скалярных выражений с литералами, ссылками на атрибуты и итоговыми функциями.</p>\r\n<p>В качестве итоговых могут выступать следующие функции: COUNT (количество), SUMM (сумма), АVG (среднее), МАХ (максимальное), MIN (минимальное).</p>\r\n<p>Реляционное исчисление кортежей является основой для языка запросов QUEL.</p>\r\n<p><strong>Реляционное исчисление доменов.</strong></p>\r\n<p>В исчислении доменов областью определения переменных являются не отношения, а домены. Применительно к базе данных Сотрудники можно говорить, например, о доменных переменных ФИО (значения - допустимые ФИО) или Номер_отдела (значения - допустимые номера отделов предприятия).</p>\r\n<p>Основным формальным отличием исчисления доменов от исчисления кортежей является наличие дополнительного набора предикатов, позволяющих выражать так называемые условия членства.</p>\r\n<p>Во всем остальном формулы и выражения исчисления доменов выглядят похожими на формулы и выражения исчисления кортежей. В частности, конечно, различаются свободные и связанные вхождения доменных переменных.</p>\r\n<p>Реляционное исчисление доменов является основой большинства языков запросов, основанных на использовании форм. В частности, на этом исчислении базировался известный язык Query-by-Example, который был первым (и наиболее интересным) языком в семействе языков, основанных на табличных формах.</p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Что такое реляционная алгебра?</li>\r\n<li>Какие виды операторов реляционной алгебры заложил Эдгар Кодд?</li>\r\n<li>Какие свойства есть у реляуионных операторов?</li>\r\n<li>Что такое реляуионное исчисление?</li>\r\n<li>Какие два вида реляциооных исчислений вы знаете?</li>\r\n<li>Что такое правильно построенная формула?</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>\r\n<p>&nbsp;</p>',1,'Реляционная алгебра.\r\nОперации над множествами.\r\nРеляционное исчисление.\r\nИсчисление кортежей и исчисление доменов',0),(6,'2016-09-14 06:39:09','Лекция 6.  Планирование и разработка баз данных',6,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>Жизненный цикл информационной системы.</li>\r\n<li>Жизненный цикл разработки базы данных.</li>\r\n<li>Проектирование базы данных.</li>\r\n<li>Реализация. CASE инструменты.</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Ключевые слова: жизненный цикл, модель, жизненный цикл базы данных</strong></p>\r\n<p>&nbsp;</p>\r\n<p><strong>Жизненный цикл информационной системы</strong></p>\r\n<p>Любая информация имеет &laquo;время жизни&raquo;. Она может существовать кратковременно (в памяти калькулятора в процессе проводимых на нем вычислений), в течение некоторого времени (при подготовке какой-либо справки) или очень долго (при хранении важных личных, коммерческих, общественных или государст-венных данных). Эти периоды времени определяют&nbsp;<em>жизненный цикл информации</em>.</p>\r\n<p>Жизненный цикл ИС является производной жизненного цикла информации, информационных продуктов и услуг и технических средств.</p>\r\n<p><em>Стадии жизненного цикла</em>&nbsp;для информационных систем в различных отраслях человеческой деятельности, по сути, одинаковы:</p>\r\n<ol>\r\n<li>постановка задачи;</li>\r\n<li>проектирование услуг;</li>\r\n<li>разработка и развертывание;</li>\r\n<li>гарантированное предоставление услуг;</li>\r\n<li>модернизация или ликвидация услуги.</li>\r\n</ol>\r\n<p><strong><em>Жизненный цикл создания и использования компьютерных программ</em></strong>&nbsp;отражает различные их состояния, начиная с момента возникновения необходимости в данном программном изделии и заканчивая моментом его полного выхода из употребления у всех пользователей.</p>\r\n<p>Традиционно выделяются следующие основные этапы жизненного цикла программного обеспечения:</p>\r\n<ol>\r\n<li>анализ требований;</li>\r\n<li>проектирование;</li>\r\n<li>кодирование (программирование);</li>\r\n<li>тестирование и отладка;</li>\r\n<li>эксплуатация и сопровождение.</li>\r\n</ol>\r\n<p>Разработчики стремятся сделать максимально возможным период жизненного цикла информационных продуктов и услуг. Для большинства современных компьютерных программ длительность жизненного цикла равна двум&ndash;трём годам, хотя встречаются программы, существующие десять и более лет. Для увеличения этого периода необходимо постоянно осуществлять маркетинговые и иные мероприятия по их поддержке.</p>\r\n<p>Определённое время после снятия программного продукта с продажи может осуществляться его сопровождение. Отказ от продолжения выпуска и сопровождения программного продукта или от предоставления информационных услуг обычно обусловлен их неэффективностью, наличием неустранимых ошибок и отсутствием спроса.</p>\r\n<p><strong><em>Жизненный цикл ИС</em></strong>&nbsp;представляет собой модель ее создания и использования. Модель отражает различные состояния информационной системы, начиная с момента возникновения необходимости в данной системе и заканчивая моментом ее полного выхода из употребления у всех пользователей.</p>\r\n<p>Под моделью жизненного цикла понимается структура, определяющая последовательность выполнения и взаимосвязи процессов, действий и задач, выполняемых на протяжении всего ЖЦ.</p>\r\n<p>Модель ЖЦ зависит от специфики информационной системы, а также специфики условий, в которых последняя создается и функционирует.</p>\r\n<p>Наибольшее распространение получили три модели жизненного цикла информационных технологий: каскадная, поэтапная и спиральная.</p>\r\n<p><strong><em>Каскадная модель</em></strong>&nbsp;или &laquo;водопад&raquo; используется в технологиях, ориентированных на переход к следующему этапу после полного окончания работ на предыдущем этапе (рис. 6.1).</p>\r\n<p>Рис. 6.1. Каскадная схема разработки ПО.</p>\r\n<p>Недостатком такой модели является то, что реальный процесс создания ИС обычно полностью не укладывается в такую жесткую схему. Практически постоянно возникает потребность возвращаться к предыдущим этапам, уточнять или пересматривать ранее принятые решения. В результате затягиваются сроки получения результатов, а пользователи могут вносить замечания лишь по завершению всех работ с системой. При этом модели автоматизируемого объекта могут устареть к моменту их утверждения.</p>\r\n<p><strong><em>Поэтапная модель</em></strong>&nbsp;обычно включает промежуточный контроль на любом этапе и межэтапные корректировки. Обеспечивает меньшую трудоемкость по сравнению с каскадной моделью, но время жизни каждого этапа становится равным всему жизненному циклу. Межэтапные корректировки позволяют уменьшить трудоемкость процесса разработки по сравнению с каскадной моделью (рис. 6.2).</p>\r\n<p>Рис. 6.2. Поэтапная схема разработки ПО.</p>\r\n<p><strong><em>Спиральная модель</em></strong>&nbsp;(рис. 6.3) характеризуется тем, что на начальных этапах ЖЦ осуществляются выработка стратегии, анализ требований и предварительное детальное проектирование. При этом создаются прототипы (макеты), позволяющие проверить и обосновать реализуемость технических решений. Каждый виток спирали соответствует поэтапной модели создания фрагмента или версии изделия. На нём уточняются цели и характеристики проекта, определяется его качество, и планируются работы следующего витка спирали. В результате выбирается обоснованный вариант, который и реализуется.</p>\r\n<p>Рис. 6.3. Спиральная модель.</p>\r\n<p><strong>Жизненный цикл базы данных.</strong></p>\r\n<p><em>Жизненный цикл базы данных </em>(ЖЦБД) &ndash; это процесс проектирования, реализации и поддержки базы данных. ЖЦБД состоит из семи этапов:</p>\r\n<ol>\r\n<li>предварительное планирование;</li>\r\n<li>проверка осуществимости;</li>\r\n<li>определение требований;</li>\r\n<li>концептуальное проектирование;</li>\r\n<li>логическое проектирование;</li>\r\n<li>физическое проектирование;</li>\r\n<li>оценка работы и поддержка базы данных.</li>\r\n</ol>\r\n<p>В развитии любого экономического объекта наступает момент осознания того, что для достижения дальнейших успехов в развитии необходимо данные, находящиеся в личном пользовании работников, интегрировать для совместного использования в базе данных и воспринимать их как корпоративный ресурс.</p>\r\n<ol>\r\n<li><em>Предварительное планирование базы данных</em> &ndash; важный этап в процессе перехода от разрозненных данных к интегрированным. На этом этапе собирается информация об используемых и находящихся в процессе разработки прикладных программах и файлах, связанных с ними. Она помогает установить связи между текущими приложениями и то, как используется их информация. Кроме того, позволяет определить будущие требования к базе данных. Информация документируется в виде обобщенной концептуальной модели данных.</li>\r\n<li><em>Проверка осуществимости </em>предполагает подготовку отчетов по трем вопросам:</li>\r\n<li>есть ли технология &ndash; необходимое оборудование и программное обеспечение &ndash; дляреализации запланированной базы данных (технологическая осуществимость);</li>\r\n<li>имеются ли персонал, средства и эксперты для успешного осуществления планасоздания базы данных (операционная осуществимость);</li>\r\n<li>окупится ли запланированная база данных (экономическая эффективность).</li>\r\n<li><em>Определение требований</em>. На этом этапе определяются:</li>\r\n</ol>\r\n<ul>\r\n<li>цели базы данных;</li>\r\n<li>информационные потребности различных структурных подразделений и их руководителей;</li>\r\n<li>требования к оборудованию;</li>\r\n<li>требования к программному обеспечению.</li>\r\n</ul>\r\n<ol start=\"4\">\r\n<li><em>Концептуальное проектирование. </em>На этом этапе создаются подробные модели пользовательских представлений данных предметной области. Затем они интегрируются в <em>концептуальную модель</em>, которая фиксирует все элементы корпоративных данных, подлежащих загрузке в базу данных. Эту модель еще называют <em>концептуальной схемой базы данных.</em></li>\r\n<li><em>Логическое проектирование. </em>На этом этапе осуществляется выбор типа модели данных. Концептуальная модель отображается в <em>логическую модель</em>, основанную уже на структурах, характерных для выбранной модели.</li>\r\n<li><em>Физическое проектирование. </em>На этом этапе логическая модель расширяется характеристиками, необходимыми для определения способов физического хранения базы данных, типа устройств для хранения, методов доступа к данным базы, требуемого объема памяти, правил сопровождения базы данных и др.</li>\r\n<li><em>Оценка и поддержка базы данных. </em>Оценка включает опрос пользователей на предмет выяснения, какие их информационные потребности остались неучтенными. При необходимости в спроектированную базу данных вносятся изменения. Пользователи обучаются работе с базой данных. По мере расширения и изменения потребностей бизнеса поддержка базы данных обеспечивается путем внесения изменений, добавления новых данных, разработки новых прикладных программ, работающих с базой данных.</li>\r\n</ol>\r\n<p><strong>Проектирование базы данных.</strong></p>\r\n<p>Построение концептуальной модели самый сложный и трудно формализуемый процесс.&nbsp; Отсутствуют конструктивные методики, процесс структуризации по существу является искусством, опирающимся на опыт проектировщика и участие профессионала &ndash; работника моделируемой предметной области.</p>\r\n<p><strong><em>Концептуальное проектирование баз данных</em></strong> &ndash; это процесс создания модели, используемой информации, не зависящей от любых физических аспектов её представления &ndash; создание концептуального представления базы данных, включающее определение типов важнейших сущностей и существующих между ними связей и атрибутов.&nbsp; Далее этап логического проектирования.</p>\r\n<p>Можно выделить два подхода к моделированию данных (проектированию концептуальной модели данных):</p>\r\n<ul>\r\n<li>в результате системного анализа предметной области (называют также семантическим моделированием) &ndash; наиболее распространенный, по крайней мере, в известных работах.</li>\r\n<li>в результате анализа информационных потребностей пользователей (проектирование БД на основе нормализации имеющихся).</li>\r\n</ul>\r\n<p>Первый подход наиболее распространен (по крайней мере в известных работах), базируется на подходе, определенном Ченом примерно в 1976г. (Chen Peter). The Entity-Relationship Model 1976 ER-модель.</p>\r\n<p><strong>Реализация. </strong><strong>CASE &ndash; инструменты.</strong></p>\r\n<p>CASE-средства &ndash; это автоматизированные средства, основанные на CASE-технологиях, позволяющие автоматизировать отдельные этапы жизненного цикла программного обеспечения. Все современные CASE-средства могут быть классифицированы по типам и категориям. Классификация по типам отражает функциональную ориентацию на процессы жизненного цикла программного обеспечения. Классификация по категориям определяет степень интеграции по выполняемым функциям и включает отдельные локальные средства, решающие наиболее автономные задачи (по-английски tools), набор частично интегрированных средств, охватывающих большинство этапов жизненного цикла (toolkit) и полностью интегрированные средства, поддерживающие весь жизненный цикл информационных систем.</p>\r\n<p>Классификация по типам включает следующие основные CASE-средства:</p>\r\n<ol>\r\n<li>Средства анализа, предназначенные для построения и анализа моделей предметной области (Bpwin, Design/IDEF);</li>\r\n<li>Средства анализа и проектирования, предназначенные для создания проектных спецификаций (CASE.Аналитик, Vantage Team Builder, Designer/2000, Silverrun, PRO-IV);</li>\r\n<li>Средства проектирования баз данных, обеспечивающие моделирование данных и генерацию схем баз данных для наиболее распространенных СУБД (Silverrun, Vantage Team Builder, Designer/2000, ERwin, S-Designor);</li>\r\n<li>Средства разработки приложений и генераторы кодов (Vantage Team Builder, Silverrun, PRO-IV);</li>\r\n<li>Средства реинжениринга, обеспечивающие анализ программных кодов, схем баз данных и формирование на их основе различных моделей и проектных спецификаций. Средства анализа схем баз данных входят в состав: (Silverrun, Vantage Team Builder, Designer/2000, Erwin, S-Designor). Для анализа программных кодов используются такие средства, как Rational Rose и Object Team.</li>\r\n</ol>\r\n<p>CASE-средство Silverrun американской фирмы Computer Systems Advisers (CSA) используется для анализа и проектирования информационных систем бизнес-класса и ориентировано, в большей степени, на спиральную модель жизненного цикла. Оно применимо для поддержки любой методологии, основанной на раздельном построении функциональной и информационной моделей (диаграмм потоков данных и диаграмм &laquo;сущность-связь&raquo;). Silverrun имеет модульную структуру и состоит из четырех модулей, каждый из которых является самостоятельным продуктом. Модуль построения моделей бизнес-процессов в форме диаграмм потоков данных (BMP &ndash; Business Process Modeler) позволяет моделировать функционирование обследуемой организации или создаваемой информационной системы. Модуль концептуального моделирования данных (ERX &ndash; Entity-Relationship eXpert) обеспечивает построение моделей данных &laquo;сущность-связь&raquo;, не привязанных к конкретной реализации. Модуль реляционного моделирования (RDM &ndash; Relational Data Modeler) позволяет создавать детализированные модели &laquo;сущность-связь&raquo;, предназначенные для реализации в реляционной базе данных. Менеджер репозитория рабочей группы (WRM &ndash; Workgroup Repository Manager) применяется как словарь данных для хранения общей для всех моделей информации, а также обеспечивает интеграцию модулей Silverrun в единую среду проектирования. Платой за высокую гибкость и разнообразие изобразительных средств построения моделей является такой недостаток Silverrun, как отсутствие жесткого взаимного контроля между компонентами различных моделей (например, возможности автоматического распространения изменений между диаграммами потоков данных разного уровня). Но этот недостаток может иметь существенное значение только в случае использования каскадной модели жизненного цикла программного обеспечения. Для автоматической генерации схем баз данных у Silverrun существуют мосты к наиболее распространенным СУБД: Oracle, Informix, DB2, Ingres, Progress, SQL Server, SQLBase, Sybase. Для передачи данных в средства разработки приложений имеются мосты к языкам 4GL: JAM, PowerBuilder, SQL Windows, Uniface, NewEra, Delphi. Система Silverrun реализована на трех платформах &ndash; MS Windows, Macintosh, OS/2 Presentation Manager &ndash; с возможностью обмена проектными данными между ними.</p>\r\n<p>Vantage Team Builder представляет собой интегрированный программный продукт, ориентированный на реализацию каскадной модели жизненного цикла программного обеспечения. Vantage Team Builder обеспечивает выполнение следующих функций: 1) проектирование диаграмм потоков данных, &laquo;сущность-связь&raquo;, структур данных, структурных схем программ и последовательностей экранных форм; 2) генерацию кода программ на языке 4GL целевой СУБД с полным обеспечением программной среды и генерация SQL-кода для создания таблиц баз данных, индексов, ограничений целостности и хранимых процедур; 3) программирование на языке C со встроенным SQL; 4) управление версиями и конфигурацией проекта; 5) генерация проектной документации по стандартным и индивидуальным шаблонам; 6) экспорт и импорт данных проекта. Vantage Team Builder поставляется в различных конфигурациях в зависимости от используемых СУБД (Oracle, Informix, Sybase, Ingress) или средств разработки приложений (Uniface). Конфигурация Vantage Team Builder обеспечивает совместное использование двух систем в рамках единой технологической среды проектирования, при этом схемы баз данных (SQL - модели) переносятся в репозиторий Uniface, и, наоборот, прикладные модели, сформированные средствами Uniface, могут быть перенесены в репозиторий Vantage Team Builder. Возможности рассогласования между репозиториями двух систем устаняются с помощью специальной утилиты. Разработка экранных форм в среде Uniface выполняется на базе диаграмм последовательностей форм (FSD) после импорта SQL &ndash; модели. Vantage Team Builder функционирует на всех основных Unix &ndash; платформах (Solaris, SCO UNIX, AIX, HP-UX) и VMS.</p>\r\n<p>CASE-средство Designer/2000 фирмы Oracle является интегрированным CASE-средством, обеспечивающим в совокупности со средствами разработки приложений Developer/2000, поддержку полного жизненного цикла программного обеспечения для систем, использующих СУБД Oracle. В состав Designer/2000 входят следующие компоненты: 1) Repository Administrator &ndash; средства управления репозиторием (создание, удаление приложений, управление доступа к данным со стороны различных пользователей, экспорт и импорт данных); 2) Repository Object Navigator - средство доступа к репозиторию. Обеспечивающие многооконный объектно-ориентированный интерфейс доступа ко всем элементам репозитория; 3) Process Modeller &ndash; средство анализа и моделирования деловой деятельности, основывающиеся на концепциях реинжениринга бизнес-процессов и глобальной системы управления качеством; 4) Systems Modeller &ndash; набор средств построения функциональных и информационных моделей проектируемой информационной системы, включающий средства для построения диаграмм &laquo;сущность-связь&raquo;, диаграмм функциональных иерархий, диаграмм потоков данных и средство анализа и модификации связей объектов репозитория различных типов; 5) Systems Designer &ndash; набор средств проектирования информационных систем, включающий средство построения структуры реляционной базы данных, а также средства построения диаграмм, отображающих взаимодействие с данными, иерархию, структуру и логику приложений, реализуемую хранимыми процедурами на языке SQL; 6) Server Generator &ndash; генератор описаний объектов базы данных Oracle (таблиц, индексов, ключей, последовательностей и т.д.). Помимо продуктов Oracle, генерация и реинжиниринг баз данных может выполняться для СУБД Informix, DB/2,Microsoft SQL Server, Sybase, a а также для баз данных, доступ к которым реализуется посредством ODBC; 7) Forms Generator &ndash; генератор приложения, включающий в себя различные экранные формы, средства контроля данных, проверки ограничений целостности и автоматические подсказки; 8) Repository Reports &ndash; генератор стандартных отчетов. Среда функционирования Designer/2000 &ndash; Windows 3.x, Windows 95, Windows NT.</p>\r\n<p>Erwin &ndash; средство логического моделирования баз данных, использующее методологию IDEF1X. Erwin реализует проектирование схемы баз данных, генерацию её описания на языке целевой СУБД (Oracle, Informix, DB/2, Ingres, Progress, SQL Server, SQLBase, Sybase и др.) и реинжениринг существующей базы данных. Erwin выпускается в нескольких различных конфигурациях, ориентированных на наиболее распространенные средства разработки приложений 4GL. Версия Erwin/Open полностью совместима со средствами разработки приложений PowerBuilder и SQLWindows и позволяет экспортировать описание спроектированной базы данных непосредственно в репозитории данных средств.</p>\r\n<p>S &ndash;Designor представляет собой CASE &ndash; средство для проектирования реляционных баз данных. S &ndash;Designor реализует стандартную методологию моделирования данных и генерирует описание баз данных для таких СУБД, как Oracle, Informix, DB/2, Ingres, Progress, SQL Server, SQLBase, Sybase и др. Для существующих систем выполняется реинжениринг баз данных.</p>\r\n<p>&nbsp;</p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<p><strong>&nbsp;</strong></p>\r\n<ol>\r\n<li>Что такое жизеннный цикл информационной системы?</li>\r\n<li>Какие основные модели разработки жазненного цикла ИС существуют?</li>\r\n<li>В чем отличие жизненного цикла информационной системы от жизненного цикла базы данных?</li>\r\n<li>Что такое концептуальное проектирование?</li>\r\n<li>Какие категории CASE инфтрументов вы знаете?</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'Жизненный цикл информационной системы.\r\nЖизненный цикл разработки базы данных.\r\nПроектирование базы данных.\r\nРеализация. CASE инструменты.',0),(7,'2016-09-14 06:39:51','Лекция 7.  Нормализация.',7,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>Проблемы при построении БД.</li>\r\n<li>Нормальные формы.</li>\r\n<li>Нормализация и функциональные зависимости</li>\r\n<li>Первая нормальная форма</li>\r\n<li>Вторая нормальная форма</li>\r\n<li>Третья нормальная форма.</li>\r\n<li>Нормальная форма Бойса-Кодда.</li>\r\n<li>Четвертая нормальная форма.</li>\r\n<li>Пятая нормальная форма.</li>\r\n<li>Доменно-ключевая нормальная форма.</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Ключевые слова: аномалия, нормализация, функциональная зависимость, ключ.</strong></p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Проблемы при построении БД.</strong></p>\r\n<p>Прежде чем мы приступим к обсуждению методов проектирования хо&shy;роших схем баз данных, давайте посмотрим, почему некоторые схемы могут оказаться неадекватными. В частности, обратимся к схеме отношения ПОСТАВЩИКИ (НАЗВ_ПОСТ, АДРЕС_ПОСТ, ТОВАР, ЦЕНА)</p>\r\n<p>Рис. 7.1 Схема отношения ПОСТАВЩИКИ</p>\r\n<p>В связи с этой схемой возникает несколько проблем:</p>\r\n<ol>\r\n<li><em>Избыточность</em>. Адрес поставщика повторяется для каждого постав&shy;ляемого товара.</li>\r\n<li><em>Потенциальная противоречивость (аномалии обновления).</em> Вследствие избыточности мы можем обновлять адрес поставщика в одном кортеже, ос&shy;тавляя его неизменным в другом. Таким образом, может оказаться, что для некоторых поставщиков нет единого адреса. Однако интуитивно мы чувст&shy;вуем, что он должен быть.</li>\r\n<li><em>Аномалии включения.</em> В базу данных не может быть записан адрес по&shy;ставщика, если он в настоящее время не поставляет по меньшей мере один товар. Можно, конечно, поместить неопределенные значения в компоненты ТОВАР и ЦЕНА кортежа для этого поставщика. Но если он начнет постав&shy;лять некоторый товар, не забудем ли мы удалить кортеж с неопределенными значениями? Хуже того, ТОВАР и НАЗВ_ПОСТ образуют ключ данного отношения, и поиск кортежей с неопределенными значениями в ключе мо&shy;жет быть затруднительным или невозможным.</li>\r\n<li><em>Аномалии удаления.</em> Обратная проблема возникает при необходимо&shy;сти удаления всех товаров, поставляемых данным поставщиком, вследствие чего мы непреднамеренно утрачиваем его адрес.</li>\r\n</ol>\r\n<p>Возникает вопрос: &laquo;Как найти хоро&shy;шую замену для плохой схемы отношений?&raquo;</p>\r\n<p><a name=\"_Toc286848742\"></a><strong>Нормальные формы.</strong></p>\r\n<p>Отношения можно классифицировать по типам аномалий модификации, которым они подвержены. В 1970-х годах теоретики реляционных баз данных постепенно сокращали количество этих типов. Кто-то находил аномалию, классифицировал ее и думал, как предотвратить ее возникновение. Каждый раз, когда это происходило, критерии построения отношений совершенствовались. Эти классы отношений и способы предотвращения аномалий называются нормальными формами (normal forms). В зависимости от своей структуры, отношение может быть в первой, во второй или в какой-либо другой нормальной форме.</p>\r\n<p>В своей работе, последовавшей за эпохальной статьей 1970 г., Кодд и другие определили первую, вторую и третью нормальные формы (1НФ, 2НФ и ЗНФ). Позднее была введена нормальная форма Бойса-Кодда (НФБК), а затем были определены четвертая и пятая нормальные формы. Как показывает рис. 7,2, эти нормальные формы являются вложенными. То есть отношение во второй нормальной форме является также отношением в первой нормальной форме, а отношение в 5НФ (пятая нормальная форма) находится одновременно в 4НФ, НФБК, ЗНФ, 2НФ и 1НФ.</p>\r\n<p>Рис 7.2 Нормальные формы</p>\r\n<p>Эти нормальные формы помогали, но у них было и серьезное ограничение. Не было теории, гарантирующей, что какая-либо из этих форм устранит все аномалии: каждая форма могла устранить только определенные их виды. Эта ситуация разрешилась в 1981 г., когда Р. Фагин (R. Fagin) ввел новую нормальную форму, которую он назвал домеино-ключевой нормальной формой, или ДКНФ (domain/key normal form, DK/NF). В своей важной статье Фагин показал, что отношение в ДКНФ свободно от всех аномалий модификации, независимо от их типа1. Он также показал, что любое отношение, свободное от аномалий модификации, должно находиться в ДКНФ.</p>\r\n<p>До введения ДКНФ теоретикам реляционных баз данных приходилось продолжать поиск все новых и новых аномалий и нормальных форм. Доказательство Фагина упростило ситуацию. Если мы можем привести отношение к ДКНФ, можем быть уверены, что в нем не будет аномалий модификации. Вся загвоздка в том, как привести отношение к ДКНФ.</p>\r\n<p>Основные свойства нормальных форм:</p>\r\n<ul>\r\n<li>каждая следующая нормальная форма в некотором смысле лучше предыдущей;</li>\r\n<li>при переходе к следующей нормальной форме свойства предыдущих нормальных свойств сохраняются.</li>\r\n</ul>\r\n<p>В основе процесса проектирования лежит метод нормализации, декомпозиция отношения, находящегося в предыдущей нормальной форме, в два или более отношения, удовлетворяющих требованиям следующей нормальной формы.</p>\r\n<p><a name=\"_Toc286848743\"></a><strong>Нормализация и функциональные зависимости</strong><strong>.</strong></p>\r\n<p><strong><em>Нормализация</em></strong> &mdash; это процесс преобразования отношения, имеющего некоторые недостатки, в отношение, которое этих недостатков не имеет. Что еще более важно, нормализацию можно использовать как критерий для определения желательности и правильности отношений. Вопрос о том, что такое хорошо структурированное отношение, был предметом многочисленных теоретических исследований. Термин нормализация обязан своим появлением одному из пионеров технологии баз данных, Э. Ф. Кодду (Е. F. Codd), который определил различные нормальные формы (normal forms) отношений.</p>\r\n<p>Наиболее важные на практике нормальные формы отношений основываются на фундаментальном в теории реляционных баз данных понятии <em>функциональной зависимости</em>. Для дальнейшего изложения нам потребуются несколько определений.</p>\r\n<p><strong><em>Функциональная зависимость (functional dependency)</em></strong> &mdash; это связь между атрибутами. Предположим, что если мы знаем значение одного атрибута, то можем вычислить (или найти) значение другого атрибута. Например, если нам известен номер счета клиента, то мы можем определить состояние его счета. В таком случае мы можем сказать, что атрибут СостояниеСчетаКлиента функционально зависит от атрибута НомерСчетаКлиента.</p>\r\n<p>Говоря более общим языком, атрибут Y функционально зависит от атрибута X, если значение X определяет значение Y. Другими словами, если нам известно значение X, мы можем определить значение Y.</p>\r\n<p>Уравнения выражают функциональные зависимости. Например, если мы знаем цену и количество приобретенного товара, мы можем определить стоимость покупки по следующей формуле:</p>\r\n<p><strong>Стоимость = Цена х Количество </strong></p>\r\n<p>В этом случае мы могли бы сказать, что атрибут Стоимость функционально зависит от атрибутов Цена и Количество.</p>\r\n<p>Функциональные зависимости между атрибутами в отношении обычно не выражаются уравнениями. Пусть, например, каждому студенту присвоен уникальный идентификационный номер, и у каждого студента есть одна и только одна специальность. Имея номер студента, мы можем узнать его специальность, поэтому атрибут Специальность функционально зависит от атрибута НомерСтудента. Или рассмотрим компьютеры в вычислительной лаборатории. Каждый компьютер имеет конкретный размер основной памяти, поэтому атрибут ОбъемПамяти функционально зависит от атрибута СерийныйНомерКомпьютера.</p>\r\n<p>В отличие от случая с уравнением, такие функциональные зависимости нельзя разрешить при помощи арифметики; вместо этого они хранятся в базе данных. Фактически, можно утверждать, что базу данных стоит иметь только ради хранения и выдачи функциональных зависимостей.</p>\r\n<p>Функциональные зависимости обозначаются следующим образом:</p>\r\n<p><strong>НомерСтудента &gt; Специальность </strong></p>\r\n<p><strong>СерийныйНомерКомпьютера &gt; ОбъемПамяти</strong></p>\r\n<p>Первое выражение читается так: &laquo;атрибут НомерСтудента функционально определяет атрибут Специальность&raquo;, &laquo;атрибут НомерСтудента определяет атрибут Специальность&raquo; или &laquo;атрибут Специальность зависит от атрибута НомерСтудента&raquo;. Атрибуты по правую сторону от стрелки называются <strong><em>детерминантами (determinants)</em></strong>.</p>\r\n<p>В функциональные зависимости могут быть вовлечены группы атрибутов. Рассмотрим отношение ОЦЕНКИ (НомерСтудента,Дисциплина, Оценка). Комбинация номера студента и дисциплины определяет оценку. Такая функциональная зависимость записывается следующим образом:</p>\r\n<p><strong>(НомерСтудента, Дисциплина) &gt; Оценка </strong></p>\r\n<p>Заметьте, что для определения оценки требуется как номер студента, так и дисциплина. Мы не можем разделить эту функциональную зависимость, поскольку ни номер студента, ни дисциплина не определяют оценку сами по себе.</p>\r\n<p><strong>Ключ (key) </strong>&mdash; это группа из одного или более атрибутов, которая уникальным образом идентифицирует строку. Каждое отношение имеет минимум один ключ. Это утверждение должно быть верным, поскольку ни одно отношение не может иметь одинаковых строк, и, следовательно, в крайнем случае, ключ будет состоять из всех атрибутов отношения.</p>\r\n<p><a name=\"_Toc286848744\"></a><a name=\"_Toc286848599\"></a><strong>Первая нормальная форма</strong><strong>.</strong></p>\r\n<p>О любой таблице данных, удовлетворяющей определению отношения, говорят, что она находится в первой нормальной форме (first normal form, 1NF). Вспомните, что для того, чтобы таблица была отношением, должно выполняться следующее: ячейки таблицы должны содержать одиночные значения и в качестве значений не допускаются ни повторяющиеся группы, ни массивы. Все записи в одном столбце (атрибуте) должны иметь один и тот же тип. Каждый столбец должен иметь уникальное имя, но порядок следования столбцов в таблице несуществен. Наконец, в таблице не может быть двух одинаковых строк, и порядок следования строк несуществен.</p>\r\n<p><a name=\"_Toc286848745\"></a><a name=\"_Toc286848600\"></a><strong>Вторая нормальная форма</strong><strong>.</strong></p>\r\n<p>Отношение находится во второй нормальной форме, если все его неключевые атрибуты зависят от всего ключа. В соответствии с этим определением, если отношение имеет в качестве ключа одиночный атрибут, то оно автоматически находится во второй нормальной форме.</p>\r\n<p>Поскольку ключ является одиночным атрибутом, то по умолчанию каждый неключевой атрибут зависит от всего ключа, и частичных зависимостей быть не может. Таким образом, вторая нормальная форма представляет интерес только для тех отношений, которые имеют композитные ключи.</p>\r\n<p><a name=\"_Toc286848746\"></a><a name=\"_Toc286848601\"></a><strong>Третья нормальная форма.</strong></p>\r\n<p>Отношения во второй нормальной форме также могут иметь аномалии. Рассмотрим отношение ПРОЖИВАНИЕ на рис. 7.3. Ключом здесь является НомерСтудента, и имеются функциональные зависимости НомерСтудента &gt; Общежитие и Общежитие &gt; Плата. Эти зависимости возникают потому, что каждый студент живет только в одном общежитии, и каждое общежитие взимает со всех проживающих в нем студентов одинаковую плату. Например, каждый живущий в общежитии Рэндольф-Холл платит $3200 за квартал.</p>\r\n<p>Рис. 7.3 Схема Общежитие</p>\r\n<p>Поскольку НомерСтудента определяет атрибут Общежитие, а Общежитие определяет атрибут Плата, то косвенным образом НомерСтудента &gt; Плата. Такая структура функциональных зависимостей называется транзитивной зависимостью (transitive dependence), поскольку атрибут НомерСтудента определяет атрибут Плата через атрибут Общежитие.</p>\r\n<p>Ключом отношения ПРОЖИВАНИЕ является НомерСтудента, который является одиночным атрибутом, и, следовательно, отношение находится во второй нормальной форме (и Общежитие, и Плата определяются атрибутом НомерСтудента). Несмотря на это, отношение ПРОЖИВАНИЕ имеет аномалии, обусловленные транзитивной зависимостью.</p>\r\n<p>Что произойдет, если мы удалим вторую строку отношения на рис. 2? Мы потеряем не только тот факт, что студент № 150 живет в Ингерсолл-Холле, но и тот факт, что проживание в этом общежитии стоит $3100. Это аномалия удаления. А как мы можем записать тот факт, что плата за проживание в Кэрригг-Холле составляет $3500? Никак, пока туда не решит вселиться хотя бы один студент. Это аномалия вставки.</p>\r\n<p>Рис 7.4 Нормализованная схема Общежитие</p>\r\n<p>Чтобы удалить аномалии из отношения во второй нормальной форме, необходимо устранить транзитивную зависимость рис. 7.4. Отношение находится в третьей нормальной форме, если оно находится во второй нормальной форме и не имеет транзитивных зависимостей.</p>\r\n<p><a name=\"_Toc286848747\"></a><a name=\"_Toc286848602\"></a><strong>Нормальная форма Бойса-Кодда.</strong></p>\r\n<p>Рисунок 7.5 Схема отношения Преподаватель</p>\r\n<p>Поскольку студенты могут специализироваться в нескольких областях, атрибут НомерСтудента не определяет атрибут Специальность. Более того, так как студент может иметь несколько консультантов, НомерСтудента не определяет и атрибут Преподаватель. Таким образом, НомерСтудента сам по себе не может быть ключом.</p>\r\n<p>Комбинация (НомерСтудента, Специальность) определяет атрибут Преподаватель, а комбинация (НомерСтудента, Преподаватель) определяет атрибут Специальность. Следовательно, любая из этих комбинаций может быть ключом. Два или более атрибута или группы атрибутов, которые могут быть ключом, называются ключами-кандидатами (candidate keys). Тот из ключей-кандидатов, который выбирается в качестве ключа, называется первичным ключом (primary key).</p>\r\n<p>Кроме ключей-кандидатов, есть еще одна функциональная зависимость, которую следует рассмотреть: атрибут Преподаватель определяет атрибут Специальность (любой из преподавателей является консультантом только по одному предмету; следовательно, зная имя преподавателя, мы можем определить специальность). Таким образом, Преподаватель является детерминантом.</p>\r\n<p>По определению, отношение КОНСУЛЬТАНТ находится в первой нормальной форме. Оно также находится во второй нормальной форме, поскольку не имеет неключевых атрибутов (каждый из атрибутов является частью минимум одного ключа). Наконец, это отношение находится в третьей нормальной форме, так как не имеет транзитивных зависимостей. Тем не менее, несмотря на все это, отношение имеет аномалии модификации.</p>\r\n<p>Пусть студент с номером 300 отчисляется из университета. Если мы удалим строку с информацией о студенте с номером 300, мы потеряем тот факт, что Перле является консультантом по психологии. Это аномалия удаления. Далее, как мы можем записать в базу тот факт, что Кейнс является консультантом по экономике? Никак, пока не появится хотя бы один студент, специализирующийся на экономике. Это аномалия удаления.</p>\r\n<p>Ситуации, подобные только что описанной, приводят нас к определению нормальной формы Бойса-Кодда (Boyce-Codd normal form, BK/NF): отношение находится в НФБК, если каждый детерминант является ключом-кандидатом. Отношение КОНСУЛЬТАНТ не находится в НФБК, поскольку детерминант Преподаватель не является ключом-кандидатом.</p>\r\n<p>Рис. 7.6 Нормализованная схема Преподаватель</p>\r\n<p>Как и в других примерах, отношение КОНСУЛЬТАНТ можно разбить на два отношения, не имеющие аномалий. Например, отношения СТУДЕНТ-КОНСУЛЬТАНТ (НомерСтудента, Преподаватель) и КОНСУЛЬТАНТ-ПРЕДМЕТ (Преподаватель, Специальность) не имеют аномалий рис. 7.6.</p>\r\n<p><a name=\"_Toc286848748\"></a><a name=\"_Toc286848603\"></a><strong>Четвертая нормальная форма.</strong></p>\r\n<p>Рис. 7.7 Схема отношения Специальность</p>\r\n<p>Рассмотрим отношение СТУДЕНТ на рис. 7.7, которое отображает связи между студентами, специальностями и секциями. Предположим, что студенты могут иметь несколько специальностей и заниматься в нескольких различных секциях. В таком случае единственным ключом является комбинация (НомерСтудента, Специальность, Секция). Например, студентка с номером 100 специализируется на музыке и бухгалтерском учете и, кроме того, посещает секции плавания и тенниса, а студент с номером 150 специализируется только на математике и занимается бегом.</p>\r\n<p>Какова связь между атрибутами НомерСтудента и Специальность? Это не функциональная зависимость, поскольку у студента может быть несколько специальностей. Одному и тому же значению атрибута НомерСтудента может соответствовать много значений атрибута Специальность. Помимо того, одному и тому же значению атрибута НомерСтудента может соответствовать много значений атрибута Секция.</p>\r\n<p>Такая зависимость атрибутов называется многозначной зависимостью (multivalue dependency). Многозначные зависимости приводят к аномалиям модификации. Для начала обратите внимание на избыточность данных на рис. 6. Студентке с номером 100 посвящено четыре записи, в каждой из которых указана одна из ее специализаций и одна из посещаемых ею секций. Если бы те же данные хранились в меньшем количестве строк (скажем, было бы две строки &mdash; одна для музыки и плавания, а другая для бухгалтерского учета и тенниса), это дезориентировало бы пользователей. Получалось бы, что студентка с номером 100 плавает только тогда, когда специализируется на музыке, а в теннис играет только тогда, когда специализируется на бухгалтерском учете. Но такая интерпретация нелогична. Специальности и секции совеершенно независимы друг от друга. Поэтому, чтобы избежать таких неверных заключений, мы храним все сочетания специальностей и секций.</p>\r\n<p>Рис. 7.8 Нормализованная схема отношения Специальность</p>\r\n<p>Допустим, что студентка с номером 100 решила записаться в секцию лыж, и поэтому мы добавляем в таблицу строку [100, Музыка, Лыжи], как показано на рис. 7.8 а данный момент из отношения можно сделать вывод, что студентка 100 занимается лыжами только как музыкант, но не как бухгалтер. Чтобы данные имели согласованный характер, мы должны добавить столько строк, сколько имеется специальностей, и в каждой из них указать секцию лыж. Таким образом, мы должны добавить строку [100, Бухгалтерский учет, Лыжи], как показано на рис. 7.8 б. Это аномалия обновления: требуется слишком много модификаций, чтобы внести одно простое изменение.</p>\r\n<p>Вообще говоря, многозначная зависимость существует, когда отношение имеет минимум три атрибута, причем два из них являются многозначными, а их значения зависят только от третьего атрибута. Другими словами, в отношении R (А, В, С) существует многозначная зависимость, если А многозначным образом определяет В и С, а сами В и С не зависят друг от друга. Как мы видели из предыдущего примера, НомерСтудента многозначно определяет атрибуты Специальность и Секция, но сами Специальность и Секция не зависят друг от друга.</p>\r\n<p>Чтобы устранить эти аномалии, мы должны избавиться от многозначной зависимости. Мы сделаем это, создав два отношения, в каждом из которых будут храниться данные только по одному многозначному атрибуту. Результирующие отношения не будут иметь аномалий. Это отношения СТУДЕНТ-СПЕЦИАЛЬНОСТЬ (НомерСтудента, Специальность) и СТУДЕНТ-СЕКЦИЯ (НомерСтудента, Секция), приведенные на рис 7.9.</p>\r\n<p>Рис 7.9 Устранение многозначной зависимости</p>\r\n<p>Отношение находится в четвертой нормальной форме, если оно находится в НФБК и не имеет многозначных зависимостей.</p>\r\n<p><a name=\"_Toc286848749\"></a><a name=\"_Toc286848604\"></a><strong>Пятая нормальная форма.</strong></p>\r\n<p>Пятая нормальная форма (fifth normal form, 5NF) связана с зависимостями, которые имеют несколько неопределенный характер. Речь здесь идет об отношениях, которые можно разделить на несколько более мелких отношений, как мы это делали выше, но затем невозможно восстановить.</p>\r\n<p>Условия, при которых возникает эта ситуация, не имеют ясной, интуитивной интерпретации. Нам неизвестно, каковы следствия таких зависимостей; мы не знаем даже, есть ли у них какие-либо практические следствия.</p>\r\n<p><a name=\"_Toc286848750\"></a><a name=\"_Toc286848605\"></a><strong>Доменно-ключевая нормальная форма.</strong></p>\r\n<p>В 1981 г. Фагин опубликовал важную статью, в которой он определил доменно-ключевую нормальную форму (domain/key normal form, DKNFI. Он показал, что отношение в ДКНФ не имеет аномалий модификации и, более того, любое отношение, не имеющее аномалий модификации, должно находиться в ДКНФ.</p>\r\n<p>Это открытие положило конец введению нормальных форм, и теперь в нормальных формах более высокого порядка нет необходимости &mdash; по крайней мере, для устранения аномалий модификации.</p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Что такое аномалия?</li>\r\n<li>Какие виды аномалий могут встречаться в базах данных?</li>\r\n<li>Какие виды енормальных форм существуют?</li>\r\n<li>Какими своствами обладают все нормальные формы?</li>\r\n<li>Что такое нормализация?</li>\r\n<li>Что такое многозначные зависимости?</li>\r\n<li>Что такое доменно-ключевая нормальная форма?</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'Проблемы при построении БД.\r\nНормальные формы.\r\nНормализация и функциональные зависимости\r\nПервая нормальная форма	\r\nВторая нормальная форма	\r\nТретья нормальная форма.\r\nНормальная форма Бойса-Кодда.\r\nЧетвертая нормальная форма.\r\nПятая нормальная форма.\r\nДоменно-ключевая нормальная форма.',0),(8,'2016-09-14 06:40:18','Лекция 8.  Введение в SQL',8,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>История SQL</li>\r\n<li>Язык SQL</li>\r\n<li>Язык определения данных</li>\r\n<li>Язык манипулирования данными.</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Ключевые слова: </strong><strong>SQL, СУБД, идентификаторы, операторы.</strong></p>\r\n<p>&nbsp;</p>\r\n<p><strong>История </strong><strong>SQL</strong></p>\r\n<p>Все языки манипулирования данными (ЯМД), созданные до появления реляционных баз данных и разработанные для многих систем управления базами данных (СУБД) персональных компьютеров, были ориентированы на операции с данными, представленными в виде логических записей файлов. Это требовало от пользователей детального знания организации хранения данных и достаточных усилий для указания не только того, какие данные нужны, но и того, где они размещены и как шаг за шагом получить их.</p>\r\n<p>Разработка, в основном, шла в отделениях фирмы IBM (языки ISBL, SQL, QBE) и университетах США (PIQUE, QUEL). Последний создавался для СУБД INGRES (Interactive Graphics and Retrieval System), которая была разработана в начале 70-х годов в Университете шт. Калифорния и сегодня входит в пятерку лучших профессиональных СУБД. Сегодня из всех этих языков полностью сохранились и развиваются QBE (Query-By-Example - запрос по образцу) и SQL, а из остальных взяты в расширение внутренних языков СУБД только наиболее интересные конструкции.</p>\r\n<p>В начале 70-х годов плодотворный труд исследователя из IBM доктора Кодда (Е. F. Codd) привел к созданию продукта, связанного с реляционной моделью данных под названием SEQUEL (Structured English Query Language, структурированный английский язык для за&shy;просов), который в 1980 г. был переименован в SQL (Structured Query Language, струк&shy;турированный язык запросов).</p>\r\n<p>С тех пор, помимо IBM, многие производители присоединились к разработке программных продуктов для SQL. Компании IBM, а также другим производителям реляционных баз данных был нужен стандартизованный метод доступа к реляционной базе и манипулирования хранящимися в ней данными. Хотя компания IBM первая разработала теорию реляцион&shy;ных баз данных, первой на рынок с этой технологией вышла компания Oracle. Через какое-то время SQL завоевал на рынке достаточную популярность и привлек внимание Американского национального института по стандартизации (American National Standards Institute, ANSI), который в 1986, 1989, 1992, 1999 и 2003 годах выпустил стандарты языка SQL. Последняя версия стандарта, SQL3, содержит расширения языка для объектно-ориентированного программирования.</p>\r\n<p>Начиная с 1986 года несколько конкурирующих между собой языков позво&shy;ляли программистам и разработчикам обращаться к реляционным данным и манипу&shy;лировать ими. Однако очень немногие из них были настолько же просты в изучении и повсеместно приняты, как SQL. Программистам и администраторам теперь можно изучить один язык, который с небольшими изменениями можно применять к разно&shy;образным платформам баз данных, приложениям и прочим продуктам.</p>\r\n<p><strong><em>SQL, или язык структурированных запросов,</em></strong> &mdash; на сегодняшний день наиболее важный из языков манипулирования реляционными данными. Он рекомендован Американским национальным институтом стандартов (ANSI) в качестве стандартного языка манипулирования реляционными базами данных и используется как язык доступа к данным многими коммерческими СУБД, включая DB2, SQL/DS, Oracle, INGRES, SYBASE, SQL Server, dBase for Windows, Paradox, Microsoft Access и многие другие. Благодаря своей популярности SQL стал стандартным языком для обмена информацией между компьютерами. Поскольку существует версия SQL, которая может работать почти на любом компьютере и операционной системе, компьютерные системы способны обмениваться данными, передавая друг другу запросы и ответы на языке SQL.</p>\r\n<p>Постоянное развитие стандарта SQL способствовало появлению среди разных произ&shy;водителей и платформ многочисленных диалектов SQL. Эти диалекты развивались главным образом потому, что сообществу пользователей конкретной базы данных тре&shy;бовались какие-то возможности, до того как комитет ANSI разрабатывал стандарт. Однако иногда новую функциональность вводит научно-исследовательское сообщест&shy;во по причине давления со стороны конкурирующих технологий. Например, многие производители баз данных к существующим возможностям программирования своих продуктов добавляют Java (как это делается в DB2, Oracle и Sybase) или VBScript (как это делает Microsoft). В будущем программисты и разработчики будут использо&shy;вать эти языки программирования в SQL-программах наряду с самим SQL.</p>\r\n<p>Многие из этих диалектов включают средства условной обработки (например, под контролем оператора IF...THEN), управляющие операторы (например, циклы WHILE), переменные и обработку ошибок. Поскольку ANSI пока не разработал стандарты для такой важной функциональности, а пользователи уже требуют ее, разработчики реля&shy;ционных СУБД были вправе создавать свои собственные команды и синтаксис. Фак&shy;тически многие из наиболее старых разработчиков сохранили с 80-х годов свои вари&shy;анты самых элементарных команд (например, SELECT) поскольку их реализация предшествовала появлению стандарта. Сейчас ANSI производит уточнение стан&shy;дартов, чтобы сгладить эти несоответствия.</p>\r\n<p>В некоторых диалектах для обеспечения более полной функциональности языка программирования введены процедурные команды. Например, процедурные реализа&shy;ции содержат команды для обработки ошибок, операторы, контролирующие направ&shy;ление выполнения программы, условные команды, средства работы с переменными и массивами, а также многие другие дополнения. Хотя все эти процедурные реализа&shy;ции являются технической дивергенцией языка, здесь они называются диалектами. Пакет SQL/PSM (Persistent Stored Module) предлагает широкий спектр функциональ&shy;ности, связанной с хранимыми программными процедурами, и включает в себя многие расширения, содержащиеся в таких диалектах.</p>\r\n<p>Вот некоторые популярные диалекты SQL:</p>\r\n<ul>\r\n<li><strong>PL/SQL.</strong> Используется в Oracle. PL/SQL &ndash; это сокращение от Procedural Language/SQL. Он во многом похож на язык Ada.</li>\r\n<li><strong>Transact-SQL.</strong> Используется в Microsoft SQL Server и Sybase Adaptive Server. По мере того как Microsoft и Sybase все больше отходят от общей платформы, которую они исполь&shy;зовали в начале 90-х годов, их реализации Transact-SQL также подвергаются дивергенции.</li>\r\n<li><strong>PL/pgSQL.</strong> Название диалекта и расширений SQL, реализованных в PostgreSQL. Является сокра&shy;щением от Procedural Language/postgreSQL.</li>\r\n<li>Самый новый диалект от DB2 (SQLProcedural Language). Основан на стандартных операторах управления SQL. Большинство других диалектов&nbsp; предшествовало стандарту, и это означает, что вы найдете в них массу отличий от стандарта SQL.</li>\r\n</ul>\r\n<p><a name=\"_Toc321819301\"></a><strong>Язык </strong><strong>SQL</strong></p>\r\n<p>Язык SQL обладает следующими достоинствами:</p>\r\n<ol>\r\n<li>независимость от конкретных СУБД. Если при создании БД не использовались нестандартные возможности языка SQL предоставляемые некоторой СУБД, то такую БД можно без изменений перенести на СУБД другого производителя. К сожалению большинство БД используют особенности СУБД, на которой работают, что затрудняет их перенос на другую СУБД без изменений;</li>\r\n<li>реляционная основа. Реляционная модель имеет солидный теоретический фундамент. Язык SQL основан на реляционной модели и является единственным языком для реляционных БД;</li>\r\n<li>SQL обладает высокоуровневой структурой, напоминающей английский язык.</li>\r\n<li>SQL позволяет создавать различные представления данных для различных пользователей;</li>\r\n<li>SQL является полноценным языком для работы с БД;</li>\r\n<li>стандарты языка SQL. Официальный стандарт языка SQL опубликован ANSI и ISO в 1989 году и значительно расширен в 1992 году.</li>\r\n</ol>\r\n<p>Чтобы начать использовать SQL, вы должны понять, как пишутся инструкции. Син&shy;таксические конструкции SQL делятся на четыре основные категории:</p>\r\n<ul>\r\n<li><strong>Идентификаторы</strong><strong>.</strong> Представляют собой пользовательские или системные имена объектов баз дан&shy;ных, таких, как база данных, таблица, ограничение в таблице, столбцы таблицы, представления и т. п.</li>\r\n<li><strong>Константы.</strong> Представляют собой созданные пользователем или системой строки, или значе&shy;ния, не являющиеся идентификаторами или ключевыми словами. Константы могут представлять собой строки, например, &laquo;hello&raquo;, числа, например, &laquo;1234&raquo;, даты, например &laquo;1 января 2002&raquo;, или булевы значения, например TRUE.</li>\r\n<li><strong>Операторы.</strong> Символы, показывающие, какое действие выполняется над одним или несколькими выражениями, чаще всего в инструкциях DELETE, INSERT, SELECT или UPDATE. Операторы также часто применяются для создания объектов базы данных.</li>\r\n<li><strong>Зарезервированные и ключевые слова.</strong> Имеют специальный смысл для обработчика кода SQL. Например, SELECT, GRANT, DELETE или CREATE. Зарезервированные слова (Reserved words), обычно команды и инструкции SQL, нельзя использовать в качестве идентификаторов на данной платформе. Ключевые слова (keywords) - это слова, которые могут стать заре&shy;зервированными в будущем.</li>\r\n</ul>\r\n<p><strong>Идентификаторы</strong></p>\r\n<p>Помните, что СУРБД созданы на основе теории множеств. В терминологии ANSI кластеры содержат множество каталогов, каталоги содержат множество схем, схемы содержат множество объектов и т. д. В большинстве платформ применяются дополни&shy;тельные термины: экземпляры (instances) содержат одну или несколько баз данных, базы данных содержат одну или несколько схем, схемы содержат одну или несколько таблиц, представлений, хранимых процедур и привилегий, связанных с каждым объектом. На каждом уровне структуры элементам необходимы уникальные имена (т. е., иденти&shy;фикаторы), чтобы к ним могли обращаться программы и системные процессы. Это означает, что каждый объект (будь то база данных, таблица, представление, столбец, индекс, ключ, триггер, хранимая процедура или ограничение) в СУРБД должен получить свой идентификатор. Если вы запускаете команду, которая создает объект базы данных, вы должны указать идентификатор (т. е. имя) этого нового объекта.</p>\r\n<p>Есть два важных набора правил, которые опытный программист держит в уме при выборе имени объекта. <em>Соглашения об именах</em></p>\r\n<p>Сюда входят практические руководства или соглашения об именах, применение которых в конечном счете улучшает структуру базы и отслеживание данных. Они являются не столько требованиями SQL, сколько накопленным опытом практи&shy;кующих программистов. <em>Правила создания идентификаторов</em></p>\r\n<p>Они определены в стандарте SQL и реализованы в платформах. Эти правила включают, например, такие параметры, как максимальная длина имени. Эти согла&shy;шения описываются ниже в этой главе применительно к каждому производителю.</p>\r\n<p><strong>Соглашения</strong><strong> об</strong><strong> именах</strong></p>\r\n<ul>\r\n<li><em>Выбирайте имя так, чтобы оно было осмысленным, наглядным и соответствовало назначению объекта.</em> Не называйте таблицу ХРОЗ, назовите лучше Expenses_2005, чтобы было ясно, что в ней содержатся расходы за 2005 год. Помните, что и другим людям скорее всего придется использовать таблицу и базу данных, и возможно, еще в течение долгого времени после того, как вы уйдете. Имена должны быть понятны с перво&shy;го взгляда. У каждого производителя есть свои ограничения на длину имени объ&shy;ектов, но, как правило, имена могут быть достаточно длинными, чтобы любой мог понять их смысл.</li>\r\n<li><em>Используйте в именах один и тот же регистр по всей базе.</em> Используйте для всех имен объектов базы либо верхний, либо нижний регистр. Некоторые серверы баз учитывают регистр, и использование смешения регистров может позже вызвать проблемы.</li>\r\n<li><em>Будьте последовательны в использовании сокращений.</em> Как только сокращение выбрано, его нужно последовательно использовать по всей базе данных. Например, если вы используете ЕМР как сокращение слова EMPLOYEE, то используйте ЕМР по всей базе данных. Не используйте в одних местах ЕМР, а в других - EMPLOYEE.</li>\r\n<li><em>Для удобства восприятия используйте полные, наглядные и осмысленные имена с симво&shy;лами подчеркивания</em>. Имя столбца UPPERCASEWITHLNDERSCORES не такое понятное, как</li>\r\n<li><em>Не помещайте название компании и продуктов в имена объектов баз данных.</em> Компании приобретают друг друга, и продукты меняют названия. Такие элементы преходящи, и их не нужно включать в имена объектов базы.</li>\r\n<li><em>Не используйте слишком очевидные префиксы и суффикс.</em> Например, не используйте в качестве префикса имени базы данных сочетание &laquo;DB_&raquo;, а в качестве префикса всех представлений - &laquo;V_&raquo;. Простые запросы к сис&shy;темным таблицам базы могут дать администратору или программисту базы сведе&shy;ния о том, к какому типу относится объект, который представляет идентификатор.</li>\r\n<li><em>Не заполняйте все пространство, отведенное для имени объекта.</em> Если платформа позволяет использовать имя таблицы из 32 символов, попробуйте оставить хотя бы несколько пустых мест в конце. Некоторые платформы при ма&shy;нипуляции временными копиями таблиц иногда добавляют к именам таблиц пре-фиксы и суффиксы.</li>\r\n<li><em>Не используйте идентификаторы с разделителями.</em> Иногда имена объектов заключают в двойные кавычки. (Стандарт ANSI называет такие имена идентификаторами с разделителями (delimited identifiers). Такое за&shy;ключение идентификатора в кавычки позволяет создавать имена, которые могут оказаться сложными в использовании и которые впоследствии могут вызывать проблемы. Такие идентификаторы чувствительны к регистру. Например, вы можете включать в них пробелы, специальные символы, символы в разных реги&shy;страх и даже управляющие символы. Однако, поскольку некоторые инструменты, выпускаемые сторонними производителями (и даже производителем самой базы), могут не обрабатывать специальные символы в именах, широко использовать по&shy;добные идентификаторы не следует. Некоторые платформы разрешают использо&shy;вать другие символы-ограничители, помимо двойных кавычек. Например, в SQL Server для&nbsp;&nbsp; обозначения&nbsp;&nbsp; идентификаторов&nbsp;&nbsp; с&nbsp;&nbsp; ограничителями&nbsp;&nbsp; применяются квадратные скобки [].</li>\r\n</ul>\r\n<p><strong>Правила</strong><strong> создания</strong><strong> идентификаторов</strong></p>\r\n<p>Идентификаторы должны быть уникальны в пределах своей области действия. Таким образом, в иерархии объектов имена баз данных не должны повторяться в преде&shy;лах данного экземпляра сервера базы, а имена таблиц, представлений, функций, триг&shy;геров и хранимых процедур - уникальны в пределах данной схемы. С другой стороны, таблица и хранимая процедура могут иметь одно имя, поскольку они являются объекта&shy;ми разных типов. Имена столбцов, ключей и индексов должны быть уникальны в преде&shy;лах одной таблицы или представления и т. д. За более подробной информацией обра&shy;щайтесь к документации платформы. В некоторых платформах уникальность идентифи&shy;каторов является обязательным условием, а в других - нет. Например, платформа DB2 требует, чтобы все идентификаторы индексов были уникальны по всей базе данных, a SQL Server требует, чтобы идентификаторы индексов были уникальными только в пре&shy;делах таблицы, к которой они относятся.</p>\r\n<p>Помните, что для обхода некоторых этих правил можно использовать идентифика&shy;торы с ограничителями (т. е. имена объектов, заключенные в специальные символы-огра&shy;ничители, обычно в двойные кавычки). В частности, идентификаторы с разделителями можно применять для того, чтобы давать имена с зарезервированными словами, или для того, чтобы использовать в имени обычно не употребляемые там символы. Например, чаше всего вы не можете использовать в имени таблицы знак процента (%). Однако, если это необходимо, вы можете его использовать, если будете всегда заключать это имя табли&shy;цы в двойные кавычки. Чтобы назвать таблицу expense%%ratios, нужно заключить это имя в кавычки - \"expense%%ratios\". Также помните, что в SQL2003 такие имена иногда называются идентификаторами с разделителями (delimited identifiers).</p>\r\n<p><strong>Константы</strong></p>\r\n<p>В SQL константами считаются любые числовые значения, строки символов, значения, связанные с представлением времени (дата и время), и булевы значения, которые не являются идентификаторами или ключевыми словами. Базы данных на основе SQL разрешают использовать в коде SQL различные константы. Допустимы большинство числовых, символьных и булевых типов данных, а также даты. Например, к числовым типам данных SQL Server можно (среди прочих) отнести типы INTEGER, REAL и MONEY. Таким образом, числовые константы могут выглядеть так.</p>\r\n<p>30</p>\r\n<p>-17</p>\r\n<p>-853 3888</p>\r\n<p>-6.66</p>\r\n<p>$70000</p>\r\n<p>2Е5</p>\r\n<p>7Е-3</p>\r\n<p>Как показывает приведенный пример, в SQL Server допустимы числа со знаком и без знака, в обычной и экспоненциальной записи. А поскольку в SQL Server есть денежный тип данных, в константы можно включать даже знак доллара. В численных константах SQL Server не разрешается использовать другие символы (за исключением 0123456789+ -$.Ее), поэтому не включайте в них запятые (или точки, приме&shy;няемые в Европе). Большинство баз данных интерпретируют запятую в числовой константе как ограничитель элементов. Так, константа 3,000 будет интерпретировать&shy;ся как 3 и отдельно 000.</p>\r\n<p>Булевы значения, строковые константы и даты выглядят примерно так.:</p>\r\n<p>TRUE</p>\r\n<p>\'Hello world!\'</p>\r\n<p>10СT-28-1966 22:14:30:00\'</p>\r\n<p>Строковые константы должны всегда заключаться в одинарные кавычки (\"), которые являются стандартным ограничителем всех строковых констант. Символы в строковых константах не ограничиваются алфавитными символами. По сути, любой символ из набора символов можно представить в виде строковой константы. Все при&shy;веденные ниже выражения являются строковыми константами.</p>\r\n<p>\'1998\'</p>\r\n<p>\'70,000 + 14000\'</p>\r\n<p>\'Жил-был один человек из Нантакета\'</p>\r\n<p>\'Oct 28, 1966\'</p>\r\n<p>Все приведенные примеры фактически являются совместимыми с типом данных CHARACTER. He путайте строковую константу \'1998\' с числовой константой 1998. Когда только строковые константы связаны с типом данных CHARACTER, не стоит использовать их в арифметических вычислениях, не преобразовав их явным образом в числовой тип. Некоторые базы данных выполняют автоматическое преобразование строковых констант, содержащих числа, при выполнении сравнения их с любыми значениями, относящимися к типам DATE или NUMBER.</p>\r\n<p>При необходимости вы можете отобразить в строковой константе символ одинарной кавычки. Для этого его необходимо написать два раза; т. е., каждый раз, когда вам нужно написать внутри строки одинарную кавычку, вы должны написать две. Проиллюстрируем эту идею примером из SQL Server.</p>\r\n<p>SELECT \'So he said&nbsp; \'\'who\'\'s Le Petomaine?\'\' \'</p>\r\n<p>Получится следующий результат.</p>\r\n<p>So he said \'Who\'s Le Petomaine?\'</p>\r\n<p><strong>Операторы</strong></p>\r\n<p>Оператор &ndash; это символ, обозначающий действие, выполняемое над одним или несколькими выражениями. Операторы наиболее часто используются в инструкциях DELETE, INSERT, SELECT или UPDATE, а также часто применяются при создании объектов базы данных, таких, как хранимые процедуры, функции, триггеры и пред&shy;ставления.</p>\r\n<p>Операторы, как правило, делятся на следующие категории:</p>\r\n<ol>\r\n<li><em>Арифметические операторы.</em> Поддерживаются всеми базами данных.</li>\r\n<li><em>Операторы присваивания.</em> Поддерживаются всеми базами данных.</li>\r\n<li><em>Побитовые операторы.</em> Поддерживаются Microsoft SQL Server.</li>\r\n<li><em>Операторы сравнения.</em> Поддерживаются всеми базами данных.</li>\r\n<li><em>Логические операторы.</em> Поддерживаются в DB2, Oracle, SQL Server и PostgreSQL. <em>Унарные операторы.</em> Поддерживаются в DB2, Oracle и SQL Server.</li>\r\n</ol>\r\n<p><strong>Арифметические операторы</strong></p>\r\n<p>Арифметические операторы выполняют математические действия над двумя значе&shy;ниями любого типа, относящегося к числовой категории. Перечень арифметических операторов приведен в табл. 8.1.</p>\r\n<p>Таблица 8.1 Арифметические операторы.</p>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td width=\"167\">\r\n<p><strong>Арифметический оператор</strong></p>\r\n</td>\r\n<td width=\"437\">\r\n<p><strong>Действие</strong></p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"167\">\r\n<p>+</p>\r\n</td>\r\n<td width=\"437\">\r\n<p>Сложение</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"167\">\r\n<p>-</p>\r\n</td>\r\n<td width=\"437\">\r\n<p>Вычитание</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"167\">\r\n<p>*</p>\r\n</td>\r\n<td width=\"437\">\r\n<p>Умножение</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"167\">\r\n<p>/</p>\r\n</td>\r\n<td width=\"437\">\r\n<p>Деление</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"167\">\r\n<p>%</p>\r\n</td>\r\n<td width=\"437\">\r\n<p>Остаток отделения (только SQL Server). Возвращает оста&shy;ток от операции деления в виде целого числа (integer)</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>Операторы</strong><strong> присваивания</strong></p>\r\n<p>За исключением Oracle, где для этой цели применяется оператор :- оператор присваи&shy;вания (=) присваивает значение переменной или псевдониму (alias) заголовка столбца. В SQL Server в качестве оператора для присваивания псевдонимов таблицам или заго&shy;ловкам столбцов может служить ключевое слово AS.</p>\r\n<p><strong>Побитовые операторы</strong></p>\r\n<p>В Microsoft SQL Server существуют побитовые операторы, являющиеся удобным средством манипулирования битами в двух выражениях целого типа (см. табл. 8.2). Для побитовых операторов доступны следующие типы данных: <em>binary, hit, int, smallint, tinyint и varbinary</em>.</p>\r\n<p>Таблица 8.2 Побитовые операторы</p>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td width=\"135\">\r\n<p><strong>Побитовый оператор</strong></p>\r\n</td>\r\n<td width=\"357\">\r\n<p><strong>Действие</strong></p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"135\">\r\n<p>&amp;</p>\r\n</td>\r\n<td width=\"357\">\r\n<p>Поразрядное И (два операнда)</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"135\">\r\n<p>|</p>\r\n</td>\r\n<td width=\"357\">\r\n<p>Поразрядное ИЛИ (два операнда)</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"135\">\r\n<p>^</p>\r\n</td>\r\n<td width=\"357\">\r\n<p>Поразрядное исключающее ИЛИ (два операнда)</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>Операторы сравнения</strong></p>\r\n<p>Операторы сравнения проверяют равенство или неравенство двух выражений. Резуль&shy;татом операции сравнения является булево значение: TRUE, FALSE или UNKNOWN. Также заметьте, что по стандарту ANSI сравнение выражений, когда одно или оба значения равны NULL, дает результат NULL. Например, выражение 23 + NULL дает NULL, как и выражение Feb 23, 2003 + NULL.</p>\r\n<p>Таблица 8.3 Операторы сравнения</p>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td width=\"134\">\r\n<p><strong>Оператор сравнения</strong></p>\r\n</td>\r\n<td width=\"336\">\r\n<p><strong>Действие</strong></p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"134\">\r\n<p>=</p>\r\n</td>\r\n<td width=\"336\">\r\n<p>Равно</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"134\">\r\n<p>&gt;&nbsp;</p>\r\n</td>\r\n<td width=\"336\">\r\n<p>Больше</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"134\">\r\n<p>&lt;&nbsp;</p>\r\n</td>\r\n<td width=\"336\">\r\n<p>Меньше</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"134\">\r\n<p>&gt;=</p>\r\n</td>\r\n<td width=\"336\">\r\n<p>Больше или равно</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"134\">\r\n<p>&lt;=</p>\r\n</td>\r\n<td width=\"336\">\r\n<p>Меньше или равно</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"134\">\r\n<p>&lt;&gt;&nbsp;</p>\r\n</td>\r\n<td width=\"336\">\r\n<p>Не равно</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"134\">\r\n<p>! =</p>\r\n</td>\r\n<td width=\"336\">\r\n<p>Не равно (не соответствует стандарту ANSI)</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"134\">\r\n<p>!&lt;</p>\r\n</td>\r\n<td width=\"336\">\r\n<p>Не меньше (не соответствует стандарту ANSI)</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"134\">\r\n<p>!&gt;</p>\r\n</td>\r\n<td width=\"336\">\r\n<p>Не больше (не соответствует стандарту ANSI)</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>Логические операторы</p>\r\n<p>Логические операторы обычно применяются в предложении WHERE для проверки истинности какого-либо условия. Логические операторы возвращают булево значение TRUE или FALSE. Логические операторы также обсуждаются в разделе &laquo;Инструкция SELECT&raquo; главы 3. Не все базы данных поддерживают все операторы. Список логических операторов приведен в табл. 8.4.</p>\r\n<p>Таблица 8.4 Логические операторы</p>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td width=\"126\">\r\n<p><strong>Логический оператор</strong></p>\r\n</td>\r\n<td width=\"479\">\r\n<p><strong>Действие</strong></p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"126\">\r\n<p>ALL</p>\r\n</td>\r\n<td width=\"479\">\r\n<p>TRUE, если весь набор сравнений дает результат TRUE</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"126\">\r\n<p>AND</p>\r\n</td>\r\n<td width=\"479\">\r\n<p>TRUE, если оба булевых выражения дают результат TRUE</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"126\">\r\n<p>ANY</p>\r\n</td>\r\n<td width=\"479\">\r\n<p>TRUE, если хотя бы одно сравнение из набора дает результат TRUE</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"126\">\r\n<p>BETWEEN</p>\r\n</td>\r\n<td width=\"479\">\r\n<p>TRUE, если операнд находится внутри диапазона</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"126\">\r\n<p>EXISTS</p>\r\n</td>\r\n<td width=\"479\">\r\n<p>TRUE, если подзапрос возвращает хотя бы одну строку</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"126\">\r\n<p>IN</p>\r\n</td>\r\n<td width=\"479\">\r\n<p>TRUE, если операнд равен одному выражению из списка или одной или нескольким строкам, возвращаемым подзапросом</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"126\">\r\n<p>LIKE</p>\r\n</td>\r\n<td width=\"479\">\r\n<p>TRUE, если операнд совпадает с шаблоном</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"126\">\r\n<p>NOT</p>\r\n</td>\r\n<td width=\"479\">\r\n<p>Обращает значение любого другого булевого оператора</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"126\">\r\n<p>OR</p>\r\n</td>\r\n<td width=\"479\">\r\n<p>TRUE, если любое булево выражение равно TRUE</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"126\">\r\n<p>SOME</p>\r\n</td>\r\n<td width=\"479\">\r\n<p>TRUE, если несколько сравнений из набора дают результат TRUE</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>Унарные операторы</p>\r\n<p>Унарные операторы выполняют операцию над одним выражением любого типа, отно&shy;сящимся к числовой категории. Унарные операторы можно применять к целым типам, хотя операторы положительности и отрицательности можно применять к любому число&shy;вому типу данных (см. табл. 8.5).</p>\r\n<p>Таблица 8.5 Унарные операторы</p>\r\n<table width=\"605\">\r\n<tbody>\r\n<tr>\r\n<td width=\"124\">\r\n<p><strong>Унарный оператор</strong></p>\r\n</td>\r\n<td width=\"480\">\r\n<p><strong>Действие</strong></p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"124\">\r\n<p>+</p>\r\n</td>\r\n<td width=\"480\">\r\n<p>Числовое значение становится положительным</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"124\">\r\n<p>-</p>\r\n</td>\r\n<td width=\"480\">\r\n<p>Числовое значение становится отрицательным</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"124\">\r\n<p>~</p>\r\n</td>\r\n<td width=\"480\">\r\n<p>Поразрядное НЕ, возвращает двоичное дополнение числа (пет в Oracle и DB2)</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>Приоритет операторов</strong></p>\r\n<p>Иногда выражения, включающие операторы, могут быть довольно сложными. Когда в выражении присутствуют несколько операторов, последовательность их выполне&shy;ния определяет приоритет операторов. Порядок выполнения может существенно по&shy;влиять на результат вычисления.</p>\r\n<p>Ниже перечислены уровни приоритета операторов. Оператор с более высоким приоритетом выполняется до оператора с более низким приоритетом. В списке опера&shy;торы перечислены в порядке от самого высокого к самому низкому приоритету. () (выражения, стоящие в скобках)</p>\r\n<ol>\r\n<li>+, -, ~ (унарные операторы)</li>\r\n<li>*, /, % (математические операторы)</li>\r\n<li>+, - (арифметические операторы)</li>\r\n<li>=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, !=, !&gt;, !&lt; (операторы сравнения)</li>\r\n<li>^ (побитовое исключающее ИЛИ), &amp; (побитовое И), | (побитовое ИЛИ)</li>\r\n<li>NOT, AND, ALL, ANY, BETWEEN IN LIKE, OR, SOME = (присваивание значение переменной)</li>\r\n</ol>\r\n<p>Если операторы имеют одинаковый приоритет, вычисления производятся слева направо. Для того чтобы изменить применяемый по умолчанию порядок выполнения операторов, в выражении используются скобки. Выражения, заключенные в скобки, вычисляются первыми, а уже после них - все, что находится за скобками.</p>\r\n<p><em>Строковые ограничители</em> обозначают границы строки, состоящей из буквенно-цифро&shy;вых символов. <strong><em>Системные ограничители</em></strong> - это такие символы из набора символов, которые имеют для сервера базы данных особое значение. <strong><em>Ограничители</em></strong> - это символы, которые применяются для определения иерархического порядка процессов и элемен&shy;тов списка. <strong><em>Операторы</em></strong> - это ограничители, используемые для определения значений при операциях сравнения, в том числе символы, обычно используемые для арифме&shy;тических и математических операций. В табл. 6 перечислены системные ограничи&shy;тели и операторы, допустимые в SQL.</p>\r\n<p><strong>Ключевые и зарезервированные слова.</strong></p>\r\n<p>Наряду с символами, которые имеют особый смысл и функции в SQL, существуют и некоторые слова и фразы, имеющие особую значимость. <strong><em>Ключевые слова SQL</em></strong> - это слова, которые настолько тесно связаны с функционированием реляционной базы дан&shy;ных, что их нельзя использовать ни для каких других целей. Как правило, такие слова используются в инструкциях SQL. (Заметьте, что на большинстве платформ их можно использовать в качестве идентификаторов, хотя этого делать не следует.) Например, слово &laquo;SELECT&raquo; является зарезервированным словом, и его не следует использовать в качестве имени таблицы.</p>\r\n<p>С другой стороны, зарезервированные слова в настоящий момент не имеют специ&shy;ального назначения, но они могут приобрести его в будущем. Чтобы подчеркнуть тот факт, что ключевые слова не следует использовать в качестве идентификаторов, но тем не менее такая возможность существует, в стандарте SQL они называются &laquo;незарезервированными ключевыми словами&raquo;. Зарезервированные и ключевые слова SQL не всегда представляют собой слова, используемые в инструкциях SQL, они также могут быть связаны с технологией использования базы данных. Например, слово CASCADE применяется для описания таких манипуляций с данными, в которых действие (например, удаление или обновление) распространяется &laquo;вниз&raquo;, т. е. &laquo;каска&shy;дом&raquo; на все нижележащие таблицы. Зарезервированные и ключевые слова часто пуб&shy;ликуются, чтобы программисты не использовали их в качестве идентификаторов и чтобы в дальнейшем, в следующих версиях, не возникали проблемы.</p>\r\n<p>Основные категории команд языка SQL:</p>\r\n<ul>\r\n<li>DDL &ndash; язык определения данных;</li>\r\n<li>DML &ndash; язык манипулирования данными;</li>\r\n<li>DQL &ndash; язык запросов;</li>\r\n<li>DCL &ndash; язык управления данными;</li>\r\n<li>команды администрирования данных;</li>\r\n<li>команды управления транзакциями.</li>\r\n</ul>\r\n<p>Чаще всего выделяются два языка - язык определения схемы БД (SDL - Schema Definition Language) и язык манипулирования данными (DML - Data Manipulation Language). SDL служил главным образом для определения логической структуры БД, т.е. той структуры БД, какой она представляется пользователям. DML содержал набор операторов манипулирования данными, т.е. операторов, позволяющих заносить данные в БД, удалять, модифицировать или выбирать существующие данные.</p>\r\n<p><strong><em>Data Definition Language (DDL) (язык описания данных) </em></strong>&mdash; это семейство компьютерных языков, используемых в компьютерных программах для описания структуры баз данных.</p>\r\n<p>Функции языков DDL определяются первым словом в предложении (часто называемом запросом), которое почти всегда является глаголом. В случае с SQL это глаголы &mdash; &laquo;create&raquo; (&laquo;создать&raquo;), &laquo;alter&raquo; (&laquo;изменить&raquo;), &laquo;drop&raquo; (&laquo;удалить&raquo;). Эти запросы или команды часто смешиваются с другими командами SQL, в связи с чем DDL не является отдельным компьютерным языком.</p>\r\n<p>Запрос &laquo;create&raquo; используется для создания базы данных, таблицы, индекса, представления или хранимой процедуры. Запрос &laquo;alter&raquo; используется для изменения существующего объекта базы данных (таблицы, индекса, представления или хранимой процедуры) или самой базы данных. Запрос &laquo;drop&raquo; используется для удаления существующего объекта базы данных (таблицы, индекса, представления или хранимой процедуры) или самой базы данных. И наконец, в DDL существуют понятия первичного и внешнего ключа, которые осуществляют соблюдение целостности данных. Команды \"первичный ключ\" primary key, \"внешний ключ\" foreign key включаются в запросы &laquo;create table\", &laquo;alter table&raquo;.</p>\r\n<p><strong><em>Data Manipulation Language (DML) (язык управления (манипулирования) данными)</em></strong> &mdash; это семейство компьютерных языков, используемых в компьютерных программах или пользователями баз данных для получения, вставки, удаления или изменения данных в базах данных.</p>\r\n<p>Языки DML изначально использовались только компьютерными программами, но с появлением SQL стали также использоваться и людьми.</p>\r\n<p>Функции языков DML определяются первым словом в предложении (часто называемом запросом), которое почти всегда является глаголом. В случае с SQL эти глаголы &mdash; &laquo;select&raquo; (&laquo;выбрать&raquo;), &laquo;insert&raquo; (&laquo;вставить&raquo;), &laquo;update&raquo; (&laquo;обновить&raquo;), и &laquo;delete&raquo; (&laquo;удалить&raquo;). Это превращает природу языка в ряд обязательных утверждений (команд) к базе данных.</p>\r\n<p>Языки DML могут существенно различаться у различных производителей СУБД. Существует стандарт SQL, установленный ANSI, но производители СУБД часто предлагают свои собственные &laquo;расширения&raquo; языка.</p>\r\n<p>Языки DML разделяются в основном на два типа:</p>\r\n<ul>\r\n<li>Procedural DMLs &mdash; описывают действия над данными.</li>\r\n<li>Declarative DMLs &mdash; описывают сами данные.</li>\r\n</ul>\r\n<p>&nbsp;</p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Как развивался язык запросов SQL?</li>\r\n<li>В чем основные преимущества языка SQL?</li>\r\n<li>Какие категории языков объединяет в себе SQL?</li>\r\n<li>Что такое оператор?</li>\r\n<li>Какие виды констант существуют в SQL?</li>\r\n<li>Какие группы опертаоров языка SQL вы знаете?</li>\r\n<li>Что такое идентификатор?</li>\r\n<li>Что такое язык опреления данных?</li>\r\n<li>Что такое язык манипулирование данных?</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'История SQL\r\nЯзык SQL\r\nЯзык определения данных	\r\nЯзык манипулирования данными.',0),(9,'2016-09-14 06:40:48','Лекция 9. SQL: манипулирование данными',9,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>Добавление, обновление, удаление данных</li>\r\n<li>Агрегатные функции языка SQL и группировка.</li>\r\n<li>Соединение таблиц.</li>\r\n<li>Вложенные запросы.</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Как производится выборка данных?</li>\r\n<li>Как производится обновление данных?</li>\r\n<li>Как производится удаление данных?</li>\r\n<li>Как добавляются строки в таблицу?</li>\r\n<li>Что такое агрегатная функция?</li>\r\n<li>Перечислите основные агрегатные функции.</li>\r\n<li>Где используется HAVING?</li>\r\n<li>Какие виды соединений бывают?</li>\r\n<li>Что такое самосоединение?</li>\r\n<li>Объясните пошагово как производится соединение?</li>\r\n<li>Как выполняется подзапрос?</li>\r\n<li>Что такое соотнесенный подзапрос?</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'Добавление, обновление, удаление данных\r\nАгрегатные функции языка SQL и группировка.\r\nСоединение таблиц.\r\nВложенные запросы.',0),(10,'2016-09-14 06:41:51','Лекция 10. SQL: определение данных',10,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>Создание базы данных.</li>\r\n<li>Создание и модификация таблиц базы данных.</li>\r\n<li>Создание представлений и последовательностей.</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Ключевые слова: таблица, домен, </strong><strong>collocation</strong></p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><a name=\"_Toc321819302\"></a><strong>Язык определения данных</strong><strong>.</strong></p>\r\n<p>В состав языка определения входят операторы:</p>\r\n<ol>\r\n<li>CREATE&nbsp;&ndash; создает объектов базы данных</li>\r\n<li>ALTER &ndash; изменяет объект</li>\r\n<li>DROP &ndash;удаляет объект</li>\r\n<li>Стандарт ANSI SQL-92 определяет команды для следующих объектов:</li>\r\n<li>ASSERTION &ndash; утверждения для проверки</li>\r\n<li>CHARACTER SET &ndash; набор символов</li>\r\n<li>COLLATION &ndash; правила сортировки для набора символов</li>\r\n<li>DOMAIN &ndash; домен (пользовательского типа данных столбца).</li>\r\n<li>SCHEMA &ndash; схема (именованной группы объектов)</li>\r\n<li>TABLE &ndash; таблица базы данных</li>\r\n<li>TRANSLATION &ndash; правила преобразования (трансляции) из одного набора символов в другой (используется в операторе TRANSLATE)</li>\r\n<li>VIEW &ndash; представления данных</li>\r\n</ol>\r\n<p><strong>Типы данных.</strong></p>\r\n<p>ANSI SQL включает в себя следующие типы данных</p>\r\n<p><strong>Символьные строки:</strong></p>\r\n<ul>\r\n<li>CHARACTER(<em>n</em>)или CHAR(<em>n</em>) &mdash; строка фиксированной длины в <em>n</em> символов, разделенная пробелами;</li>\r\n<li>CHARACTER VARYING(<em>n</em>)или VARCHAR(<em>n</em>) &mdash; строка переменной длины с максимальным количеством символов <em>n</em>;</li>\r\n<li>NATIONAL CHARACTER(<em>n</em>)или NCHAR(<em>n</em>) &mdash; строка фиксированной длины с поддержкой международных кодировок</li>\r\n<li>NATIONAL CHARACTER VARYING(<em>n</em>)или NVARCHAR(<em>n</em>) &mdash; строка переменной длины</li>\r\n</ul>\r\n<p><strong>Битовые данные:</strong></p>\r\n<ul>\r\n<li>BIT(<em>n</em>) &mdash; массив из <em>n</em> битов</li>\r\n<li>BIT VARYING(<em>n</em>) &mdash; массив длинной до <em>n</em> битов</li>\r\n</ul>\r\n<p><strong>Числа:</strong></p>\r\n<ul>\r\n<li>INTEGER и SMALLINT &mdash; целые числа;</li>\r\n<li>FLOAT, REAL и DOUBLE PRECISION &mdash; вещественные числа;</li>\r\n<li>NUMERIC(<em>precision</em>, <em>scale</em>)или DECIMAL(<em>precision</em>, <em>scale</em>)&mdash; &shy;вещественное число с указанием в скобках количество знаков до запятой и после запятой.</li>\r\n</ul>\r\n<p><strong>Дата и время:</strong></p>\r\n<ul>\r\n<li>DATE &mdash; дата (2010-05-30);</li>\r\n<li>TIME &mdash; время (14:55:37);</li>\r\n<li>TIME WITH TIME ZONE или TIMESTAMP&mdash; тоже самое, что и TIME, только исключаются данные о часовом поясе;</li>\r\n<li>TIMESTAMP &mdash; это DATE и TIME соединенные вместе в одной переменной (2010-05-30 14:55:37).</li>\r\n<li>TIMESTAMP WITH TIME ZONE or TIMESTAMPTZ &mdash; тоже самое, что и TIMESTAMP, только исключаются данные о часовом поясе.</li>\r\n</ul>\r\n<p><strong>Домен.</strong></p>\r\n<p>Создание домена:</p>\r\n<p>CREATE DOMAIN <em>&lt;имя_домена&gt;</em> [AS] <em>&lt;тип_данных&gt;</em></p>\r\n<p>[DEFAULT {<em>LITERAL</em> | NULL | USER}]</p>\r\n<p>&nbsp; [NOT NULL] [CHECK (<em>&lt;</em><em>условие</em><em>&gt;</em>)]</p>\r\n<p>&nbsp; [COLLATE <em>&lt;</em><em>имя_сортировки</em><em>&gt;</em>];</p>\r\n<p>где</p>\r\n<ul>\r\n<li><strong><em>DEFAULT</em></strong> &shy;&ndash; Определяет значение по умолчанию, которое вставляется, когда ни какой другой ввод не сделан. Значения:</li>\r\n<li><strong><em>LITERAL</em></strong> &ndash; Вводится определенная строка, числовое значение или дата.</li>\r\n<li><strong><em>NULL</em></strong> &ndash; Вводится значение NULL.</li>\r\n<li><strong><em>USER</em></strong> &ndash; Вводится имя текущего пользователя. Столбец должен быть совместимый символьный тип, чтобы использовать значение по умолчанию.</li>\r\n<li><strong><em>NOT NULL</em></strong> &ndash; Определяет, что значения, введенные в столбец, не могут быть NULL.</li>\r\n<li><strong><em>CHECK</em></strong> &ndash; (&lt;условие&gt;) создает одиночное CHECK ограничение для домена.</li>\r\n<li><strong><em>VALUE</em></strong> &ndash; Заменитель для имени столбца, в конечном счете, основанном на домене.</li>\r\n<li><strong><em>COLLATE &lt;имя_сортировки&gt;</em></strong> &ndash; Устанавливает способ сортировки для домена.</li>\r\n</ul>\r\n<p>Следующая инструкция создает домен, который может принимать положительные значения больше 1000, со значением по умолчанию 9999. Ключевое слово VALUE заменяется именем столбца основанном на этом домене.</p>\r\n<p>CREATE DOMAIN CUSTNO</p>\r\n<p>&nbsp; AS INTEGER</p>\r\n<p>&nbsp;&nbsp;&nbsp; DEFAULT 9999</p>\r\n<p>&nbsp;&nbsp;&nbsp; CHECK (VALUE &gt; 1000);</p>\r\n<p>Следующая инструкция ограничивает введенные значения в домен до четырех определенных значений:</p>\r\n<p>CREATE DOMAIN PRODTYPE</p>\r\n<p>&nbsp; AS VARCHAR(12)</p>\r\n<p>&nbsp;&nbsp;&nbsp; CHECK (VALUE IN (\"software\", \"hardware\", \"other\", \"N/A\"));</p>\r\n<p>Изменение домена:</p>\r\n<p>ALTER DOMAIN &lt;имя_домена&gt; {</p>\r\n<p>[SET DEFAULT {LITERAL | NULL | USER}]</p>\r\n<p>&nbsp; | [DROP DEFAULT]</p>\r\n<p>&nbsp; | [ADD [CONSTRAINT] CHECK (&lt;условие&gt;)]</p>\r\n<p>&nbsp; | [DROP CONSTRAINT]</p>\r\n<p>&nbsp; };</p>\r\n<p>где</p>\r\n<ul>\r\n<li><strong><em>SET DEFAULT</em></strong> &ndash; Определяет значение столбца по умолчанию, которое будет введено, когда ни какой другой ввод не сделан. Значения:</li>\r\n<li><strong><em>LITERAL &ndash;</em></strong> Вводится определенная строка, числовое значение или дата.</li>\r\n<li><strong><em>NULL &ndash;</em></strong> Вводится значение NULL.</li>\r\n<li><strong><em>USER &ndash;</em></strong> Вводится имя текущего пользователя. Столбец должен быть совместимого текстового типа для использования значения по умолчанию.</li>\r\n</ul>\r\n<p>Установка значения по умолчанию на уровне столбца отменяет установку значения по умолчанию на уровне домена.</p>\r\n<ul>\r\n<li><strong><em>DROP DEFAULT</em></strong> &ndash; Удаляет существующее значение по умолчанию.</li>\r\n<li><strong><em>ADD [CONSTRAINT] CHECK (&lt;условие&gt;)</em></strong> &ndash; Добавляет CHECK ограничения в определение домена. Определение домена может включать только одно CHECK ограничение.</li>\r\n<li><strong><em>DROP CONSTRAINT</em></strong> &ndash; Удаляет CHECK ограничения из определения домена.</li>\r\n</ul>\r\n<p>Следующая инструкция устанавливает значение домена по умолчанию к 9999.</p>\r\n<p>ALTER DOMAIN CUSTNO SET DEFAULT 9999;</p>\r\n<p>Удаление домена:</p>\r\n<p>DROP DOMAIN &lt;имя_домена&gt;;</p>\r\n<p><strong>Схема</strong></p>\r\n<p>Создание базы данных:</p>\r\n<p>CREATE {DATABASE | SCHEMA} &lt;имя_базы_данных&gt;</p>\r\n<p>Удаление базы данных:</p>\r\n<p>DROP {DATABASE | SCHEMA} &lt;имя_базы_данных&gt;</p>\r\n<p><strong>Таблица</strong><strong>.</strong></p>\r\n<p>Создание таблицы</p>\r\n<p>CREATE TABLE [ IF NOT EXISTS ] &lt;имя_таблицы&gt;</p>\r\n<p>(</p>\r\n<p>&lt;имя столбца_1&gt; &lt;тип данных&gt; [ DEFAULT expression ] [ {NULL | NOT NULL} ] [ {INDEX_BLIST | INDEX_NONE} ]</p>\r\n<p>&nbsp;</p>\r\n<p>&lt;имя столбца_2&gt; &lt;тип данных&gt; [ DEFAULT expression ] [ {NULL | NOT NULL} ] [ {INDEX_BLIST | INDEX_NONE} ]</p>\r\n<p>&nbsp;</p>\r\n<p>...</p>\r\n<p>&nbsp;</p>\r\n<p>&lt;имя столбца_N&gt; &lt;тип данных&gt; [ DEFAULT expression ] [ {NULL | NOT NULL} ] [ {INDEX_BLIST | INDEX_NONE} ]</p>\r\n<p>&nbsp;</p>\r\n<p>[ CONSTRAINT &lt;имя ограничения&gt; ]</p>\r\n<p>PRIMARY KEY ( &lt;имя столбца_1&gt;, &lt;имя столбца_2&gt;, ... ) |</p>\r\n<p>&nbsp;</p>\r\n<p>FOREIGN KEY (&lt;имя столбца_1&gt;, &lt;имя столбца_2&gt;, ... ) REFERENCES &lt;имя_таблицы_2&gt; [ (&lt;имя столбца_1&gt;, &lt;имя столбца_2&gt;, ... ) ] [ ON UPDATE {NO ACTION | SET NULL | SET DEFAULT | CASCADE} ] [ ON DELETE {NO ACTION | SET NULL | SET DEFAULT | CASCADE} ] |</p>\r\n<p>&nbsp;</p>\r\n<p>UNIQUE (&lt;имя столбца_1&gt;, &lt;имя столбца_2&gt;, ... ) |</p>\r\n<p>&nbsp;</p>\r\n<p>CHECK ( &lt;условие&gt; ) [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ] [ {NOT DEFERRABLE | DEFERRABLE} ]</p>\r\n<p>);</p>\r\n<p>где</p>\r\n<ul>\r\n<li><strong><em>DEFAULT</em></strong> expression &ndash; значение по умолчанию;</li>\r\n<li><strong><em>NULL</em></strong> | <strong><em>NOT </em></strong><strong><em>NULL</em></strong> &ndash; разрешается ли пустое поле;</li>\r\n<li><strong><em>INDEX_BLIST</em></strong> | <strong><em>INDEX_NONE</em></strong> &ndash; есть или нет индекса;</li>\r\n<li><strong>CONSTRAINT</strong> &ndash; ограничение</li>\r\n<li><strong><em>PRIMARY KEY &ndash; </em></strong>первичный ключ</li>\r\n<li><strong><em>FOREIGN KEY &ndash; </em></strong>вторичный ключ</li>\r\n<li>ON DELETE &ndash; при удалении в родительской таблице</li>\r\n<li>ON UPDATE &ndash; при обновлении в родительской таблице</li>\r\n<li>NO ACTION &shy;&ndash; нет действий</li>\r\n<li>SET NULL &ndash; устанавливается значение NULL</li>\r\n<li>SET DEFAULT &ndash; устанавливается значение по умолчанию</li>\r\n<li>CASCADE &ndash; каскадно</li>\r\n<li><strong><em>UNIQUE &ndash; </em></strong>уникальный</li>\r\n<li><strong><em>CHECK &ndash; </em></strong>проверка</li>\r\n</ul>\r\n<p>Например</p>\r\n<p>CREATE TABLE Customer (</p>\r\n<p>&nbsp; number VARCHAR(40)&nbsp; NOT NULL,</p>\r\n<p>&nbsp; name&nbsp;&nbsp; VARCHAR(100) NOT NULL,</p>\r\n<p>&nbsp; ssn&nbsp;&nbsp;&nbsp; VARCHAR(50)&nbsp; NOT NULL,</p>\r\n<p>&nbsp; age&nbsp;&nbsp;&nbsp; INTEGER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOT NULL,</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp; CONSTRAINT cust_pk PRIMARY KEY (number),</p>\r\n<p>&nbsp; UNIQUE ( ssn ),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (An anonymous constraint)</p>\r\n<p>&nbsp; CONSTRAINT age_check CHECK (age &gt;= 0 AND age &lt; 200)</p>\r\n<p>);</p>\r\n<p>Изменение таблицы:</p>\r\n<p>Переименование таблицы</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; RENAME TO &lt;новое_имя_таблицы&gt;</p>\r\n<p>Переименование столбца</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; RENAME [ COLUMN ] &lt;имя_столбца&gt; TO &lt;новое_имя_столбца&gt;</p>\r\n<p>Добавление столбца</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; ADD [COLUMN] &lt;имя_столбца&gt; &lt;тип_данных&gt; [ DEFAULT expression ] [ {NULL | NOT NULL} ] [ {INDEX_BLIST | INDEX_NONE} ]</p>\r\n<p>Добавление первичного ключа ограничения к таблице</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; ADD [ CONSTRAINT &lt;имя ограничения&gt; ]</p>\r\n<p>PRIMARY KEY ( &lt;имя столбца_1&gt;, &lt;имя столбца_2&gt;, ... ) |</p>\r\n<p>Добавление вторичного ключа ограничения к таблице</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; ADD [ CONSTRAINT &lt;имя ограничения&gt; ]</p>\r\n<p>FOREIGN KEY (&lt;имя столбца_1&gt;, &lt;имя столбца_2&gt;, ... ) REFERENCES &lt;имя_таблицы_2&gt; [ (&lt;имя столбца_1&gt;, &lt;имя столбца_2&gt;, ... ) ] [ ON UPDATE {NO ACTION | SET NULL | SET DEFAULT | CASCADE} ] [ ON DELETE {NO ACTION | SET NULL | SET DEFAULT | CASCADE} ] |</p>\r\n<p>Добавление уникального поля к таблице</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; ADD [ CONSTRAINT &lt;имя ограничения&gt; ]</p>\r\n<p>UNIQUE (&lt;имя столбца_1&gt;, &lt;имя столбца_2&gt;, ... ) |</p>\r\n<p>Добавление проверки столбца к таблице</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; ADD [ CONSTRAINT &lt;имя ограничения&gt; ]</p>\r\n<p>CHECK ( &lt;условие&gt; ) [ {INITIALLY DEFERRED | INITIALLY IMMEDIATE} ] [ {NOT DEFERRABLE | DEFERRABLE} ]</p>\r\n<p>Изменение типа данных столбца</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; MODIFY \"column 1\" \"New Data Type\"</p>\r\n<p>Изменение столбца ограничений столбца</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; ALTER [COLUMN] column_name SET default_expr</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; ALTER [COLUMN] column_name DROP DEFAULT</p>\r\n<p>Изменение удаление столбца</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; DROP [COLUMN] column_name</p>\r\n<p>Удаление ограничения таблицы</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; DROP CONSTRAINT constraint_name</p>\r\n<p>Удаление первичного ключа</p>\r\n<p>ALTER TABLE &lt;имя_таблицы&gt; DROP PRIMARY KEY</p>\r\n<p>Удаление таблицы</p>\r\n<p>DROP TABLE [ IF EXISTS ] &lt;имя_таблицы&gt;</p>\r\n<p><strong>Представления.</strong></p>\r\n<p><strong><em>Представление (VIEW) </em></strong>- объект данных который не содержит никаких данных его владельца. Это - тип таблицы, чье содержание выбирается из других таблиц с помощью выполнения запроса. Поскольку значения в этих таблицах меняются, то автоматически, их значения могут быть показаны представлением. В этой главе, вы узнаете, что такое представления, как они создаются, и немного об их возможностях и ограничениях. Использование представлений, основанных на улучшенных средствах запросов, таких как объединение и подзапрос, разработанных очень тщательно, в некоторых случаях даст больший выигрыш по сравнению с запросами.</p>\r\n<p>Представления - это таблицы чье содержание выбирается или получается из других таблиц. Они работают в запросах и операторах DML точно также, как и основные таблицы, но не содержат никаких собственных данных. Представления - подобны окнам, через которые вы просматриваете информацию (как она есть, или в другой форме, как вы потом увидите), которая фактически хранится в базовой таблице. Представление - это фактически запрос, который выполняется всякий раз, когда представление становится темой команды. Вывод запроса при этом в каждый момент становится содержанием представления.</p>\r\n<p>Вы создаете представление командой CREATE VIEW. Она состоит из слов CREATE VIEW (СОЗДАТЬ ПРЕДСТАВЛЕНИЕ), имени представления которое нужно создать, слова AS (КАК), и далее запроса, как в следующем примере:</p>\r\n<p>CREATE VIEW Londonstaff</p>\r\n<p>AS SELECT *</p>\r\n<p>FROM Salespeople</p>\r\n<p>WHERE city = \'London\';</p>\r\n<p>Теперь Вы имеете представление, называемое Londonstaff. Вы можете использовать это представление точно так же, как и любую другую таблицу. Она может быть запрошена, модифицирована, вставлена в, удалена из, и соединена с, другими таблицами и представлениями. Давайте сделаем запрос такого представления (вывод показан в Рисунке 10.1):</p>\r\n<p>&nbsp;</p>\r\n<p>SELECT *</p>\r\n<p>FROM Londonstaff;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>===============&nbsp; SQL Execution Log ============</p>\r\n<p>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| SELECT *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| FROM&nbsp; Londonstaff;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</p>\r\n<p>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| ==============================================|</p>\r\n<p>|&nbsp;&nbsp; snum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; city&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comm&nbsp;&nbsp; |</p>\r\n<p>| ------&nbsp;&nbsp;&nbsp; ----------&nbsp;&nbsp; -----------&nbsp;&nbsp; -------&nbsp; |</p>\r\n<p>|&nbsp;&nbsp; 1001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Peel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; London&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;0.1200&nbsp; |</p>\r\n<p>|&nbsp;&nbsp; 1004&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Motika&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; London&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.1100&nbsp; |</p>\r\n<p>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>===============================================</p>\r\n<p>Рис. 10.1: Представление Londonstaff .</p>\r\n<p>Когда вы приказываете SQL выбрать (SELECT) все строки ( * ) из представления, он выполняет запрос содержащий в определении - Londonstaff, и возвращает все из его вывода. Имея предикат в запросе представления, можно вывести только те строки из представления, которые будут удовлетворять этому предикату. Если это так, вы будете должны выбрать другое им для вашего представления). Преимущество использования представления, по сравнению с основной таблицы, в том, что представление будет модифицировано автоматически всякий раз, когда таблица, лежащая в его основе, изменяется. Содержание представления не фиксировано, и переназначается каждый раз, когда вы ссылаетесь на представление в команде. Если вы добавите завтра другого, живущего в Лондоне продавца, он автоматически появится в представлении.</p>\r\n<p>Представления значительно расширяют управление вашими данными. Это - превосходный способ дать публичный доступ к некоторой, но не всей информации в таблице. Если вы хотите чтобы ваш продавец был показан в таблице Продавцов, но при этом не были показаны комиссии других продавцов, вы могли бы создать представление с использованием следующего оператора (вывод показан в Рис 10.2)</p>\r\n<p>CREATE VIEW Salesown</p>\r\n<p>AS SELECT snum, sname, city</p>\r\n<p>FROM Salespeople:</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>===============&nbsp; SQL Execution Log ============</p>\r\n<p>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</p>\r\n<p>| SELECT *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| FROM&nbsp; Salesown;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| ==============================================|</p>\r\n<p>|&nbsp;&nbsp; snum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; city &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</p>\r\n<p>| ------&nbsp;&nbsp;&nbsp; ----------&nbsp;&nbsp; -----------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>|&nbsp;&nbsp; 1001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Peel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; London&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>|&nbsp;&nbsp; 1002&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serres&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; San Jose&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>|&nbsp;&nbsp; 1004&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Motika&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; London&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>|&nbsp;&nbsp; 1007&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rifkin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Barcelona&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</p>\r\n<p>|&nbsp;&nbsp; 1003&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Axelrod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; New York&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>===============================================</p>\r\n<p>Рис 10.2: Представление Salesown</p>\r\n<p>Другими словами, это представление - такое же как для таблицы Продавцов, за исключением того, что поле comm, не упоминалось в запросе, и, следовательно, не было включено в представление.</p>\r\n<p><strong>Модифицирование представлений</strong></p>\r\n<p>&nbsp;</p>\r\n<p>Представление может теперь изменяться командами модификации DML, но модификация не будет воздействовать на само представление. Команды будут на самом деле перенаправлены к базовой таблице:</p>\r\n<p>UPDATE Salesown</p>\r\n<p>SET city = \'Palo Alto\'</p>\r\n<p>WHERE snum = 1004;</p>\r\n<p>Его действие идентично выполнению той же команды в таблице Продавцов. Однако, если значение комиссионных продавца будет обработано командой UPDATE</p>\r\n<p>UPDATE Salesown</p>\r\n<p>SET comm = .20</p>\r\n<p>WHERE snum = 1004;</p>\r\n<p>она будет отвергнута, так как поле comm отсутствует в представлении Salesown. Это важное замечание, показывающее, что не все представления могут быть модифицированы.</p>\r\n<p><strong>Именование столбцов.</strong></p>\r\n<p>В нашем примере, пол наших представлений имеют свои имена, полученные прямо из имен полей основной таблицы. Это удобно. Однако, иногда вам нужно снабжать ваши столбцы новыми именами:</p>\r\n<ul>\r\n<li>когда некоторые столбцы являются выводимыми, и поэтому не имеющими имен.</li>\r\n<li>когда два или более столбцов в объединении, имеют те же имена что в их базовой таблице.</li>\r\n</ul>\r\n<p>Имена, которые могут стать именами полей, даются в круглых скобках ( ), после имени таблиц. Они не будут запрошены, если совпадают с именами полей запрашиваемой таблицы. Тип данных и размер этих полей будут отличаться от запрашиваемых полей, которые \"передаются\" в них. Обычно вы не указываете новых имен полей, но если вы все-таки сделали это, вы должны делать это для каждого пол в представлении.</p>\r\n<p><strong>Комбинирование предикатов представлений и основных запросов в представлениях.</strong></p>\r\n<p>Когда вы делаете запрос представления, вы собственно, запрашиваете запрос. Основной способ для SQL обойти это, - объединить предикаты двух запросов в один. Давайте посмотрим еще раз на наше представление с име- нем Londonstaff :</p>\r\n<p>&nbsp;CREATE VIEW Londonstaff</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; AS SELECT *</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; FROM Salespeople</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; WHERE city = \'London\';</p>\r\n<p>Если мы выполняем следующий запрос в этом представлении</p>\r\n<p>&nbsp;SELECT *</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; FROM Londonstaff</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; WHERE comm &gt; .12;</p>\r\n<p>он такой же, как если бы мы выполнили следующее в таблице Продавцов:</p>\r\n<p>&nbsp;SELECT *</p>\r\n<p>FROM Salespeople</p>\r\n<p>WHERE city = \'London\'</p>\r\n<p>AND comm &gt; .12;</p>\r\n<p>Это прекрасно, за исключением того, что появляется возможна проблема с представлением. Имеется возможность комбинации из двух полностью допустимых предикатов и получения предиката который не будет работать. Например, предположим, что мы создаем (CREATE) следующее представление:</p>\r\n<p>CREATE VIEW Ratingcount (rating, number)</p>\r\n<p>AS SELECT rating, COUNT (*)</p>\r\n<p>FROM Customers</p>\r\n<p>GROUP BY rating;</p>\r\n<p>Это дает нам число заказчиков, которые мы имеем для каждого уровня оценки(rating). Вы можете затем сделать запрос этого представления чтобы выяснить, имеется ли какая-нибудь оценка, в настоящее время назначенная для трех заказчиков:</p>\r\n<p>SELECT *</p>\r\n<p>FROM Ratingcount</p>\r\n<p>WHERE number = 3;</p>\r\n<p>Посмотрим, что случится если мы скомбинируем два предиката:</p>\r\n<p>&nbsp;SELECT rating, COUNT (*)</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; FROM Customers</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp; WHERE COUNT (*) = 3</p>\r\n<p>GROUP BY rating;</p>\r\n<p>Это недопустимый запрос. Агрегатные функции, такие как COUNT (СЧЕТ), не могут использоваться в предикате. Правильным способом при формировании вышеупомянутого запроса, конечно же будет следующий:</p>\r\n<p>SELECT rating, COUNT (*)</p>\r\n<p>FROM Customers</p>\r\n<p>GROUP BY rating;</p>\r\n<p>HAVING COUNT (*) = 3;</p>\r\n<p>Но SQL может не выполнить превращения. Может ли равноценный запрос вместо запроса Ratingcount потерпеть неудачу? Да может! Это - неоднозначна область SQL, где методика использования представлений может дать хорошие результаты. Самое лучшее что можно сделать в случае, когда об этом ничего не сказано в вашей системной документации, так это попытка в ней разобраться. Если команда допустима, вы можете использовать представления чтобы установить некоторые ограничения SQL в синтаксисе запроса.</p>\r\n<p><strong>Групповые представления.</strong></p>\r\n<p>Групповые представления - это представления, наподобие запроса Ratingcount в предыдущем примере, который содержит предложение GROUP BY, или который основывается на других групповых представлениях. Групповые представления могут стать превосходным способом обрабатывать полученную информацию непрерывно. Предположим, что каждый день вы должны следить за порядком номеров заказчиков, номерами продавцов принимающих порядки, номерами порядков, средним от порядков, и общей суммой приобретений в порядках.</p>\r\n<p>Чем конструировать каждый раз сложный запрос, вы можете просто создать следующее представление:</p>\r\n<p>CREATE VIEW Totalforday</p>\r\n<p>AS SELECT odate, COUNT (DISTINCT cnum), COUNT</p>\r\n<p>(DISTINCT snum), COUNT (onum), AVG</p>\r\n<p>(amt), SUM (amt)</p>\r\n<p>FROM Orders</p>\r\n<p>GROUP BY odate;</p>\r\n<p>Теперь вы сможете увидеть всю эту информацию с помощью простого запроса:</p>\r\n<p>SELECT *</p>\r\n<p>FROM Totalforday;</p>\r\n<p>Как мы видели, SQL запросы могут дать вам полный комплекс возможностей, так что представления обеспечивают вас чрезвычайно гибким и мощным инструментом чтобы определить точно, как ваши данные могут быть использованы. Они могут также делать вашу работу более простой, переформатируя данные удобным для вас способом и исключив двойную работу.</p>\r\n<p><strong>Представления и объединения.</strong></p>\r\n<p>Представления не требуют, чтобы их вывод осуществлялся из одной базовой таблицы. Так как почти любой допустимый запрос SQL может быть использован в представлении, он может выводить информацию из любого числа базовых таблиц, или из других представлений. Мы можем, например, создать представление, которое показывало бы, порядки продавца и заказчика по имени:</p>\r\n<p>CREATE VIEW Nameorders</p>\r\n<p>AS SELECT onum, amt, a.snum, sname, cname</p>\r\n<p>FROM Orders a, Customers b, Salespeople c</p>\r\n<p>WHERE a.cnum = b.cnum</p>\r\n<p>AND a.snum = c.snum;</p>\r\n<p>Теперь вы можете выбрать (SELECT) все порядки заказчика или продавца (*), или можете увидеть эту информацию для любого порядка. Например, чтобы увидеть все порядки продавца Rifkin, вы должны ввести следующий запрос (вывод показан в рис. 10.3):</p>\r\n<p>&nbsp;SELECT *</p>\r\n<p>&nbsp;FROM Nameorders</p>\r\n<p>&nbsp;WHERE sname = \'Rifkin\';</p>\r\n<p>&nbsp;</p>\r\n<p>===============&nbsp; SQL Execution Log ==============</p>\r\n<p>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| SELECT *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| FROM&nbsp; Nameorders&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| WHERE sname = \'Rifkin\';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| =============================================== |</p>\r\n<p>|&nbsp;&nbsp; onum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snum&nbsp;&nbsp; sname&nbsp;&nbsp;&nbsp;&nbsp; cname&nbsp;&nbsp; |</p>\r\n<p>|&nbsp; ------&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; -----&nbsp; -------&nbsp;&nbsp; -------&nbsp; |</p>\r\n<p>|&nbsp;&nbsp; 3001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18.69&nbsp;&nbsp;&nbsp;&nbsp; 1007&nbsp; Rifkin&nbsp;&nbsp;&nbsp; Cisneros |</p>\r\n<p>|&nbsp;&nbsp; 3006&nbsp;&nbsp;&nbsp;&nbsp; 1098.16&nbsp;&nbsp;&nbsp;&nbsp; 1007&nbsp; Rifkin&nbsp;&nbsp;&nbsp; Cisneros |</p>\r\n<p>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>================================================</p>\r\n<p>Рис. 10.3: Порядки Rifkin показанные в Nameorders</p>\r\n<p>Вы можете также объединять представления с другими таблицами, или базовыми таблицами или представлениями, поэтому вы можете увидеть все порядки Axelrodа и значения его комиссионных в каждом порядке:</p>\r\n<p>SELECT a.sname, cname, amt&nbsp; comm</p>\r\n<p>FROM Nameorders a, Salespeople b</p>\r\n<p>WHERE a.sname = \'Axelrod\'</p>\r\n<p>AND b.snum = a.snum;</p>\r\n<p>Вывод для этого запроса показывается в рис.10.4.</p>\r\n<p>В предикате, мы могли бы написать - \" WHERE a.sname = \'Axelrod\' AND b.sname = \'Axelrod\' \" , но предикат который мы использовали здесь более общеупотребительный. Кроме того, поле snum - это первичный ключ таблицы Продавцов, и, следовательно, должен по определению быть уникальным.</p>\r\n<p>&nbsp;</p>\r\n<p>===============&nbsp; SQL Execution Log ==============</p>\r\n<p>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| SELECT a.sname, cname, amt * comm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| FROM&nbsp; Nameorders a, Salespeople b&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</p>\r\n<p>| WHERE a.sname = \'Axelrod\'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| AND b.snum = a.snum;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>| =============================================== |</p>\r\n<p>|&nbsp;&nbsp; onum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snum&nbsp;&nbsp; sname&nbsp;&nbsp;&nbsp;&nbsp; cname&nbsp;&nbsp; |</p>\r\n<p>|&nbsp; ------&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; -----&nbsp; -------&nbsp;&nbsp; -------&nbsp; |</p>\r\n<p>|&nbsp;&nbsp; 3001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18.69&nbsp;&nbsp;&nbsp;&nbsp; 1007&nbsp; Rifkin&nbsp;&nbsp;&nbsp; Cisneros |</p>\r\n<p>|&nbsp;&nbsp; 3006&nbsp;&nbsp;&nbsp;&nbsp; 1098.16&nbsp;&nbsp;&nbsp;&nbsp; 1007&nbsp; Rifkin&nbsp;&nbsp;&nbsp; Cisneros |</p>\r\n<p>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>\r\n<p>================================================</p>\r\n<p>Рис. 10.4 Объединениеосновнойтаблицыспредставлением</p>\r\n<p>Если бы там, например было два Axelrodf, вариант с именем, будет объединять вместе их данные. Более предпочтительный вариант - использовать поле snum чтобы хранить его отдельно.</p>\r\n<p><strong>Представления и подзапросы.</strong></p>\r\n<p>Представления могут также использовать и подзапросы, включая соотнесенные подзапросы. Предположим ваша компания предусматривает премию для тех продавцов которые имеют заказчика с самым высоким порядком для любой указанной даты. Вы можете проследить эту информацию с помощью представления:</p>\r\n<p>CREATE VIEW Elitesalesforce</p>\r\n<p>AS SELECT b.odate, a.snum, a.sname,</p>\r\n<p>FROM Salespeople a, Orders b</p>\r\n<p>WHERE a.snum = b.snum</p>\r\n<p>AND b.amt =</p>\r\n<p>(SELECT MAX (amt)</p>\r\n<p>FROM Orders c</p>\r\n<p>WHERE c.odate = b.odate);</p>\r\n<p>Если, с другой стороны, премия будет назначаться только продавцу, который имел самый высокий порядок за последние десять лет, вам необходимо будет проследить их в другом представлении основанном на первом:</p>\r\n<p>CREATE VIEW Bonus</p>\r\n<p>AS SELECT DISTINCT snum, sname</p>\r\n<p>FROM Elitesalesforce a</p>\r\n<p>WHERE 10 &lt; =</p>\r\n<p>(SELECT COUNT (*)</p>\r\n<p>FROM Elitesalestorce b</p>\r\n<p>WHERE a.snum = b.snum);</p>\r\n<p>Извлечение из этой таблицы продавца, который будет получать премию - выполняется простым вопросом:</p>\r\n<p>SELECT *</p>\r\n<p>FROM Bonus;</p>\r\n<p>Теперь мы видим истинную мощность SQL. Извлечение той же полученной информации программами RPG или COBOL будет более длительной процедурой. В SQL, это - только вопрос из двух комплексных команд, сохраненных, как представление совместно с простым запросом. При самостоятельном запросе - мы должны заботится об этом каждый день, потому что информация, которую извлекает запрос, непрерывно меняется чтобы отражать текущее состояние базы данных.</p>\r\n<p><strong>Что не могут делать представления.</strong></p>\r\n<p>Имеются большое количество типов представлений (включая многие из наших примеров в этой главе) которые являются доступными только для чтения. Это означает, что их можно запрашивать, но они не могут подвергаться действиям команд модификации. Имеются также некоторые виды запросов, которые не допустимы в определениях представлений. Одиночное представление должно основываться на одиночном запросе; ОБЪЕДИНЕНИЕ (UNION) и ОБЪЕДИНЕНИЕ ВСЕГО (UNIOM ALL) не разрешаются. УПОРЯДОЧЕНИЕ ПО (ORDER BY) никогда не используется в определении представлений. Вывод запроса формирует содержание представления, которое напоминает базовую таблицу и является - по определению - неупорядоченным.</p>\r\n<p><strong>Удаление представлений.</strong></p>\r\n<p>Синтаксис удаления представления из базы данных подобен синтаксису удаления базовых таблиц:</p>\r\n<p>DROP VIEW &lt; view name &gt;</p>\r\n<p>В этом нет необходимости, однако, сначала надо удалить все содержание как это делается с базовой таблицей, потому что содержание представления не является созданным и сохраняется в течении определенной команды. Базовая таблица, из которой представление выводится, не эффективна, когда представление удалено. Помните, вы должны являться владельцем представления чтобы иметь возможность удалить его.</p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Что такое язык определения данных?</li>\r\n<li>Какие объекты можно создавать с помощью языка определения данных?</li>\r\n<li>Как производить модификацию таблиц с помощью DDL?</li>\r\n<li>Что такое представление?</li>\r\n<li>Как формируется представление?</li>\r\n<li>Можно ли обновлять данные представления и почему?</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'Создание базы данных.\r\nСоздание и модификация таблиц базы данных.\r\nСоздание представлений и последовательностей.',0),(11,'2016-09-14 06:43:21','Лекция 11. Управление транзакциями.',11,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>Цель управления согласованностью.</li>\r\n<li>Назначение транзакций.</li>\r\n<li>Свойства транзакций.</li>\r\n<li>Блокировка и журналирование транзакций.</li>\r\n<li>Декомпозиция запросов.</li>\r\n<li>Оценка времени выполнения для операций реляционной алгебры.</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Ключевые слова: согласованнойсть данных, атомарность, согласованность, изоляция, долговечность, блокировка</strong></p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong><em>Согласованность данных (иногда консистентность данных, англ. data consistency)</em></strong> &mdash; согласованность данных друг с другом, целостность данных, а также внутренняя непротиворечивость.</p>\r\n<p>Задача аналитика и проектировщика базы данных &mdash; возможно более полно выявить все имеющиеся ограничения целостности и задать их в базе данных.</p>\r\n<p>Целостность БД не гарантирует достоверности содержащейся в ней информации, но обеспечивает по крайней мере правдоподобность этой информации, отвергая заведомо невероятные, невозможные значения. Таким образом, не следует путать целостность БД с достоверностью БД. Достоверность (или истинность) есть соответствие фактов, хранящихся в базе данных, реальному миру. Очевидно, что для определения достоверности БД требуется обладание полными знаниями как о содержимом БД, так и о реальном мире. Для определения целостности БД требуется лишь обладание знаниями о содержимом БД и о заданных для неё правилах. Поэтому СУБД может (и должна) контролировать целостность БД, но принципиально не в состоянии контролировать достоверность БД. Контроль достоверности БД может быть возложен только на человека, да и то в ограниченных масштабах, поскольку в ряде случаев люди тоже не обладают полнотой знаний о реальном мире.</p>\r\n<p>Итак, БД может быть целостной, но не достоверной. Возможно и обратное: БД может быть достоверной, но не целостной. Последнее имеет место, если правила (ограничения целостности) заданы неверно.</p>\r\n<p><a name=\"_Toc45513426\"></a><a name=\"_Toc45513328\"></a><a name=\"_Toc44257125\"></a><strong><em>Транзакция</em></strong> &ndash; это логическая единица работы. Например. Предположим сначала, что отношение Students (отношение студентов) включает дополнительный атрибут AvgMark, представляющий собой средний балл студента, по результатам сдачи текущей сессии. Значение AvgMark для любой определенной детали предполагается равным среднему арифметическому всех значений Mark из таблицы Marks для всех оценок полученных в текущем семестре.</p>\r\n<p>В приведенном примере предполагается, что речь идет об одиночной, атомарной операции. На самом деле добавление новой оценки в таблицу Marks &ndash; это выполнение двух обновлений в базе данных (под обновлениями здесь, конечно, понимаются операции insert, delete, а также сами по себе операции update). Более того, в базе данных между этими двумя обновлениями временно нарушается требование, что значение AvgMark для студента 1 равно среднему арифметическому всех значений поля Mark для студента 1 в текущем семестре. Таким образом, логическая единица работы (т.е. транзакция) &ndash; не просто одиночная операция системы баз данных, а скорее согласование нескольких таких операций. В общем, это преобразование одного согласованного состояния базы данных в другое, причем в промежуточных точках база данных находится в несогласованном состоянии.</p>\r\n<p>Из этого следует, что недопустимо, чтобы одно из обновлений было выполнено, а другое нет, так как база данных останется в несогласованном состоянии. В идеальном случае должны быть выполнены оба обновления. Однако нельзя обеспечить стопроцентную гарантию, что так и будет. Не исключена вероятность того, что, система, например, будет разрушена между двумя обновлениями, или же на втором обновлении произойдет арифметическое переполнение и т.п. Система, поддерживающая транзакции,&nbsp; гарантирует, что если во время выполнения неких обновлений произошла ошибка (по любой причине), то все эти обновления будут аннулированы. Таким образом, транзакция или выполняется полностью, или полностью отменяется (как будто она вообще не выполнялась).</p>\r\n<p>Системный компонент, обеспечивающий атомарность (или ее подобие), называется администратором транзакций (или диспетчером транзакций), а ключами к его выполнению служат операторы COMMIT TRANSACTION и ROLLBACK TRANSACTION.</p>\r\n<p>Оператор COMMIT TRANSACTION (для краткости commit) сигнализирует об успешном окончании транзакции. Он сообщает администратору транзакций, что логическая единица работы завершена успешно, база данных вновь находится (или будет находиться) в согласованном состоянии, а все обновления, выполненные логической единицей работы, теперь могут быть зафиксированы, т.е. стать постоянными.</p>\r\n<p>Оператор ROLLBACK TRANSACTION (для краткости ROLLBACK) сигнализирует о неудачном окончании транзакции. Он сообщает администратору транзакций, что произошла какая-то ошибка, база данных находится в несогласованном состоянии и все обновления могут быть отменены, т.е. аннулированы.</p>\r\n<p>Для отмены обновлений система поддерживает файл регистрации, или журнал, на диске, где записываются детали всех операций обновления, в частности новое и старое значения модифицированного объекта. Таким образом, при необходимости отмены некоторого обновления система может использовать соответствующий файл регистрации для возвращения объекта в первоначальное состояние.</p>\r\n<p>Еще один важный момент. Система должна гарантировать, что индивидуальные операторы сами по себе атомарные (т.е. выполняются полностью или не выполняются совсем). Это особенно важно для реляционных систем, в которых операторы многоуровневые и обычно оперируют множеством кортежей одновременно; такой оператор просто не может быть нарушен посреди операции и привести систему в несогласованное состояние. Другими словами, если произошла ошибка во время работы такого оператора, база данных должна остаться полностью неизмененной. Более того, это должно быть справедливо даже в том случае, когда действия оператора являются причиной дополнительной, например каскадной, операции.</p>\r\n<p><strong>Свойства АСИД.</strong></p>\r\n<p>Из предыдущих разделов следует, что транзакции обладают четырьмя важными свойствами: атомарность, согласованность, изоляция и долговечность (назовем это свойствами АСИД).</p>\r\n<ol>\r\n<li><strong><em>Атомарность.</em></strong> Транзакции атомарны (выполняется все или ничего).</li>\r\n<li><strong><em>Согласованность.</em></strong> Транзакции защищают базу данных согласованно. Это означает, что транзакции переводят одно согласованное состояние базы данных в другое без обязательной поддержки согласованности во всех промежуточных точках.</li>\r\n<li><strong><em>Изоляция.</em></strong> Транзакции отделены одна от другой. Это означает, что, если даже будет запущено множество конкурирующих друг с другом транзакций, любое обновление определенной транзакции будет скрыто от остальных до тех пор, пока эта транзакция выполняется. Другими словами, для любых двух отдаленных транзакций Т1 и Т2 справедливо следующее утверждение: Т1 сможет увидеть обновление Т2 только после выполнения Т2, а Т2 сможет увидеть обновление Т1 только после выполнения Т1.</li>\r\n<li><strong><em>Долговечность.</em></strong> Когда транзакция выполнена, ее обновления сохраняются, даже если в следующий момент произойдет сбой системы.</li>\r\n</ol>\r\n<p><strong>Восстановление транзакции.</strong></p>\r\n<p>Транзакция начинается с успешного выполнения оператора BEGIN&nbsp;TRANSACTION) и заканчивается успешным выполнением либо оператора COMMIT, либо ROLLBACK. Оператор COMMIT устанавливает так называемую точку фиксации (которая в коммерческих продуктах также называется точкой синхронизации (syncpoint). Точка фиксации соответствует концу логической единицы работы и, следовательно, точке, в которой база данных находится (или будет находиться) в состоянии согласованности. В противовес этому, выполнение оператора ROLLBACK вновь возвращает базу данных в состояние, в котором она была во время операции BEGIN&nbsp;TRANSACTION, т.е. в предыдущую точку фиксации.</p>\r\n<p>Случаи установки точки фиксации:</p>\r\n<ol>\r\n<li>Все обновления, совершенные программой с тех пор, как установлена предыдущая точка фиксации, выполнены, т.е. стали постоянными. Во время выполнения все такие обновления могут расцениваться только как пробные (в том смысле, что они могут быть не выполнены, например прокручены назад). Гарантируется, что однажды зафиксированное обновление так и останется зафиксированным (это и есть определение понятия \"зафиксировано\").</li>\r\n<li>Все позиционирование базы данных утеряно, и все блокировки кортежей реализованы. Позиционирование базы данных здесь означает, что в любое конкретное время программа обычно адресована определенным кортежам. Эта адресуемость в точке фиксации теряется.</li>\r\n</ol>\r\n<p>Следовательно, система может выполнить откат транзакции как явно &ndash; например по команде ПО с которым работает пользователь, так и неявно &ndash; для любой программы, которая по какой-либо причине не достигла запланированного завершения операций, входящих в транзакцию.</p>\r\n<p>Из этого видно, что транзакции &ndash; это не только логические единицы работы, но также и единицы восстановления при неудачном выполнении операций. При успешном завершении транзакции система гарантирует, что обновления постоянно установлены в базе данных, даже если система потерпит крах в следующий момент. Возможно, что в системе произойдет сбой после успешного выполнения COMMIT, но перед тем, как, обновления будут физически записаны в базу данных (они все еще могут оставаться в буфере оперативной памяти и таким образом могут быть утеряны в момент сбоя системы). Даже если подобное случилось, процедура перезагрузки системы все равно должна устанавливать эти обновления в базу данных, исследуя соответствующие записи в файле регистрации. Из этого следует, что файл регистрации должен быть физически записан перед завершением операции COMMIT. Это важное правило ведения файла регистрации известно как протокол предварительной записи в журнал (т.е. запись об операции осуществляется перед ее выполнением). Таким образом, процедура перезагрузки сможет восстановить любые успешно завершенные транзакции, хотя их обновления не были записаны физически до аварийного отказа системы. Следовательно, как указывалось ранее, транзакция действительно является единицей восстановления.</p>\r\n<p><strong>Параллелизм.</strong></p>\r\n<p>Термин параллелизм означает возможность одновременной обработки в СУБД многих транзакций с доступом к одним и тем же данным, причем в одно и то же время. В такой системе для корректной обработки параллельных транзакций без возникновения конфликтных ситуаций необходимо использовать некоторый метод управления параллелизмом.</p>\r\n<p>Каждый метод управления параллелизмом предназначен для решения некоторой конкретной задачи. Тем не менее, при обработке правильно составленных транзакций возникают ситуации, которые могут привести к получению неправильного результата из-за взаимных помех среди некоторых транзакций. (Обратите внимание, что вносящая помеху транзакция сама по себе может быть правильной. Неправильный конечный результат возникает по причине бесконтрольного чередования операций из двух правильных транзакций). Основные проблемы, возникающие при параллельной обработке транзакций следующие:</p>\r\n<ol>\r\n<li>проблема потери результатов обновления;</li>\r\n<li>проблема незафиксированной зависимости;</li>\r\n<li>проблема несовместимого анализа.</li>\r\n</ol>\r\n<p><strong>Проблема потери результатов обновления.</strong></p>\r\n<p>Рассмотрим ситуацию, показанную на рис 11.1. В такой интерпретации: транзакция A извлекает некоторый кортеж p в момент времени t1; транзакция B извлекает некоторый кортеж p в момент времени t2; транзакция A обновляет некоторый кортеж p (на основе значений, полученных в момент времени t1) в момент времени t3; транзакция B обновляет тот же кортеж р (на основе значений, полученных в момент времени t2, которые имеют те же значения, что и в момент времени t1) в момент времени t4. Однако результат операции обновления, выполненной транзакцией A, будет утерян, поскольку в момент времени t4 она не будет учтена и потому будет \"отменена\" операцией обновления, выполненной транзакцией B.</p>\r\n<p>&nbsp;</p>\r\n<p>Рис 11.1. Потеря в момент времени t4 результатов обновления, выполненного транзакцией A.</p>\r\n<p><strong>Проблема незафиксированной зависимости.</strong></p>\r\n<p>Проблема незафиксированной зависимости появляется, если с помощью некоторой транзакции осуществляется извлечение (или, что еще хуже, обновление) некоторого кортежа, который в данный момент обновляется другой транзакцией, но это обновление еще не закончено. Таким образом, если обновление не завершено, существует некоторая вероятность того, что оно не будет завершено никогда. (Более того, в подобном случае может быть выполнен возврат к предыдущему состоянию кортежа с отменой выполнения транзакции.) B таком случае, в первой транзакции будут принимать участие данные, которых больше не существует. Эта ситуация показана на рис. 11.2, рис.11. 3.</p>\r\n<p>В первом примере (рис. 11.3) транзакция A в момент времени t2 встречается с невыполненным обновлением (оно также называется невыполненным изменением). Затем это обновление отменяется в момент времени t3. Таким образом, транзакция A выполняется на основе фальшивого предположения, что кортеж р имеет некоторое значение в момент времени t2, тогда как на самом деле он имеет некоторое значение, существовавшее еще в момент времени t1. В итоге после выполнения транзакции A будет получен неверный результат. Кроме того, обратите внимание, что отмена выполнения транзакции B может произойти не по вине транзакции B, а, например, в результате краха системы. (К этому времени выполнение транзакции A может быть уже завершено, а потому крушение системы не приведет к отмене выполнения транзакции A.)</p>\r\n<p>Риc. 11.2. Транзакция A становится зависимой от невыполненного изменения в момент времени t2.</p>\r\n<p>Второй пример, приведенный на рис. 11/3, иллюстрирует другой случай. Не только транзакция A становится зависимой от изменения, не выполненного в момент времени t2, но также в момент времени t3 фактически утрачивается результат обновления, поскольку отмена выполнения транзакции B в момент времени t3 приводит к восстановлению кортежа р к исходному значению в момент времени t1. Это еще один вариант проблемы потери результатов обновления.</p>\r\n<p>Рис. 11.3. Транзакция A обновляет невыполненное изменение в момент времени t2, и результаты этого обновления утрачиваются в момент времени t3.</p>\r\n<p><strong>Проблема несовместимого анализа.</strong></p>\r\n<p>На рис. 11.4 показаны транзакции A и B, которые выполняются для кортежей со счетами (табл. 11.1). При этом транзакция A суммирует балансы, транзакция B производит перевод суммы 10 со счета 3 на счет 1. Полученный в итоге транзакции A результат 110, очевидно, неверен, и если он будет записан в базе данных, то в ней может возникнуть проблема несовместимости. В таком случае говорят, что транзакция A встретилась с несовместимым состоянием и на его основе был выполнен несовместимый анализ. Обратите внимание на следующее различие между этим примером и предыдущим: здесь не идет речь о зависимости транзакции A от транзакции B, так как транзакция B выполнила все обновления до того, как транзакция A извлекла СЧЕТ 3.</p>\r\n<table width=\"633\">\r\n<tbody>\r\n<tr>\r\n<td width=\"158\">\r\n<p>Счет</p>\r\n</td>\r\n<td width=\"158\">\r\n<p>СЧЕТ 1</p>\r\n</td>\r\n<td width=\"158\">\r\n<p>СЧЕТ 2</p>\r\n</td>\r\n<td width=\"158\">\r\n<p>СЧЕТ 3</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"158\">\r\n<p>Остаток</p>\r\n</td>\r\n<td width=\"158\">\r\n<p>40</p>\r\n</td>\r\n<td width=\"158\">\r\n<p>50</p>\r\n</td>\r\n<td width=\"158\">\r\n<p>30</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>Таблица 11.1. Остатки на счетах до выполнения транзакций.</p>\r\n<p>Рис. 11.4. Транзакция A выполнила несовместимый анализ.</p>\r\n<p><a name=\"_Toc45513427\"></a><a name=\"_Toc45513329\"></a><a name=\"_Toc44257126\"></a><strong>Понятие блокировки</strong><strong>.</strong></p>\r\n<p>Описанные выше проблемы могут быть разрешены с помощью методики управления параллельным выполнением процессов под названием блокировка. Ее основная идея очень проста: в случае, когда для выполнения некоторой транзакции необходимо, чтобы некоторый объект (обычно это кортеж базы данных) не изменялся непредсказуемо и без ведома этой транзакции (как это обычно бывает), такой объект блокируется. Таким образом, эффект блокировки состоит в том, чтобы \"заблокировать доступ к этому объекту со стороны других транзакций\", а значит, предотвратить непредсказуемое изменение этого объекта. Следовательно, первая транзакция в состоянии выполнить всю необходимую обработку с учетом того, что обрабатываемый объект остается в стабильном состоянии настолько долго, насколько это нужно.</p>\r\n<ol>\r\n<li>Предположим, что в системе поддерживается два типа блокировок: блокировка без взаимного доступа (монопольная блокировка), называемая Х-блокировкой (X locks &ndash; exclusive locks), и блокировка с взаимным доступом, называемая S-блокировкой (S locks - Shared locks).</li>\r\n</ol>\r\n<p>Замечание. Х- и S-блокировки иногда называют блокировками записи и чтения соответственно. Предположим, что Х- и S-блокировки единственно возможные, хотя в коммерческих системах существуют блокировки других типов. Кроме того, допустим, что в кортежи являются единственным типом \"блокируемого объекта\", хотя опять же н в коммерческих системах могут блокироваться и другие объекты. Ниже показано функционирование механизма блокировок.</p>\r\n<ol start=\"2\">\r\n<li>Если транзакция A блокирует кортеж р без возможности взаимного доступа (Х‑блокировка), то запрос другой транзакции B с блокировкой этого кортежа p будет отменен.</li>\r\n<li>Если транзакция A блокирует кортеж р с возможностью взаимного доступа (S‑блокировка), то:\r\n<ol>\r\n<li>запрос со стороны некоторой транзакции B на Х‑блокировку кортежа будет отвергнут;</li>\r\n<li>запрос со стороны некоторой транзакции B на S‑блокировку кортежа р будет принят (т.е. транзакция B также будет блокировать кортеж р с помощью S‑блокировки).</li>\r\n</ol>\r\n</li>\r\n</ol>\r\n<p>Эти правила можно наглядно представить в виде матрицы совместимости, показанной на рис. 11.5, и интерпретировать ее следующим образом. Рассмотрим некоторый кортеж р и предположим, что транзакция A блокирую кортеж р различными типами блокировки (это обозначено соответствующими символами S и X, а отсутствие блокировки &mdash; прочерком). Предположим также, что некоторая транзакция B запрашивает блокировку кортежа р, что обозначено в первом слева столбце матрицы на рис 5 (для полноты картины в таблице также приведен случай \"отсутствия блокировки\"). В других ячейках матрицы символ N обозначает конфликтную ситуацию (запрос со стороны транзакции B не может быть удовлетворен, и сама эта транзакция переходит в состояние ожидания), a Y &ndash; полную совместимость (запрос со стороны транзакции B удовлетворен). Очевидно, что эта матрица является симметричной.</p>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td width=\"31\">\r\n<p>&nbsp;</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>X</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>S</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>&ndash;</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"31\">\r\n<p>X</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>N</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>N</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>Y</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"31\">\r\n<p>S</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>N</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>Y</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>Y</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td width=\"31\">\r\n<p>&ndash;</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>Y</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>Y</p>\r\n</td>\r\n<td width=\"31\">\r\n<p>Y</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>Рис. 11.5. Матрица совместимости для Х- и S-блокировки.</p>\r\n<p>Введем протокол доступа к данным, который на основе введения только что описанных Х- и S-блокировки позволяет избежать возникновения проблем параллелизма.</p>\r\n<ol>\r\n<li>Транзакция, предназначенная для извлечения кортежа, прежде всего должна наложить S‑блокировку на этот кортеж.</li>\r\n<li>Транзакция, предназначенная для обновления кортежа, прежде всего должна наложить Х&ndash;блокировку на этот кортеж. Иначе говоря, если, например, для последовательности действий типа извлечение/обновление для кортежа уже задана S-блокировка, то ее необходимо заменить Х‑блокировкой.</li>\r\n</ol>\r\n<p>Замечение: Блокировки в транзакциях обычно задаются неявным образом: например, запрос на \"извлечение кортежа\" является неявным запросом с S-блокировкой, а запрос на \"обновление кортежа\" &ndash; неявным запросом с Х‑блокировкой соответствующего кортежа. При этом под термином \"обновление\" (как и ранее) подразумеваются помимо самих операций обновления также операции вставки и удаления.</p>\r\n<ol>\r\n<li>Если запрашиваемая блокировка со стороны транзакции B отвергается из-за конфликта с некоторой другой блокировкой со стороны транзакции A, то транзакция B переходит в состояние ожидания. Причем транзакция B будет находиться в состоянии ожидания до тех пор, пока не будет снята блокировка, заданная транзакцией A. В системе обязательно должны быть предусмотрены способы устранения бесконечно долгого состояния ожидания транзакции B.</li>\r\n<li>Х&ndash;блокировки сохраняются вплоть до конца выполнения транзакции (до операции \"завершение выполнения\" или \"отмена выполнения\"). S‑блокировки также обычно сохраняются вплоть до этого момента.</li>\r\n</ol>\r\n<p><a name=\"_Toc45513428\"></a><a name=\"_Toc45513330\"></a><a name=\"_Toc44257127\"></a><strong>Решение проблем параллелизма</strong><strong>.</strong></p>\r\n<p>Рассмотрим решение проблем параллелизма с помощью механизма блокировок.</p>\r\n<p><strong>Проблема потери результатов обновления.</strong></p>\r\n<p>На рис. 11.6 приведена измененная версия процесса, показанного на рис. 11.1, с учетом применения протокола блокировки для чередующихся операций. Операция обновления для транзакции A в момент времени t3 не будет выполнена, поскольку она является неявным запросом с заданием Х-блокировки для кортежа р, а этот запрос вступает в конфликт с S-блокировкой, уже заданной транзакцией B. Таким образом, транзакция A переходит в состояние ожидания. По аналогичным причинам транзакция B переходит в состояние ожидания в момент времени t4.Обновления теперь не утрачиваются, однако возникает новая проблема &ndash; бесконечное ожидание или тупиковая ситуация. Способы решения этой проблемы рассматриваются ниже.</p>\r\n<p>Рис. 11.6. Хотя обновления не утрачиваются, но в момент времени t4 возникает тупиковая ситуация.</p>\r\n<p><strong>Проблема незафиксированной зависимости.</strong></p>\r\n<p>На рис. 11.7, рис. 11.8 приведены в измененном виде примеры, показанные ранее на рис. 2 и рис. 3 соответственно. Они демонстрируют чередующееся выполнение операций согласно описанному выше протоколу блокировки. Операция для транзакции A в момент времени t2 (извлечение на рис. 11.7 и обновление на рис. 11.8) не будет выполнена. Дело в том, что она является неявным запросом с заданием блокировки для кортежа р, а этот запрос вступает в конфликт с Х-блокировкой, уже заданной транзакцией B. Таким образом, транзакция A переходит в состояние ожидания до тех пор, пока не будет прекращено выполнение транзакции B (до операции окончания или отмены выполнения транзакции B). Тогда заданная транзакцией B блокировка будет снята и транзакция A может быть выполнена. Причем транзакция A будет иметь дело с некоторым фиксированным значением (либо существовавшим до выполнения транзакции B при отмене ее выполнения, либо полученным после выполнения транзакции B). В любом случае транзакция A больше не зависит от незафиксированного обновления.</p>\r\n<p>Рис. 11.7. Транзакция A предохраняется от выполнения операций с незафиксированным изменением в момент времени t2.</p>\r\n<p>Рис. 11.8. Транзакция A предохраняется от выполнения операций с незафиксированным изменением в момент времени t2.</p>\r\n<p><strong>Проблема несовместимого анализа.</strong></p>\r\n<p>На рис. 11.9 приведена измененная версия отношения (рис. 11.4) с перечислением чередующихся транзакций согласно протоколу блокировки. Операция обновления для транзакции B в момент времени t6 не будет выполнена. Дело в том, что она является неявным запросом с заданием Х-блокировки для кортежа СЧЕТ 1, а этот запрос вступает в конфликт с S-блокировкой, уже заданной транзакцией A. Таким образом, транзакция B переходит в состояние ожидания. Точно так же операция извлечения для транзакции A в момент времени t7 не будет выполнена. Дело в том, что она является неявным запросом с заданием S-блокировки для кортежа СЧЕТ 3, а этот запрос вступает в конфликт с Х‑блокировкой, уже заданной транзакцией B. Таким образом, транзакция A переходит в состояние ожидания. Следовательно, блокировка хотя и помогает решить одну проблему (а именно проблему несовместимого анализа), но приводит к необходимости решения другой проблемы (а именно проблемы возникновения тупиковой ситуации).</p>\r\n<p>Рис. 11.9.&nbsp; Проблема несовместимого анализа разрешается, но в момент времени t7 возникает тупиковая ситуация.<a name=\"_Toc45513429\"></a><a name=\"_Toc45513331\"></a><a name=\"_Toc44257128\"></a></p>\r\n<p><strong>Тупиковые ситуации</strong><strong>.</strong></p>\r\n<p>Как было показано выше, блокировку можно использовать для разрешения трех основных проблем, возникающих при параллельной обработке кортежей. К сожалению, использование блокировок приводит к возникновению другой проблемы &ndash; тупиковой ситуации. На рис. 11.10 показан обобщенный пример этой проблемы, в котором p1 и p2 представляют любые блокируемые объекты, необязательно кортежи базы данных, а выражения типа \"блокировка ... без взаимного доступа\" представляют любые операции с наложением блокировки без взаимного доступа, заданные как явно, так и неявно.</p>\r\n<p>Рис. 11.10. Пример тупиковой ситуации.</p>\r\n<p>Тупиковая ситуация возникает тогда, когда две или более транзакции одновременно находятся в состоянии ожидания, причем для продолжения работы каждая из транзакций ожидает прекращения выполнения другой транзакции.</p>\r\n<p>Для обнаружения тупиковой ситуации следует обнаружить цикл в диаграмме состояний ожидания, т.е. в перечне \"транзакций, которые ожидают окончания выполнения других транзакций\" Поиск выхода из тупиковой ситуации состоит в выборе одной из заблокированных транзакций в качестве жертвы и отмене ее выполнения. Таким образом, с нее снимается блокировка, а выполнение другой транзакции может быть возобновлено.</p>\r\n<p>На практике не все системы в состоянии обнаружить тупиковую ситуацию. Например, в некоторых из них используется хронометраж выполнения транзакций, и сообщение о возникновении тупиковой ситуации поступает, если транзакция не выполняется за некоторое предписанное заранее время.</p>\r\n<p>Следует обратить внимание на то, что транзакция-жертва признается \"некорректной\" и отменяется \"не из-за собственной некорректности\". В некоторых системах предусмотрен автоматический перезапуск транзакции с самого начала при условии, что обстоятельства, которые привели к тупиковой ситуации, не повторятся вновь. A в других системах в программу, связанную с данной транзакцией, просто посылается сообщение о \"вызвавшей тупиковую ситуацию транзакции-жертве\" для обработки этой ситуации в самой программе С точки зрения программирования приложений предпочтительнее первый из этих подходов. Но несмотря на это, всегда рекомендуется решать данную проблему с точки зрения пользователя.</p>\r\n<p><a name=\"_Toc45513430\"></a><a name=\"_Toc45513332\"></a><a name=\"_Toc44257129\"></a><strong>Способность к упорядочению</strong><strong>.</strong></p>\r\n<p>Чередующееся выполнение заданного множества транзакций будет верным, если оно упорядочено, т.е. при его выполнении будет получен такой же результат, как и при последовательное выполнении тех же транзакций. Обосновать это утверждение помогут следующие замечания:</p>\r\n<ol>\r\n<li>Отдельные транзакции считаются верными, если при их выполнении база данных переходит из одного непротиворечивого состояния в другое непротиворечивое состояние.</li>\r\n<li>Выполнение транзакций одна за другой в любом последовательном порядке также является верным. При этом под выражением \"любой последовательный порядок\" подразумевается, что используются независимые друг от друга транзакции.</li>\r\n<li>Чередующееся выполнение транзакций, следовательно, является верным, если оно эквивалентно некоторому последовательному выполнению, т.е. если оно подлежит упорядочению.</li>\r\n</ol>\r\n<p>Возвращаясь к приведенным выше примерам (рис. 11.1 &ndash; рис. 11.4), можно отметить, что проблема в каждом случае заключалась в том, что чередующееся выполнение транзакций не было упорядочено, т.е. не было эквивалентно выполнению либо сначала транзакции A, а затем транзакции B, либо сначала транзакции B, а затем транзакции A.</p>\r\n<p>Для заданного набора транзакций любой порядок их выполнения (чередующийся или какой-либо другой) называется графиком запуска. Выполнение транзакций по одной без их чередования называется последовательным графиком запуска, а непоследовательное выполнение транзакций &ndash; чередующимся графиком запуска или непоследовательным графиком запуска. Два графика называются эквивалентными, если при их выполнении будет получен одинаковый результат, независимо от исходного состояния базы данных. Таким образом, график запуска является верным (т.е. допускающим возможность упорядочения), если он эквивалентен некоторому последовательному графику запуска.</p>\r\n<p>При выполнении двух различных последовательных графиков запуска, содержащих одинаковый набор транзакций, можно получить совершенно различные результаты. Поэтому выполнение двух различных чередующихся графиков запуска с одинаковыми транзакциями может также привести к различным результатам, которые могут быть восприняты как верные.</p>\r\n<p>Теорема двухфазной блокировки (не имеет отношения к протоколу двухфазной фиксации), которая может быть сформулирована следующим образом:</p>\r\n<p>Если все транзакции подчиняются \"протоколу двухфазной блокировки\", то для всех возможных чередующихся графиков запуска существует возможность упорядочения.</p>\r\n<p>При этом протокол двухфазной блокировки, в свою очередь, формулируется следующим образом.</p>\r\n<ol>\r\n<li>Перед выполнением каких-либо операций с некоторым объектом (например, с кортежем базы данных) транзакция должна заблокировать этот кортеж.</li>\r\n<li>После снятия блокировки транзакция не должна накладывать никаких других блокировок.</li>\r\n</ol>\r\n<p>Таким образом, транзакция, которая подчиняется этому протоколу, характеризуется двумя фазами: фазой наложения блокировки и фазой снятия блокировки.</p>\r\n<p>Характеристика упорядочения может быть выражена следующим образом. Если A и B являются любыми двумя транзакциями некоторого графика запуска, допускающего возможность упорядочения, то либо A логически предшествует B, либо B логически предшествует A, т.е. либо B использует результаты выполнения транзакции A, либо A использует результаты выполнения транзакции B. (Если транзакция A приводит к обновлению кортежей р, q, ... r и транзакция B использует эти кортежи в качестве входных данных, то используются либо все обновленные с помощью A кортежи, либо полностью не обновленные кортежи до выполнения транзакции A, но никак не их смесь.) Наоборот, график запуска является неверным и не подлежит упорядочению, если результат выполнения транзакций не соответствует либо сначала выполнению транзакции A, а затем транзакции B, либо сначала выполнению транзакции B, а затем транзакции A.</p>\r\n<p>В настоящее время с целью понижения требований к ресурсам и, следовательно, повышения производительности и пропускной способности в реальных системах обычно предусмотрено использование не двухфазных транзакций, а транзакций с \"ранним снятием блокировки\" (еще до выполнения операции прекращения транзакции) и наложением нескольких блокировок. Однако следует понимать, что использование таких транзакций сопряжено с большим риском. Действительно, при использовании недвухфазной транзакции A предполагается, что в данной системе не существует никакой другой чередующейся с ней транзакции B (в противном случае в системе возможно получение ошибочных результатов).</p>\r\n<p><a name=\"_Toc45513431\"></a><a name=\"_Toc45513333\"></a><a name=\"_Toc44257130\"></a><strong>Уровни изоляции транзакции</strong><strong>.</strong></p>\r\n<p>Термин уровень изоляции, грубо говоря, используется для описания степени вмешательства параллельных транзакций в работу некоторой заданной транзакции. Но при обеспечении возможности упорядочения не допускается никакого вмешательства, иначе говоря, уровень изоляции должен быть максимальным. Однако, как уже отмечалось, в реальных системах по различным причинам обычно допускаются транзакции, которые работают на уровне изоляции ниже максимального.</p>\r\n<p>Уровень изоляции обычно рассматривается как некоторое свойство транзакции. В реальных СУБД может быть реализовано различное количество уровней изоляции.</p>\r\n<p>Кроме того, помимо кортежей могут блокироваться другие единицы данных, например, целое отношение, база данных или (пример противоположного характера) некоторое значение атрибута внутри заданного кортежа.</p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Что такое транзакция?</li>\r\n<li>Перечислите основные свойства ACID.</li>\r\n<li>Как реализуется механизм синхронизации транзакций?</li>\r\n<li>Что такое S-блокировка?</li>\r\n<li>Что такое тупиковые ситуации?</li>\r\n<li>Как производится оценка времени выполнения запроса?</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'Цель управления согласованностью.\r\nНазначение транзакций.\r\nСвойства транзакций.\r\nБлокировка и журналирование транзакций.\r\nДекомпозиция запросов.\r\nОценка времени выполнения для операций реляционной алгебры.\r\n',0),(12,'2016-09-14 06:44:15','Лекция 12. Администрирование и безопасность',12,'Lecture','<h2>Лекция 12. Администрирование и безопасность базы данных.</h2>\r\n<p>&nbsp;</p>\r\n<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>Резервное копирование и восстановление.</li>\r\n<li>Документирование схемы базы данных.</li>\r\n<li>Создание и модификация пользователей и ролей.</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Ключевые слова: документирование, резервная копия, откат, накат, привелегии</strong></p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><a name=\"_Toc323551714\"></a><a name=\"_Toc323551717\"></a><strong>Восстановление базы данных</strong><strong>.</strong></p>\r\n<p>Компьютерные системы порою дают сбои. Причин тому множество: поломки аппаратного обеспечения, дефекты в программах, неточности в описаниях ручных процедур и ошибочные человеческие действия. Все перечисленные виды ошибок могут возникать и возникают в приложениях баз данных. Поскольку база данных совместно используется множеством людей и зачастую является ключевым элементом функционирования организации, важно как можно быстрее ее восстановить.</p>\r\n<p>Это ставит перед нами несколько задач. Во-первых, с точки зрения бизнеса, работа должна продолжаться. Например, выполнение заказов, осуществление финансовых транзакций и составление упаковочных листов должно быть организовано вручную. Позже, когда приложение базы данных вновь заработает, можно будет ввести новые данные. Во-вторых, персонал, ответственный за компьютерную систему, должен восстановить ее как можно быстрее и привести как можно ближе к тому состоянию, которое было до сбоя. В-третьих, пользователи должны знать, что требуется сделать, когда система вновь начнет функционировать. Возможно, придется повторно ввести какие-то данные, и пользователям нужно знать, насколько далеко им следует возвращаться назад.</p>\r\n<p>Когда происходит сбой, невозможно просто устранить проблему и продолжать обработку. Если даже при этом не были потеряны никакие данные (для чего необходимо, чтобы все виды памяти были энергонезависимыми, &ndash; совершенно нереалистичное предположение), то синхронизация и планирование обработки слишком сложны, чтобы состояние системы можно было воспроизвести в точности. Чтобы продолжить работу точно с того места, где она была прервана, операционной системе потребовалось бы громадное количество избыточных данных и времени на их обработку. Невозможно прокрутить время назад и вернуть все электроны в те же конфигурации, в которых они находились на момент возникновения ошибки. Возможны два подхода к восстановлению базы данных: повторная обработка и откат-накат.</p>\r\n<p><strong>Восстановление путем повторной обработки </strong></p>\r\n<p>Поскольку обработка не может быть возобновлена точно с того места, где она была прервана, следующая возможность &ndash; отойти назад до некоторой известной точки и возобновить обработку с нее. Простейший способ такого восстановления &ndash; это периодически делать копию базы данных (называемую снимком базы данных (database save)) и хранить записи обо всех транзакциях, которые были выполнены со времени последнего копирования. Затем при возникновении сбоя персонал может восстановить базу данных по ее снимку и заново произвести все транзакции.</p>\r\n<p>К сожалению, эта простая стратегия, как правило, нереализуема. Во-первых, повторное выполнение транзакций занимает столько же времени, сколько оно заняло до возникновения ошибки. Если компьютер имеет напряженный график работы, система может так никогда и не &laquo;догнать&raquo; свое исходное состояние. Во-вторых, при параллельной обработке транзакций события происходят асинхронно. Небольшие вариации в действиях человека &ndash; например, когда пользователь чуть медленнее вставляет дискету или читает сообщение электронной почты, прежде чем ответить на запрос приложения, &ndash; могут изменить порядок обработки параллельных транзакций. Поэтому может случиться, что хотя изначально последний билет на данный рейс достался клиенту А, при повторной обработке его получит клиент В. В связи с этим повторная обработка обычно не является реально осуществимой формой восстановления от сбоев в системах параллельной обработки.</p>\r\n<p><strong>Восстановление через откат-накат </strong></p>\r\n<p>Второй подход к восстановлению заключается в том, чтобы периодически делать копии (снимки) базы данных и вести журнал всех изменений, произведенных транзакциями в базе данных со времени последнего копирования. В этом случае, когда происходит сбой, можно использовать один из двух методов. При первом методе, который называется накатом (rollforward), база данных восстанавливается до сохраненного состояния, после чего выполняются все правильные транзакции. (Мы не обрабатываем транзакции повторно, поскольку прикладные программы не участвуют в процессе восстановления. Все, что мы делаем &ndash; это производим изменения в базе данных согласно записям в журнале.)</p>\r\n<p>Второй метод называется откатом (rollback). При этом методе мы отменяем изменения, произведенные в базе данных ошибочными или частично выполненными транзакциями. Затем повторно запускаются правильные транзакции, которые выполнялись в момент возникновения сбоя.</p>\r\n<p>Оба эти метода требуют ведения журнала (log) результатов транзакций. Этот журнал содержит записи изменений, произведенных с данными, в хронологическом порядке. Прежде чем транзакция будет выполнена, ее необходимо записать и журнал. Тогда, если крах системы произойдет в интервале между записью транзакции в журнал и выполнением ее, то в худшем случае у нас будет иметься запись о невыполненной транзакции. Если, напротив, транзакции сначала выполняются, а затем уже записываются в журнал, то возможен нежелательный вариант, когда изменения в базе данных произведены, но запись об этих изменениях отсутствует. В такой ситуации неискушенный пользователь может повторно ввести транзакцию, которая уже выполнена.</p>\r\n<p>В случае сбоя журнал используется как для отмены, так и для повторного выполнения транзакций (рис. 12.1). Чтобы была возможна отмена транзакций, журнал должен содержать копию каждой записи (или страницы) базы данных, сделанную перед ее изменением. Такие записи называются исходными образами (before-images). Отмена транзакции производится путем последовательной записи в базу данных исходных образов всех произведенных ею изменений. Чтобы было возможно повторное выполнение транзакций, журнал должен содержать копию каждой записи (или страницы) базы данных, сделанную после ее изменения. Такие записи называются конечными образами (after-images). Транзакция выполняется повторно путем последовательной записи в базу данных конечных образов всех произведенных ею изменений.</p>\r\n<p>Рис. 12.1. Откат и накат транзакций: а &ndash; отмена изменений в базе данных (откат); б &ndash; повторное выполнение изменений (накат).</p>\r\n<p>Если есть журнал с исходными и конечными образами, то отмена и повторное выполнение транзакций происходит элементарно (но мы все равно опишем этот процесс). Чтобы отменить транзакцию, программа восстановления просто заменяет каждую измененную запись ее исходным образом. Когда все исходные образы будут восстановлены, транзакция будет отменена. Чтобы повторно выполнить транзакцию, программа восстановления начинает с версии базы данных, существовавшей на момент начала данной транзакции, и записывает&nbsp; в базу все конечные образы. Как уже говорилось, это действие подразумевает, что имеется снимок базы данных с более ранней ее версией.</p>\r\n<p>Восстановление базы данных до ее последнего снимка и повторное выполнение всех транзакций может потребовать значительного времени. Чтобы уменьшить задержку, в СУБД иногда используются контрольные точки. <strong><em>Контрольная точка (checkpoint)</em></strong> &ndash; это точка синхронизации между базой данных и журналом транзакций. Для вставки контрольной точки СУБД отклоняет новые запросы, завершает обработку текущих запросов и сбрасывает свои буферы на диск. Затем СУБД ждет, пока операционная система не сообщит, что все текущие операции записи на диск и в журнал успешно выполнены. Теперь база данных и журнал синхронизированы. После этого в журнале делается запись о контрольной точке. Позже база данных может быть восстановлена с контрольной точки, при этом нужно будет записать конечные образы только тех транзакций, которые начались после контрольной точки.</p>\r\n<p>Вставка контрольной точки &ndash; недорогая операция, и можно выполнять три или четыре (а можно и больше) таких операции в час. Таким образом, для восстановления потребуется не более 15-20 минут работы. Большинство СУБД вставляют контрольные точки автоматически, делая человеческое вмешательство ненужным.</p>\r\n<p><strong>Управление структурой базы данных.</strong></p>\r\n<p>Управление структурой базы данных включает участие в первоначальном проектировании и реализации базы данных, а также руководство и контроль в процессе внесения в нее изменений. В идеальном случае отдел администрирования привлекается к работе на ранней стадии разработки базы данных и ее приложений и принимает участие в изучении требований, оценке альтернатив, включая то, какую СУБД предпочтительнее использовать, и разработке структуры базы данных. Для больших организационных приложений администратор базы данных &ndash; это обычно менеджер, который руководит работой технически ориентированного персонала по проектированию базы данных.</p>\r\n<p>Как говорилось ранее, при создании базы данных приходится решать несколько задач. Прежде всего, создается база данных и выделяется место на физическом носителе под саму базу и ее журналы. Затем создаются таблицы, индексы, хранимые процедуры и триггеры. Примеры этого вы увидите в следующих двух главах. Когда структуры базы данных сформированы, база заполняется информацией. В большинстве СУБД предусмотрены утилиты для записи больших объемов данных.</p>\r\n<p><strong>Конфигурирование.</strong></p>\r\n<p>После того как база данных и ее приложения будут реализованы, неизбежно будут меняться требования. Это может быть обусловлено новыми потребностями, изменениями в бизнес-окружении, сменой политики и т. д. Когда изменение требований вызывает необходимость изменения структуры базы данных, следует действовать с большой осторожностью, потому что структурные изменения редко затрагивают только одно приложение.</p>\r\n<p>Следовательно, эффективное администрирование базы данных должно включать в себя процедуры и политику, с помощью которых пользователи могли бы регистрировать свои потребности в изменениях, а все сообщество пользователей базы данных имело бы возможность обсуждать эффект от этих изменений, чтобы затем можно было принять глобальное решение о том, стоит ли их воплощать. Из-за больших размеров и сложности базы данных и ее приложений изменения иногда приводят к неожиданным результатам. Поэтому администратор базы&nbsp; данных должен быть готов к тому, что базу данных придется восстанавливать, и должен иметь достаточное количество информации для диагностики и устранения проблемы, вызвавшей сбой. База данных наиболее подвержена сбоям после внесения изменений в ее структуру.</p>\r\n<p><strong>Документирование.</strong></p>\r\n<p>В обязанности администратора по управлению структурой базы данных входит также ведение документации. Исключительно важно знать, какие модификации были произведены, когда и каким образом. Изменение в структуре базы данных может повлечь за собой ошибку, которая не будет проявляться в течение шести месяцев; при отсутствии должного документирования изменений диагностика такой проблемы становится почти невозможной. Могут потребоваться десятки повторных прогонов, чтобы выявить момент, когда начали появляться первые симптомы, и по этой причине важно также вести запись тестовых процедур и прогонов, сделанных для проверки произведенной модификации. Если используются стандартизированные тестовые процедуры, тестовые формы и методы ведения записей, запись тестовых результатов не должна занимать много времени.</p>\r\n<p>Хотя ведение документации &ndash; процесс утомительный и бесконечный, затраченные на него усилия окупаются, когда приходит беда и документация оказывается тем, без чего невозможно решить серьезную (и дорогостоящую) проблему. В настоящее время появляется много продуктов, облегчающих бремя ведения документации. Многие CASE-средства, например, можно использовать для документирования логической структуры базы данных. Для отслеживания изменений можно использовать программы контроля версий. Словари данпых обеспечивают составление отчетов и применение других средств для чтения и интерпретации структуры информации в базе данных.</p>\r\n<p>Другая причина для тщательного документирования изменений в структуре базы данных состоит в том, чтобы должным образом использовать исторические данные. Если, например, маркетологи захотят проанализировать данные о продажах трехлетней давности, находившиеся в архивах в течение двух лет, им необходимо будет знать, какова была структура базы данных перед тем, как данные были отправлены в архив. В ответе на этот вопрос могут помочь записи, отражающие изменения в структуре базы данных. Аналогичная ситуация возникает, когда для восстановления поврежденной базы данных приходится использовать резервную копию шестимесячной давности (хотя такого происходить не должно, иногда это случается). Резервную копию можно использовать для реконструкции базы данных до того состояния, в котором она находилась на момент снятия этой копии. Затем можно в хронологическом порядке выполнить транзакции к произвести структурные изменения, чтобы восстановить базу данных до ее текущего состояния. В списке приведен перечень обязанностей администратора по управлению структурой базы данных.</p>\r\n<p>Участие в разработке базы данных и приложений.</p>\r\n<ul>\r\n<li>Помощь на стадии определения требований и оценки альтернатив.</li>\r\n<li>Активная роль в проектировании и создании базы данных.</li>\r\n<li>Помощь в изменении структуры базы данных</li>\r\n<li>Поиск решений во взаимодействии с пользователями.</li>\r\n<li>Оценка того, как планируемое изменение отразится на каждом пользователе.</li>\r\n<li>Организация форума по вопросам конфигурирования.</li>\r\n<li>Готовность к устранению проблем, возникающих после внесения изменений.</li>\r\n<li>Ведение документации.</li>\r\n</ul>\r\n<p><a name=\"_Toc323551716\"></a><strong>Безопасность базы данных.</strong></p>\r\n<p>Защита безопасности базы данных заключается в том, что право выполнять некоторые действия дается только определенным пользователям и в определенное время. Эта цель труднодостижима, и чтобы хоть в какой-то степени к ней приблизиться, команда разработчиков базы данных должна на стадии определения требований к проекту установить для всех пользователей права и обязанности по обработке (processing rights and responsibilities). Реализация этих требований безопасности может обеспечиваться соответствующими возможностями СУБД, а при их недостаточности &ndash; логикой прикладных программ.</p>\r\n<p><strong>Права и обязанности по обработке.</strong></p>\r\n<p>В задачи администратора базы данных входит управление правами и обязанностями по обработке. Это подразумевает, что права и обязанности могут меняться с течением времени. В ходе работы с базой данных, по мере внесения изменений в приложения и в структуру СУБД возникает потребность во введении новых или изменении существующих прав и обязанностей. Администратор базы данных играет ведущую роль в обсуждении и реализации таких изменений.</p>\r\n<p>Когда права по обработке определены, необходимо их реализовать. Эта задача может быть возложена на различные элементы: операционную систему, сеть, web-сервер, СУБД или приложение. В последующих двух разделах мы рассмотрим реализацию прав по обработке средствами СУБД и приложения. Описание остальных возможностей выходит за рамки данной книги.</p>\r\n<p><strong>Обеспечение безопасности средствами СУБД.</strong></p>\r\n<p>Терминология, возможности и функции безопасности СУБД варьируются от продукта к продукту. В принципе, во всех СУБД существует возможность ограничить выполнение определенных действий определенным временем и кругом пользователей. Общая модель безопасности СУБД представлена на рис. 12.2</p>\r\n<p>Рис. 12.2. Модель безопасности СУБД.</p>\r\n<p>Пользователю может быть назначена одна или несколько ролей, а роль может принадлежать одному или многим пользователям. Как пользователи, так и роли могут иметь много различных полномочий. С каждым объектом (в широком смысле этого слова) связаны определенные полномочия. Каждое полномочие относится к одному пользователю или группе и одному объекту.</p>\r\n<p>Когда пользователь входит в систему базы данных, СУБД ограничивает его действия полномочиями, определенными индивидуально для данного пользователя, а также для роли, назначенной данному пользователю. Определить, является ли пользователь тем, за кого он себя выдает, &mdash; задача, вообще говоря, сложная. Во всех коммерческих СУБД используется тот или иной вариант парольной защиты, даже при том, что такой метод обеспечения безопасности можно легко обойти, если пользователи небрежно относятся к своим личным идентификаторам.</p>\r\n<p><strong>Язык управления данными (</strong><strong>DCL)</strong>&nbsp;используется для управления правами доступа к данным и выполнением процедур в многопользовательской среде. Более точно его можно назвать \"язык управления доступом\". Он состоит из двух основных команд:</p>\r\n<ul>\r\n<li><strong>GRANT </strong>&ndash; дать права;</li>\r\n<li><strong>REVOKE </strong>&ndash; забрать права.</li>\r\n</ul>\r\n<p>Как правило, пользователи самостоятельно вводят свое имя и пароль, а в некоторых приложениях имя пользователя и пароль вводятся системой от лица пользователя. Например, Windows 2000 может непосредственно передать имя пользователя и пароль для входа в систему СУБД SQL Server. В других случаях имя пользователя и пароль предоставляются прикладной программой.</p>\r\n<p>В интернет-приложениях обычно определяется группа под названием вроде &laquo;Unknown Public&raquo; (неизвестная публика), и в эту группу записываются анонимные пользователи, входящие в систему. Таким образом, компании типа Dell Computer избегают необходимости вводить каждого пользователя в систему под собственным именем и паролем.</p>\r\n<p>Модели систем безопасности, используемые во множестве СУБД, изображены на рис. 12.3. В соответствии с этой моделью, у каждого пользователя есть профиль, который указывает, какие системные ресурсы может задействовать данный пользователь. Пользователю может быть назначено много ролей, и одна и та же роль может быть назначена многим пользователям. Каждый пользователь или роль имеет множество привилегий. Есть два вида привилегий. Объектные привилегии определяют действия, которые могут быть предприняты по отношению к объектам базы данных &ndash; таблицам, представлениям и индексам. Системные привилегии определяют возможные действия с использованием команд.</p>\r\n<p>Рис. 12.3. Модель безопасности.</p>\r\n<p><strong>Обеспечение безопасности средствами&nbsp; приложения.</strong></p>\r\n<p>Хотя такие СУБД, как Oracle или SQL Server, предоставляют значительные возможности по обеспечению безопасности, эти возможности по своей натуре являются весьма общими. Если приложению требуются специфические меры безопасности, например &laquo;пользователь не может просматривать строки таблицы или соединения таблиц, имя сотрудника в которых отличается от его собственного&raquo;, то СУБД будет бессильна это сделать. В таких случаях система безопасности должна быть дополнена функциями, реализованными в самом приложении.</p>\r\n<p>Можно организовать хранение информации, относящейся к безопасности, в специализированной базе данных, доступ к которой могут осуществлять приложение или хранимые процедуры и триггеры.</p>\r\n<p>Есть много других способов расширения возможностей СУБД по обеспечению безопасности за счет приложения. Однако в первую очередь следует задействовать систему безопасности СУБД. Только если ее функций оказывается недостаточно, стоит дополнять их за счет прикладных программ. Чем ниже уровень, на котором идет обеспечение безопасности, тем меньше возможностей для несанкционированного вторжения. Кроме того, система безопасности СУБД работает быстрее, ее использование приводит к меньшим затратам и, возможно, дает лучшие результаты, чем разработка собственной системы.</p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Шифрование.</strong></p>\r\n<p><strong><em>Шифрование</em></strong> &ndash; преобразование данных с использованием специального алгоритма, в результате чего данные становятся недоступными для чтения любой программой, не имеющей ключа дешифрования,</p>\r\n<p>Если в системе с базой данных содержится весьма важная конфиденциальная информация, то имеет смысл зашифровать ее с целью предупреждения возможной угрозы несанкционированного доступа с внешней стороны (по отношению к СУБД). Некоторые СУБД включают средства шифрования, предназначенные для использования в подобных целях. Подпрограммы таких СУБД обеспечивают санкционированный доступ к данным (после их дешифрования), хотя это будет связано с некоторым снижением производительности, вызванным необходимостью двойного преобразования. Шифрование также может использоваться для защиты данных при их передаче по линиям связи. Существует множество различных технологий шифрования данных с целью сокрытия передаваемой информации, причем одни из них называют необратимыми, а другие &ndash; обратимыми. Необратимые методы, как и следует из их названия, не позволяют установить исходные данные, хотя последние могут использоваться для сбора достоверной статистической информации. Обратимые технологии используются чаще. Для организации защищенной передачи данных по незащищенным сетям должны использоваться системы шифрования, включающие следующие компоненты:</p>\r\n<ul>\r\n<li>ключ шифрования, предназначенный для шифрования исходных данных (обычного текста);</li>\r\n<li>алгоритм шифрования, который описывает, как с помощью ключа шифрвания преобразовать обычный текст в зашифрованный;</li>\r\n<li>ключ дешифрования, предназначенный для дешифрования зашифрованного текста;</li>\r\n<li>алгоритм дешифрования, который описывает, как с помощью ключа дешифрования преобразовать зашифрованный текст в обычный исходный.</li>\r\n</ul>\r\n<p>Некоторые системы шифрования, называемые симметричными, используют один и тот же ключ как для шифрования, так и для дешифрования, при этом предполагается наличие защищенных линий связи, предназначенных для обмена ключами. Однако большинство пользователей не имеют доступа к защищенным линиям связи, поэтому для получения надежной защиты длина ключа должна быть не меньше длины самого сообщения. Тем не менее, большинство эксплуатируемых систем построено на использовании ключей, которые короче самих сообщений.</p>\r\n<p>Другой тип систем шифрования предусматривает использование различных ключей для шифровки и дешифровки сообщений &ndash; подобные системы принято называть асимметричными. Примером такой системы является система с открытым ключом, предусматривающая использование двух ключей, один из которых является открытым, а другой хранится в секрете. Алгоритм шифрования также может быть открытым, поэтому любой пользователь, желающий направить владельцу ключей зашифрованное сообщение, может использовать его открытый ключ и соответствующий алгоритм шифрования. Однако дешифровать данное сообщение сможет только тот, кто имеет парный закрытый ключ шифрования. Системы шифрования с открытым ключом могут также использоваться для отправки вместе с сообщением \"цифровой подписи\", подтверждающей, что данное сообщение было действительно отправлено владельцем открытого ключа.</p>\r\n<p><a name=\"_Toc323551718\"></a><strong>Управление СУБД.</strong></p>\r\n<p>Кроме управления работой с данными и структурой базы данных, администратор обязан управлять самой СУБД. Он должен собирать и анализировать статистику производительности системы и идентифицировать области, чреватые возникновением проблем. Вспомните, что база данных обслуживает множество пользовательских групп. Администратор базы данных должен рассматривать все жалобы на медленный отклик системы, неточность данных, сложность в использовании и т. п. Если требуются какие-то изменения, администратор должен составить план этих изменений и реализовать их.</p>\r\n<p>Администратор должен периодически осуществлять мониторинг пользовательской активности при работе с базой данных. Отчеты могут содержать информацию о том, какие пользователи были наиболее активны, какие файлы и, возможно, элементы данных использовались, какие методы доступа были при этом задействованы. Также в отчетах может присутствовать информация о типах и частоте возникновения ошибок. Администратор анализирует эту информацию с целью определить, нужны ли какие-либо изменения в структуре базы данных для повышения производительности или упрощения работы пользователей. Если такие изменения необходимы, администратор обеспечивает их реализацию.</p>\r\n<p>Администратор базы данных должен анализировать текущую статистику производительности базы данных и активности пользователей. При обнаружении каких-либо проблем с производительностью (в ходе анализа отчета или по жалобе пользователя) администратор должен определить, требуется ли модификация структуры базы данных или системы. Примерами возможных структурных модификаций являются введение новых ключей, чистка данных, удаление ключей и установление новых связей между объектами.</p>\r\n<p>Когда производитель используемой СУБД объявляет о новых возможностях продукта, администратор базы данных должен рассмотреть их в свете потребностей сообщества пользователей. Если он решит внедрить эти новые возможности, разработчиков следует уведомить об этом и обучить их использованию. Соответственно, помимо управления структурой базы данных администратор должен осуществлять управление и контроль над изменениями в СУБД.</p>\r\n<p>В обязанности администратора базы данных могут входить и другие изменения в системе; какие именно &ndash; это зависит от используемой СУБД и другого программного и аппаратного обеспечения. Например, изменения в операционной системе или web-сервере могут повлечь за собой необходимость модификации некоторых возможностей, функций или параметров СУБД. Поэтому администратор базы данных должен также настраивать СУБД для совместной работы с другим используемым программным обеспечением.</p>\r\n<p>Первоначальный выбор параметров СУБД (таких как уровень изоляции транзакций) происходит в момент, когда еще мало известно о том, как система будет работать в конкретном пользовательском окружении. Следовательно, опыт работы с системой и результаты анализа ее производительности могут указать на необходимость изменений. Даже если производительность кажется приемлемой, возможно, администратор базы данных захочет исследовать, как изменение ее параметров будет влиять на производительность. Этот процесс называется настройкой (tuning), или оптимизацией (optimizing), системы. В списке приведен перечень обязанностей администратора базы данных по управлению СУБД.</p>\r\n<ul>\r\n<li>Подготовка отчетов о работе базы данных.</li>\r\n<li>Рассмотрение жалоб пользователей на работу системы.</li>\r\n<li>Оценка необходимости изменений в структуре базы данных или приложений.</li>\r\n<li>Модификация структуры базы данных.</li>\r\n<li>Оценка и внедрение новых возможностей и функций СУБД.</li>\r\n<li>Настройка СУБД.</li>\r\n</ul>\r\n<p><a name=\"_Toc323551719\"></a><strong>Поддержание репозитория данных.</strong></p>\r\n<p>Представьте себе большое и активное интернет-приложение базы данных, подобное тем, что используются компаниями, занимающимися электронной коммерцией, &ndash; например, продажей музыки в сети Интернет. Информацию для такой системы могут предоставлять несколько различных баз данных, десятки web-страниц и сотни, если не тысячи, пользователей.</p>\r\n<p>Предположим, что компания, использующая это приложение, желает расширить ассортимент предлагаемых товаров, включив в него спортивные товары. Высшее руководство компании может попросить администратора базы данных оценить время и другие ресурсы, необходимые для того, чтобы настроить базу данных на поддержку новой линии продуктов.</p>\r\n<p>Чтобы администратор базы данных смог ответить на этот запрос, ему потребуются подробные метаданные, описывающие базу данных, ее приложения и компоненты этих приложений, пользователей и их права и привилегии, а также другие элементы системы. Часть этих метаданных хранится в системных таблицах базы данных, но одной только этой части будет недостаточно, чтобы ответить на вопросы, задаваемые высшим руководством. Администратору базы данных требуются дополнительные данные об объектах СОМ и ActiveX, сценарных процедурах и функциях, ASP-страницах, таблицах стилей, определениях типов документов и т. п. Кроме того, хотя механизмы безопасности СУБД обеспечивают документирование данных о пользователях, группах и привилегиях, они делают это в высокоструктурированной и зачастую неудобной форме.</p>\r\n<p>По этим причинам многие организации разрабатывают и поддерживают репозитории данных (data repositories), которые представляют собой коллекции метаданных, описывающих базу данных, ее приложения, web-страницы, пользователей и другие компоненты приложений. Репозиторий может быть виртуальным в том смысле, что составляющие его метаданные собраны из различных источников, в числе которых может быть СУБД, программное обеспечение контроля версий, библиотеки кода, средства генерации и редактирования web-страниц и т. д. Репозиторий данных также может быть интегрированным продуктом, который поставляется производителем CASE-средств или другими компаниями, например Microsoft или Oracle.</p>\r\n<p>В любом из этих случаев администратор базы данных должен задуматься о построении репозитория данных задолго до того, как высшее руководство начнет задавать вопросы. На самом деле репозиторий должен строиться при разработке системы, и его следует рассматривать как важную составляющую часть системы. В противном случае администратор базы данных будет &laquo;вечно догоняющим&raquo;, пытаясь поддерживать существующие приложения, адаптировать их к новым потребностям и каким-то образом собирать метаданные для репозитория.</p>\r\n<p>Лучший вид репозиториев &ndash; это активные репозитории (active repositories). Они формируются в процессе разработки системы за счет того, что при создании компонентов системы автоматически создаются метаданные. Менее желательным, но все же эффективным вариантом являются пассивные репозитории (passive repositories): заполнение таких репозиториев и создание метаданных для них происходит вручную.</p>\r\n<p>Интернет создал невиданные возможности для расширения клиентской базы и увеличения продаж и рентабельности в бизнесе. Базы данных и приложения, используемые компаниями в своей работе, составляют ключевой элемент этого успеха. К сожалению, найдутся такие организации, росту которых будет препятствовать неспособность наращивать свои приложения или адаптировать их к меняющимся потребностям. Зачастую построить новую систему оказывается проще, чем адаптировать уже существующую; определенно, построение новой системы, которая интегрировалась бы со старой, в то же время заменяя ее, может быть весьма сложной задачей.</p>\r\n<p>&nbsp;</p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Какие способы восстановления данных существуют в СУБД?</li>\r\n<li>Как обеспечивается управление конфигурацией БД?</li>\r\n<li>Как обеспечивается управление безопасностью БД?</li>\r\n<li>Каким способом администратор участвует в процессе поддержки базы данных?</li>\r\n<li>Как обеспечивается шифрование?</li>\r\n<li>Что такое репозиторий?</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'Резервное копирование и восстановление.\r\nДокументирование схемы базы данных.\r\nСоздание и модификация пользователей и ролей.',0),(13,'2016-09-14 06:44:43','Лекция 13. Интерфейс ODBC. ',13,'Lecture','<p><strong>Лекционный план</strong></p>\r\n<ol>\r\n<li>Технологии доступа к данным</li>\r\n<li>Интерфейс Open Database Connectivity.</li>\r\n<li>Архитектура ODBC.</li>\r\n<li>Функции ODBC API.</li>\r\n<li>Архитектура ODBC, JDBC, OCI, OLE DB и ADO.</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Ключевые слова: доступ к данным, </strong><strong>API, драйвер, </strong><strong>OLE, </strong><strong>JDBC</strong></p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p>Одной из основных задач, необходимых решить проектировщику или программисту ИС - это выбор технологии доступа к БД. Выбор технологии доступа к данным является одной из стратегических задач, от решения которой зависит как производительность будущей системы и способность реализовывать дополнительные функции, так и совместимость ее с другими программными платформами и технологиями, переносимость с одной платформы на другую.</p>\r\n<p>Существует несколько способов решения задачи обеспечения доступа к данным.</p>\r\n<p>Во многих современных СУБД имеются библиотеки, содержащие специальный интерфейс прикладного программирования (API), который представляет собой набор функций для манипулирования данными. В СУБД для настольных систем API осуществляет лишь чтение и запись данных в БД. В СУБД типа клиент/сервер API инициирует отправку по сети запроса к серверу и получение результатов или кодов ошибок для дальнейшей их обработки клиентским приложением.</p>\r\n<p>Один из способов доступа к данным заключается в непосредственном использовании API, однако это означает полную зависимость приложения от используемой СУБД. Таким образом, необходим некий универсальный механизм доступа к данным, обеспечивающий для клиентского приложения стандартный набор общих функций, классов, сервисов, служб, необходимых для работы с различными СУБД. Эти стандартные функции (классы или сервисы) должны размещаться в библиотеках, именуемых драйверами или провайдерами баз данных (data base drivers (providers)). Каждая такая библиотека реализует набор стандартных функций, классов или сервисов, используя обращения API к конкретной системе управления базами данных.</p>\r\n<p><strong>Интерфейс Open Database Connectivity.</strong></p>\r\n<p>Интерфейс ODBC (Open Database Connectivity) был разработан фирмой Microsoft как открытый интерфейс доступа к базам данных. Он предоставляет унифицированные средства взаимодействия прикладной программы, называемой клиентом (или приложением-клиентом), с сервером - базой данных.</p>\r\n<p>В основу интерфейса ODBC были положены спецификация CLI-интерфейса (Call-Level Interface), разработанная X/Open, и ISO/IEC для API баз данных, а также язык SQL (Structured Query Language) как стандарт языка доступа к базам данных.</p>\r\n<p>Интерфейс ODBC проектировался для поддержки максимальной интероперабельности приложений, которая обеспечивает унифицированный доступ любого приложения, использующего ODBC, к различным источникам данных. Так, если приложение, соответствующее стандарту ODBC и SQL, первоначально разрабатывалось для работы с базой данных Microsoft Access, а затем таблицы этой базы были перенесены в базу данных Microsoft SQL Server или базу данных Oracle, то приложение сможет и дальше обрабатывать эти данные без внесения дополнительных изменений.</p>\r\n<p>Для взаимодействия с базой данных приложение-клиент вызывает функции интерфейса ODBC, которые реализованы в специальных модулях, называемых ODBC-драйверами. Как правило, ODBC-драйверы - это DLL-библиотеки, при этом одна DLL-библиотека может поддерживать несколько ODBC-драйверов. При установке на компьютер любого SQL-сервера (базы данных, поддерживающей один из стандартов языка SQL, например, SQL-92) автоматически выполняется регистрация в реестре Windows и соответствующего ODBC-драйвера.</p>\r\n<p>Архитектура ODBC</p>\r\n<p>Архитектура ODBC представлена четырьмя компонентами (рис. 13.1):</p>\r\n<ul>\r\n<li>Приложение-клиент, выполняющее вызов функций ODBC.</li>\r\n<li>Менеджер драйверов, загружающий и освобождающий ODBC-драйверы, которые требуются для приложений-клиентов. Менеджер драйверов обрабатывает вызовы ODBC-функций или передает их драйверу.</li>\r\n<li>ODBC-драйвер, обрабатывающий вызовы SQL-функций, передавая SQL-серверу выполняемый SQL-оператор, а приложению-клиенту - результат выполнения вызванной функции.</li>\r\n<li>Источник данных, определяемый как конкретная локальная или удаленная база данных.</li>\r\n</ul>\r\n<p>Рис. 13.1 Архитектура ODBC.</p>\r\n<p>Основное назначение менеджера драйверов - загрузка драйвера, соответствующего подключаемому источнику данных, и инкапсуляция взаимодействия с различными типами источников данных посредством применения различных ODBC-драйверов.</p>\r\n<p>ODBC-драйверы, принимая вызовы функций, взаимодействуют с приложением-клиентом, выполняя следующие задачи:</p>\r\n<ul>\r\n<li>управление коммуникационными протоколами между приложением-клиентом и источником данных;</li>\r\n<li>управление запросами к СУБД;</li>\r\n<li>выполнение передачи данных от приложения-клиента в СУБД и из базы данных в приложение-клиент;</li>\r\n<li>возвращение приложению-клиенту стандартной информации о выполненном вызове ODBC-функции в виде кода возврата;</li>\r\n<li>поддерживает работу с курсорами и управляет транзакциями.</li>\r\n</ul>\r\n<p>Приложение-клиент одновременно может устанавливать соединения с несколькими различными источниками данных, используя разные ODBC-драйверы, а также несколько соединений с одним и тем же источником данных, используя один и тот же ODBC-драйвер.</p>\r\n<p><strong>Функции ODBC API.</strong></p>\r\n<p>Все функции ODBC API условно можно разделить на четыре группы:</p>\r\n<ol>\r\n<li>основные функции ODBC, обеспечивающие взаимодействие с источником данных;</li>\r\n<li>функции установки (setup DLL);</li>\r\n<li>функции инсталляции (installer DLL) ODBC и источников данных;</li>\r\n<li>функции преобразования данных (translation DLL).</li>\r\n</ol>\r\n<p>Объявления всех функций и используемых ими типов данных содержатся в заголовочных файлах. Группа основных функций ODBC API разбита на три уровня:</p>\r\n<ol>\r\n<li>функции ядра ODBC;</li>\r\n<li>функции 1 уровня;</li>\r\n<li>функции 2 уровня.</li>\r\n</ol>\r\n<p>Интерфейс ODBC API реализован как набор расслоенных DLL-функций для Windows. Динамическая библиотека ODBC.DLL &ndash; это основная библиотека управления драйверами ODBC, которая содержит функции вызовов специализированных драйверов для разных поддерживаемых системой баз данных. Каждый драйвер совместим со своим уровнем и относится к одной из двух категорий: одноуровневые или многоуровневые драйверы.</p>\r\n<p>Одноуровневые драйверы предназначены для использования при работе с теми источниками данных, которые не могут быть прямо обработаны с использованием ANSI SQL. Обычно это локальные базы данных на персональных компьютерах, такие как dBase, Paradox, FoxPro и Excel. Драйверы, соответствующие этим базам данных, производят компиляцию ANSI SQL в наборы инструкций более низкого уровня, которые непосредственно обрабатывают составляющие базу данных файлы.</p>\r\n<p>Многоуровневые драйверы используют сервер СУБД для обработки SQL-предложений и предназначены для работы в среде клиент-сервер. Помимо обработки ANSI SQL, они также могут поддерживать и собственные конструкции конкретной РСУБД, поскольку ODBC может без трансляции передавать SQL-операторы источникам данных (механизм \"passthrough\"). Драйверы ODBC для баз данных, поддерживаемым в технологии клиент-сервер реализованы для практически для всех промышленных серверов БД.</p>\r\n<p>Существует 4 важных этапа (шага) процедуры запроса данных через ODBC API.</p>\r\n<ul>\r\n<li><em>Шаг 1</em>- установление соединения. Первый шаг состоит в размещении указателей (handle) среды ODBC, которые выделяют оперативную память под ODBC драйверы и библиотеки. Затем происходит выделение памяти для указателей соединения, и соединение устанавливается.</li>\r\n<li><em>Шаг 2</em>- выполнение оператора SQL. Выделяется указатель оператора, локальные переменные связываются со столбцами в SQL-выражении (это необязательное действие), и выражение представляется главному ODBC-драйверу для обработки.</li>\r\n<li><em>Шаг 3</em>- извлечение данных. Перед извлечением данных возвращается информация о результирующем наборе, в частности, число столбцов в наборе. Исходя из этого числа, результирующий набор помещается в буфер записей, выполняется цикл его просмотра и содержимое каждого столбца помещается в соответствующую локальную переменную. Этот шаг необязателен, если используется связывание столбцов с локальными переменными.</li>\r\n<li><em>Шаг 4</em>- освобождение ресурсов. После того, как данные получены, ресурсы освобождаются путем вызова функций освобождения указателей оператора, соединения и среды. Указатели оператора и соединения могут быть использованы в процессе обработки.</li>\r\n</ul>\r\n<p>Технология ODBC разрабатывалась как общий, независимый от источников данных, способ доступа к данным. Применение технологии должно было также обеспечить переносимость приложений в среду различных баз данных без потребности переработки самих приложений. В этом смысле технология ODBC уже стала промышленным стандартом, ее поддерживают практически все производители СУБД и средств разработки.</p>\r\n<p>Однако универсальность стоит дорого. Если при разработке приложений одним из основных критериев является переносимость на различные СУБД, то использование ODBC является оправданным. Для увеличения производительности и эффективности приложения активно применяют специфические для данной СУБД расширения языка SQL, используют хранимые на сервере процедуры и функции. В этом случае теряется роль ODBC как общего метода доступа к данным. Тем более, что для разных СУБД драйверы ODBC поддерживают разные уровни совместимости. Поэтому многие производители средств разработки, помимо поддержки ODBC, поставляют \"прямые\" драйверы к основным СУБД.</p>\r\n<p><strong>Объектная модель OLE DB.</strong></p>\r\n<p>OLE DB представляет собой набор COM-интерфейсов (Component Object Model), которые предоставляют приложению-клиенту унифицированный доступ к различным источникам данных.</p>\r\n<p>Можно сказать, что OLE DB - это метод доступа к любым данным через стандартные COM-интерфейсы, вне зависимости от типа данных и места их расположения. В качестве данных могут выступать базы данных, простые документы, таблицы Excel и любые другие источники данных. В отличие от доступа, предоставляемого посредством драйверов OBDC, OLE DB позволяет реализовывать доступ к источникам данных, как с применением языка SQL (к SQL-серверам), так и к любым другим произвольным источникам данных.</p>\r\n<p>Средства, предоставляющие доступ к источнику данных с использованием технологии OLE DB, называются OLE DB провайдерами. Программы-клиенты, использующие для доступа OLE DB провайдеры, называются потребителями данных.</p>\r\n<p>В том случае, если существует только ODBC-драйвер для доступа к конкретному источнику данных, то для применения технологии OLE DB можно использовать OLE DB провайдер, предназначенный для доступа к ODBC-источнику данных.</p>\r\n<p>Так как архитектура OLE DB основана на COM, то механизм создания результирующих наборов состоит из последовательностей шагов типа: 1. создание объекта -&gt; 2. запрос указателя на интерфейс созданного объекта -&gt; 3. вызов метода интерфейса.</p>\r\n<p>Аналогично комплексу действий, который производится после создания результирующего набора при применении технологии ODBC - выполнению связывания, в технологии OLE DB используется механизм аксессоров. Аксессоры описывают, каким образом данные записываются в область памяти потребителя данных, устанавливая адресное соответствие между областью памяти в буфере потребителя данных и столбцами данных в результирующем наборе. Иногда такой набор связей называют картой столбцов (column map).</p>\r\n<p>Спецификация OLE DB описывает набор интерфейсов, реализуемых объектами OLE DB. Каждый объектный тип определен как набор интерфейсов. Спецификация OLE DB определяет набор интерфейсов базового уровня, которые должны реализовываться любыми OLE DB провайдерами.</p>\r\n<p>В базовую модель OLE DB входят следующие объекты:</p>\r\n<ul>\r\n<li>объект DataSource (источник данных), используемый для соединения с источником данных и создания одного или нескольких сеансов. Этот объект управляет соединением, использует информацию о полномочиях и аутентификации пользователя;</li>\r\n<li>объект Session (сеанс) управляет взаимодействием с источником данных - выполняет запросы и создает результирующие наборы. Сеанс также может возвращать метаданные. В сеансе может создаваться одна или несколько команд;</li>\r\n<li>объект Rowset (результирующий набор) представляет собой данные, извлекаемые в результате выполнения команды или создаваемые в сеансе.</li>\r\n</ul>\r\n<p>OLE DB представляет собой интерфейс системного уровня, обеспечивающий доступ к различным источникам данных &ndash; реляционным и нереляционным, содержащим текст, графические и географические данные, к файлам электронной почты, содержимому файловых систем и создаваемым пользователями бизнес-объектам. OLE DB определяет набор интерфейсов компонентной объектной модели (Component Object Model, COM), включающих в себя службы различных систем управления базами данных для обеспечения универсального доступа к данным. С помощью этих интерфейсов программисты могут создавать дополнительные сервисы баз данных.</p>\r\n<p>Любой компонент программного обеспечения, который использует интерфейсы OLE DB, является потребителем OLE DB. Это может быть бизнес-приложение, инструментальное средство разработки программного обеспечения, например, Borland Delphi, сложные приложения или же объектная модель ActiveX Data Objects, использующая интерфейсы OLE DB. Потребители используют либо те ActiveX Data Objects (ADO), которые являются интерфейсом прикладного уровня для обеспечения косвенного (indirect) доступа к данным с применением OLE DB, либо непосредственно OLE DB &ndash; для прямого доступа к данным с помощью провайдера OLE DB.</p>\r\n<p>С точки зрения OLE DB, может быть два вида провайдеров: OLE DB - провайдеры данных и провайдеры сервисов (служб).</p>\r\n<p><strong>Провайдер данных</strong>&nbsp;(data provider) представляет собой компонент программного обеспечения, \"владеющий\" данными. Он находится между потребителем и непосредственным массивом данных. В OLE DB все провайдеры представляют данные в табличном формате (с которым мы уже знакомы по реляционным базам данных и электронным таблицам), в виде виртуальных таблиц. Провайдер данных выполняет следующие задачи.</p>\r\n<ul>\r\n<li>Принимает запросы, поступающие от потребителя, на доступ к данным.</li>\r\n<li>Выполняет выборку или обновление данных из массива данных.</li>\r\n<li>Возвращает эти данные потребителю.</li>\r\n</ul>\r\n<p>Одним из примеров провайдера данных служит Microsoft Jet 4.0 OLE DB Provider. Он используется совместно с механизмом доступа к базам данных Microsoft Jet, применяемым для обработки информации в базах данных Microsoft Access, а также для доступа как к базам данных к информации, упорядоченной с помощью так называемого инсталлируемого индексно-последовательного метода доступа (Indexed Sequential Access Method, I-ISAM), который поддерживается в Jet. К таким данным относятся таблицы, хранимые в рабочих книгах Excel, почтовые файлы Outlook и Microsoft Exchange, таблицы dBase и Paradox, текстовые и HTML-файлы и т. д. Другим провайдером OLE DB является Microsoft OLE DB Provider for SQL Serwer, используемый для работы с базами данных Microsoft SQL Server 6.5, 7.0, 2000.</p>\r\n<p>Провайдер сервисов (служб) реализует расширенные функциональные возможности, которые не поддерживаются обычными провайдерами данных, и сам не \"владеет\" данными. Этот провайдер, например, обеспечивает сортировку, фильтрацию, управление транзакциями, обработку SQL-запросов, функции указателя (курсора) и т. д. Провайдер сервисов может напрямую работать с массивами данных или же через соответствующий провайдер данных; в этом случае он выступает в роли потребителя и провайдера.</p>\r\n<p>Например, такие провайдеры сервисов, как Microsoft Cursor Service for OLE DB и Microsoft Data Shaping Service for OLE DB могут интегрироваться с базовыми провайдерами данных OLE DB для расширения их функциональных возможностей.<br /> Такие провайдеры сервисов, как Microsoft Cursor Service for OLE DB и Microsoft Data Shaping Service for OLE DB могут интегрироваться с базовыми провайдерами данных OLE DB для расширения их функциональных возможностей.</p>\r\n<p><strong>ADO.</strong></p>\r\n<p>OLE DB обеспечивает связывание для программистов на С и C++, а также программистов, использующих языки с С-подобными вызовами функций. Такие языки, как VB и VBScript, не поддерживают тип данных &laquo;указатель&raquo; (адресных переменных). Следовательно, они не могут использовать связывание в стиле С и прямое обращение к OLE DB.</p>\r\n<p>Вероятно, для большей путаницы разработчики Microsoft ввели еще одну объектную модель доступа к данным: ADO. ADO работает с объектами DAO и RDO, а также поддерживает более простые модели, чем DAO и RDO (хотя с избыточной функциональностью, так что можно выполнить операцию несколькими способами). Объектная иерархия в ADO более однородная, чем в DAO. ADO содержит несколько встроенных объектов, которые упрощают доступ к данным из информационных хранилищ.</p>\r\n<p>На Рисунке 13.2 показано несколько способов, с помощью которых приложение связывается с базой данных. Например, VB-программист может использовать ADO для соединения приложения с провайдером OLE DB. Если база данных не поддерживает OLE DB, приложение может задействовать ODBC. Программист на Visual C++ может применять ADO или соединяться напрямую через OLE DB.</p>\r\n<p>Рис.13.2. Различие маршрутов приложений в ADO.</p>\r\n<p>Объект Recordset представляет собой набор записей (таблицу) и поддерживает типы курсоров adOpenForwardOnly, adOpenKeyset, adOpenDynamic и adOpenStatic. Курсор может быть как на стороне сервера (по умолчанию), так и на стороне клиента.</p>\r\n<p>Для доступа к записи ADO требуется просканировать набор строк последовательно. Для доступа к нескольким таблицам необходимо выполнить запрос на объединение JOIN, чтобы получить результат в виде набора строк. Хотя объект Recordset поддерживает доступ к данным без соединения с ними, ADO изначально был спроектирован для данных, с которыми установлено соединение. Такой метод доступа заставляет хранить важные ресурсы на стороне сервера. Вдобавок для передачи набора строк следует использовать метод упорядочивания, названный COM marshalling. COM marshalling &mdash; это процесс преобразования типов данных, который, естественно, занимает полезные ресурсы системы.</p>\r\n<p>Начиная с ADO 2.1, Microsoft добавляет поддержку XML в объектную модель ADO, что позволяет хранить набор строк Recordset как XML-документ. Однако только при появлении ADO 2.5 ряд ограничений XML, который сохранялся в версии ADO 2.1 (например, жесткая иерархия объектов Recordset), был устранен. Хотя ADO может преобразовать документ XML в набор Recordset, он в состоянии читать только документы в собственной схеме, известной как Advanced Data TableGram (ADTG).</p>\r\n<p>В поисках механизма доступа к несвязанным данным Microsoft расширяет ADO и вводит службу Remote Data Services (RDS). RDS создана после ADO и разрешает передачу объекта Recordset клиенту (например, в Web-браузер) при отсутствии активного соединения. Однако RDS, как и ADO, использует упорядочивание COM marshaling для передачи набора строк от сервера клиенту.</p>\r\n<p><strong>Эра .NET</strong></p>\r\n<p>Когда Microsoft начала разрабатывать .NET Framework, она имела хорошую возможность пересмотреть модель доступа к данным. Решив не продолжать разработку технологии ADO, специалисты Microsoft приступили к созданию новой структуры доступа к данным, при этом сохранив акроним. Microsoft разрабатывает ADO.NET на базе уже зарекомендовавшей себя объектной технологии ADO. Но ADO.NET ориентируется на три важные возможности, которые не поддерживаются ADO: поддержка модели доступа к несвязанным данным, что является ключевым элементом для работы в Web; поддержка тесной интеграции с XML; интеграция с .NET Framework (например, совместимость с базовой библиотекой классов типичной системы).</p>\r\n<p>Архитектура ADO.NET. На Рисунке 11.3 представлена архитектура ADO.NET. Объект Recordset, который выполняет так много функций в ADO, здесь отсутствует. Вместо него в ADO.NET предусмотрено несколько особых объектов, выполняющих специфические задачи. В Таблице 1 описаны три из них: DataAdapter, DataReader и DataSet.</p>\r\n<p>Рис. 11.3. Архитектура ADO.NET.</p>\r\n<p>Поставщики данных .NET. Очень важный компонент ADO.NET, провайдер данных .NET, реализует интерфейсы ADO.NET. В частности, он реализует объект DataReader так, что его могут использовать и приложение, и объект DataSet.</p>\r\n<p>Поставщик данных .NET состоит из четырех основных компонентов: Connection &mdash; для связи с источником данных; Command выполняет команды над источником данных; DataReader читает данные из источника данных в однонаправленном режиме &laquo;только чтение&raquo;, и DataAdapter, который читает данные из источника данных и использует их для заполнения объекта DataSet.</p>\r\n<p>Visual Studio .NET содержит два поставщика данных .NET. Поставщик данных SQL Server .NET обеспечивает связь с SQL Server 7.0 и более поздними версиями. Этот метод доступа наиболее эффективен для SQL Server 7.0 и выше, потому что поставщик данных SQL Server .NET связывается напрямую с SQL Server через протокол Tabular Data Stream (TDS). Поставщик данных OLE DB .NET необходим для соединения с отличными от SQL Server базами данных, такими, как Oracle или IBM DB2. Этот поставщик данных использует OLE DB для соответствующих баз данных.</p>\r\n<p>Во время написания статьи разработчики Microsoft реализовали третий тип поставщика данных .NET &mdash; ODBC .NET Data Provider &mdash; Release Candidate Beta. Его можно получить на сайте Microsoft&nbsp;<em>http://www.microsoft.com/data/ download_odbcnetrc.htm</em>.</p>\r\n<p>На Рисунке 11.4 показаны различные пути, по которым приложение может связываться с базой данных через ADO.NET. При выборе пути сначала определяется, какой поставщик данных .NET будет использоваться. Если это SQL Server 7.0 или более поздняя версия, то подключается поставщик данных SQL Server.NET. Если база данных SQL Server 6.5 или отличная от SQL Server (например, Oracle), понадобится поставщик данных OLE DB .NET. Заметим, что можно задействовать поставщик данных OLE DB .NET для баз данных SQL 7.0 и выше, но тогда потеряется выигрыш в производительности, который дает прямое подключение к SQL Server через протокол TDS. Однако в этом неспецифическом способе есть свой плюс &mdash; мобильность, т. е. можно менять базы данных без модификации кода.</p>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<p><em>&nbsp;</em></p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>Рис. 11.4. Различие маршрутов в ADO.NET.</p>\r\n<p>Далее необходимо определить, какую задачу требуется выполнить. Если надо просто прочитать и отобразить данные из источника данных, объекта Data Reader вполне достаточно. Но если предстоит манипулировать данными (например, редактировать или удалять), нужно использовать объект Data Set. Хотя задействовать этот объект следует только в случае необходимости, потому что он работает медленнее, чем Data Reader (Data Set использует Data Reader для заполнения таблиц).</p>\r\n<p><strong>JDBC.</strong></p>\r\n<p>JDBC очень проста &mdash; это API доступа к табличным данным. Внимательный читатель заметит, что речь не идет о базах данных, а о &laquo;табличных данных&raquo;. Разница на первый взгляд может и не очень существенная, но на самом деле критичная. Например существуют JDBC драйверы доступа к текстовым файлам, таблицам Microsoft Excel, то есть к таким данным, которые ну никак нельзя отнести к базам данных: с поддержкой транзакций, индексов, отношений и проч.</p>\r\n<p>JDBC, важно отметить, поддерживает работу не только с SQL совместимыми СУБД, но также и с практически любыми данными табличного типа. Хотя справедливо все же будет отметить, что мощь JDBC состоит конечно же не в том, чтобы прочитать данные из текстового файла &mdash; это как говорится &laquo;из пушки по воробъям&raquo; &mdash; без использования механизма транзакций, доступа к хранимым процедурам и проч. &laquo;прелестям&raquo; присущим SQL базам данных JDBC не стал бы тем чем он сейчас является.</p>\r\n<p>Технологию JDBC ни в коей мере нельзя называть технологией одной компании Sun Microsystems &mdash; родного отца Java. На данный момент технологию JDBC официально поддерживают следующие организации:</p>\r\n<ul>\r\n<li>Oracle</li>\r\n<li>DataDirect Technologies</li>\r\n<li>BEA</li>\r\n<li>Fujitsu</li>\r\n<li>MySQL</li>\r\n<li>INET Software</li>\r\n<li>Novell</li>\r\n<li>Borland</li>\r\n<li>Pointbase Inc.</li>\r\n<li>Macromedia</li>\r\n<li>SAP</li>\r\n</ul>\r\n<p>В API JDBC интенсивно эксплуатируется концепция интерфейсов &mdash; набора методов, которые должны быть реализованы поставщиком того или иного сервиса, в данном случае поставщиком т.н. драйвера JDBC. С программной точки зрения драйвер JDBC есть нечто иное как реализация интерфейсов предусмотренных API JDBC. По способу реализации драйверы подразделяются на 4 типа:</p>\r\n<p><strong>Тип 1</strong></p>\r\n<p>К этому типу относятся драйверы реализованные поверх ODBC драйверов (что такое ODBC мы объяснять здесь не будем, если кто-то не знает отсылаем к первооисточнику). То есть фактически все вызовы API JDBC транслируются в вызовы ODBC, а дальше обработку вызова ведет API ODBC. Иногда еще 1-й тип драйверов называется \"JDBC-ODBC bridge\". Преимуществом драйверов этого типа, является то что все источники данных доступные с помощью ODBC становятся доступными Java приложению, недостатки такого драйвера: низкая скорость работы, трудности конфигурирования и невозможность поддержки всех возможностей API JDBC.</p>\r\n<p><strong>Тип 2</strong></p>\r\n<p>Ко второму типу относятся драйверы использующие программные части написанные на других языках (как правило на Си). Обычно в этом случае для доступа к базе данных используются библиотеки разработанные производителем, а для их вызова используется JNI &mdash; Java интерфейс вызова нативных функций. Примером такого драйвера является т.н. &laquo;толстый&raquo; OCI-JDBC драйвер для Oracle. Такие драйверы обычно очень быстрые, но опять же так же как и в случае JDBC-ODBC драйверов требуют установки специального ПО на клиентской машине. Для OCI-JDBC драйвера Oracle например требуется установка клиента SQL*NET.</p>\r\n<p><strong>Тип 3</strong></p>\r\n<p>В отличие от предыдущих типов драйверов данный тип драйвера полностью реализуется на Java, но при этом вызовы JDBC транслируются в сетевой протокол (RMI, HTTP и т.д.), который далее транслируется в специфичный протокол базы данных. В чем-то этот драйвер схож с драйверами JDBC-ODBC, отличие в том, что реализуется полностью на Java, за счет чего отсутствует необходимость в установке клиентского ПО.</p>\r\n<p><strong>Тип 4</strong></p>\r\n<p>Также как и драйверы 3-го типа реализуется полностью на Java, но вызовы реализуются напрямую с использованием протокола базы данных, минуя сетевой протокол.</p>\r\n<p>Необходимо здесь также отметить, что несмотря на то что производители драйверов часто декларируют тот или иной тип, полную совместимость и т.д. тем не менее в реальной жизни только около четверти драйверов имеют сертификат соответствия спецификации JDBC. Наиболее полную информацию о существующих драйверах JDBC можно получить посетив корневой ресурс JDBC: http://java.sun.com/products/jdbc/. Здесь помещен список драйверов JDBC с указанием их типа, производителя и наличия сертификатов: http://servlet.java.sun.com/products/jdbc/drivers. База содержит около 200 драйверов и снабжена удобной системой поиска и навигации.</p>\r\n<p>JDBC API содержит два основных типа интерфейсов: первый &mdash; для разработчиков приложений и второй (более низкого уровня) &mdash; для разработчиков драйверов.</p>\r\n<p>Соединение с базой данных описывается классом, реализующим интерфейс java.sql.Connection. Имея соединение с базой данных, можно создавать объекты типа Statement, служащие для исполнения запросов к базе данных на языке SQL.</p>\r\n<p>Существуют следующие виды типов Statement, различающихся по назначению:</p>\r\n<ul>\r\n<li>sql.Statement &mdash; Statement общего назначения;</li>\r\n<li>sql.PreparedStatement &mdash; Statement, служащий для выполнения запросов, содержащих подставляемые параметры (обозначаются символом \'?\' в теле запроса);</li>\r\n<li>sql.CallableStatement &mdash; Statement, предназначенный для вызова хранимых процедур.</li>\r\n<li>sql.ResultSet позволяет легко обрабатывать результаты запроса.</li>\r\n</ul>\r\n<p>Рис 11.5. Основные интерфейсы JDBC.</p>\r\n<p>Интерфейс выражения java.sql.Statement выступает в качестве предка для других двух важных интерфейсов: java.sql.PreparedStatement и java.sql.CallableStatement, первый из которых предназначен для выполнения прекомпилированных SQL-выражений, второй - для выполнения вызовов хранимых процедур. Соответственно Statement выполняет обычные (статические) SQL-запросы, а указанные два наследника работают с параметризированными SQL-выражениями.</p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Контрольные вопросы:</strong></p>\r\n<ol>\r\n<li>Перечислите основные технологии доступа к данным.</li>\r\n<li>Что такое open database connectivity?</li>\r\n<li>Что такое OLEDB?</li>\r\n<li>Как работает OLEDB?</li>\r\n<li>Что такое JDBC?</li>\r\n<li>Как работает JDBC?</li>\r\n</ol>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>Литература:</strong></p>\r\n<ol>\r\n<li>Thomas Connolly, Carolyn Begg &ndash; Database systems. A practical Approach to Design, Implementation and Management. 4th Edition &ndash; Addison Wesley 2005 &ndash; 1373p.</li>\r\n<li>J. Date &ndash; An Introduction to Database Systems &ndash; Addison-Wesley Professional &ndash; 2003 &ndash; 1024 p.</li>\r\n</ol>',1,'Технологии доступа к данным\r\nИнтерфейс Open Database Connectivity.\r\nАрхитектура ODBC.\r\nФункции ODBC API.\r\nАрхитектура ODBC, JDBC, OCI, OLE DB и ADO.',0),(14,'2016-09-14 11:44:00','Лекция 1: Введение в MySQL',1,'Lecture','<h3>СУБД</h3>\r\n<p id=\"id_13\">Программист, работающий с базой данных, не заботится о том, как эти данные хранятся, и приложения, взаимодействующие с <span class=\"keyword\">СУБД</span>, не знают о способе записи данных на <span class=\"keyword\">диск</span>. \"Снаружи\" виден лишь <span class=\"keyword\">логический</span> образ данных, и это позволяет менять код <span class=\"keyword\">СУБД</span>, не затрагивая код самих приложений.</p>\r\n<div id=\"mark_13\" class=\"lecture_mark\">&nbsp;</div>\r\n<p id=\"id_14\">Подобная обработка данных осуществляется посредством языка четвертого поколения (<span class=\"keyword\">4GL</span>), который поддерживает запросы, записываемые и исполняемые немедленно. Данные быстро утрачивают свою актуальность, поэтому скорость доступа к ним важна. Кроме того, программист должен иметь возможность формулировать новые запросы. Они называются нерегламентированными (<span class=\"keyword\">ad hoc</span>), поскольку не хранятся в самой базе данных и служат узкоспециализированным целям.</p>\r\n<div id=\"mark_14\" class=\"lecture_mark\">&nbsp;</div>\r\n<p id=\"id_15\">Язык четвертого поколения позволяет создавать схемы &mdash; точные определения данных и отношений между ними. Схема хранится как часть <span class=\"keyword\">базы данных</span> и может быть изменена без ущерба для данных.</p>\r\n<div id=\"mark_15\" class=\"lecture_mark\">&nbsp;</div>\r\n<p id=\"id_16\">Схема предназначена для контроля целостности данных. Если, к примеру, объявлено, что <span class=\"keyword\">поле</span> содержит целочисленные значения, то <span class=\"keyword\">СУБД</span> откажется записывать в него числа с плавающей запятой или строки. Отношения между записями тоже четко контролируются, и несогласованные данные не допускаются. <span class=\"keyword\">Операции</span> можно группировать в транзакции, выполняемые <span class=\"keyword\">по</span> принципу \"все или ничего\".</p>\r\n<div id=\"mark_16\" class=\"lecture_mark\">&nbsp;</div>\r\n<p id=\"id_17\"><span class=\"keyword\">СУБД</span> обеспечивает <span class=\"keyword\">безопасность данных</span>. Пользователям предоставляются определенные <span class=\"keyword\">права доступа</span> к информации. Некоторым пользователям разрешено лишь просматривать данные, тогда как другие пользователи могут менять содержимое таблиц.</p>\r\n<div id=\"mark_17\" class=\"lecture_mark\">&nbsp;</div>\r\n<p id=\"id_18\"><span class=\"keyword\">СУБД</span> поддерживает параллельный <span class=\"keyword\">доступ</span> к базе данных. Приложения могут обращаться к базе данных одновременно, что повышает общую <span class=\"keyword\">производительность</span> системы. Кроме того, отдельные <span class=\"keyword\">операции</span> могут \"распараллеливаться\" для еще большего улучшения производительности.</p>\r\n<div id=\"mark_18\" class=\"lecture_mark\">&nbsp;</div>\r\n<p id=\"id_19\">Наконец, <span class=\"keyword\">СУБД</span> помогает восстанавливать информацию в случае непредвиденного сбоя, незаметно для пользователей создавая резервные копии данных. Все изменения, вносимые в базу данных, регистрируются, поэтому многие <span class=\"keyword\">операции</span>можно отменять и выполнять повторно.</p>',2,'Аннотация: В этой лекции рассматриваются вводные понятия баз данных, их виды, и даётся обзор основных характеристик MySQL.',0),(15,'2016-09-14 12:17:06','Введение в PostgreSQL',1,'Lecture','<h2>Что такое PostgreSQL ?</h2>\r\n<blockquote>ЗostgreSQL - это свободно распространяемая объектно-реляционная система управления базами данных (ORDBMS), наиболее развитая из открытых СУБД в мире и являющаяся реальной альтернативой коммерческим базам данных.</blockquote>\r\n<p>PostgreSQL произносится как <strong>post-gress-Q-L</strong> (можно скачать mp3 файл <a href=\"http://www.sai.msu.su/~megera/postgres/talks/postgresql.mp3\">postgresql.mp3</a>), в разговоре часто употребляется <strong>postgres</strong> (<strong>пост-гресс</strong>). Также, употребляется сокращение <strong>pgsql</strong> (<strong>пэ-жэ-эс-ку-эль</strong>).</p>\r\n<h3>История развития PostgreSQL</h3>\r\n<p>Краткую историю PostgreSQL можно прочитать в документации, распространяемой с дистрибутивом или на <a href=\"http://www.postgresql.org/docs/current/static/history.html\">сайте</a>. Также, есть <a href=\"http://www.linuxshare.ru/postgresql/manual/history.html\">перевод</a>на русский язык. Из нее следует, что современный проект PostgreSQL ведет происхождение из проекта POSTGRES, который разрабатывался под руководством Майкла Стоунбрейкера (Michael Stonebraker), профессора Калифорнийского университета в Беркли (UCB). Мне захотелось несколько подробнее показать взаимосвязи родословных баз данных, чтобы лучше понять место PostgreSQL среди основных игроков современного рынка баз данных.</p>\r\n<p>Я попытался графически ( <a href=\"http://www.sai.msu.su/~megera/postgres/talks/rel-db-hist.png\" target=\"_BLANK\">большая версия картинки</a> откроется в новом окне) отобразить все наиболее заметные RDBMS и связи между ними и приблизительно привел даты их создания и конца. Пересечение объектов означает поглощение, при этом поглощаемый объект более бледен и не окантован. Знак доллара означает, что база данных является коммерческой. При этом, я основывался на информации, доступной в интернете, в частности в <a href=\"http://www.wikipedia.org/\">Wikipedia</a>, в научных статьях, которые я читал и комментариях непосредственных пользователей БД, которые я получил после публикации этой картинки в интернете.</p>\r\n<p>Надо сказать, что несмотря на то, что вся история реляционных баз данных насчитывает менее 4 десятков лет, многие факты из истории создания трактуются по-разному, даты не согласуются, а сами участники событий зачастую просто вольно трактуют прошлое.Здесь надо принимать во внимание тот факт, что базы данных - это большой бизнес, в котором развитие одних БД часто связано с концом других. Кроме того, БД в то время были предметом научных исследований, поэтому приоритетность работ является не последним аргументом при написании воспоминаний и интервью. Наверное, учитывая такую запутанность, премия ACM Software System Award #6 была присуждена одновременно двум соперничающим группам исследователей из IBM за работу над \"System R\" и Беркли - за INGRES, хотя Стоунбрейкер получил награду от ACM SIGMOD (сейчас это премия названа в честь Теда Кодда - автора реляционной теории баз данных) #1 в 1992 г., а Грей (Jim Gray, Microsoft) - #2 в 1993 году.</p>\r\n<p>Итак, как следует из рисунка, видно две ветви развития баз данных - одна следует из \"System R\", которая разрабатывалась в IBM в начале 70-х, и другая из проекта \"INGRES\", которым руководил Стоунбрейкер приблизительно в тоже время. Эти два проекта начались как необходимость практического использования реляционной модели баз данных, разработанной Тедом Коддом (Ted Codd) из IBM в 1969,1970 годах. Надо помнить, что в то время имелось две альтернативные модели баз данных - сетевая и иерархическая, причем за ними стояли мощные силы - CODASYL Data Base Task Group (сетевая) и сама IBM с ее базой IMS (Information Management System с иерархической моделью данных). Немного в стороне стоит \"Oracle\", взлет которой во многом связан с коммерческим талантом Эллисона быть в нужном месте и в нужное время, как сказал Стоунбрейкер в своем <a href=\"http://www.crn.com/sections/special/hof/hof00.jhtml?articleId=18811372\">интервью</a>, хотя она вместе с IBM сыграла большую роль в создании и продвижении SQL.</p>\r\n<p>\"System R\" сыграла большую роль в развитии реляционных баз данных, создании языка SQL (изначально SEQUEL, но из-за проблем с уже существующей торговой маркой пришлось выкинуть все гласные буквы). Из \"System R\" развилась SQL/DS и DB2. На самом деле, в IBM было еще несколько проектов, но они были чисто внутренними. Подробнее об этой ветви можно прочитать в весьма поучительном документе <a href=\"http://www.mcjones.org/System_R/SQL_Reunion_95/\">\"The 1995 SQL Reunion: People, Projects, and Politics\"</a>, также доступен <a href=\"http://www.citforum.ru/database/digest/sql1.shtml\">русский перевод</a>.</p>\r\n<p>INGRES (или Ingres89), в отличие от \"System R\", вполне в духе Беркли развивалась как открытая база данных, коды которой распространялись на лентах практически бесплатно (оплачивались почтовые расходы и стоимость ленты). К 1980 году было распространено порядка 1000 копий. Название расшифровывается как \"<strong>IN</strong>teractive <strong>G</strong>raphics (and) <strong>RE</strong>trieval <strong>S</strong>ystem\" и совершенно <strong>случайно</strong> связано с французским художником<a href=\"http://www.sai.msu.su/cjackson/ingres/ingres_bio.htm\">Jean Auguste Dominique Ingres</a>. Отличительной особенностью этой системы являлось то, что она разрабатывалась для операционной системы UNIX, которая работала на распространенных тогда PDP 11, что и предопределило ее популярность, в то время как \"System R\" работала только на больших и дорогих mainframe. Был разработан язык запросов QUEL, который, как писал Стоунбрейкер, похож на SEQUEL в том отношении, что программист свободен от знания о структуре данных и алгоритмах, что способствует значительной степени независимости от данных. Доступность INGRES и очень либеральная лицензия BSD, а также творческая деятельность, способствовали появлению большого количества реляционных баз данных, как показано на рисунке.</p>\r\n<p>Стоунбрейкер лично способствовал их появлению, так он конце 70-х он организовал компанию Ingres Corporation (как он сам объясняет, ему пришлось на это пойти, так как Аризонский университет, потребовал поддержки), которая выпустила коммерческую версию Ingres, в 1994 году она была куплена CA (Computer Associates) и которая в 2004 году стала открытой как Ingres r3.</p>\r\n<p>\"NonStop SQL\" компании Tandem Computers являлась модифицированной версией Ingres, которая эффективно работала на параллельных компьютерах и с распределенными данными. Она умела выполнять запросы параллельно и масштабировалась почти линейно с количеством процессоров. Ее авторами были выпускники из Беркли. Впоследствии, Tandem Computers была куплена компанией Compaq (2000 г.), а затем компанией HP.</p>\r\n<p>Компания Sybase тоже была организована человеком из Беркли (Роберт Эпстейн) и на основе Ingres. Известно, что база данных компании Мaйкрософт \"SQL Server\" - это не что иное как база данных Sybase, которая была лицензирована для Windows NT. С 1993 года пути Sybase и Mirosoft разошлись и уже в 1995 году Sybase переименовывает свою базу данных в ASE (Adaptive Server Enterprise), а Microsoft стала продолжать развивать MS SQL.</p>\r\n<p>Informix тоже возник из Ingres, но на это раз людьми не из Беркли, хотя Стоунбрейкер все-таки поработал в ней CEO после того, как Informix купила в 1995 году компанию Ilustra, чтобы прибавить себе объектно-реляционности и расширяемости (DataBlade), которую организовал все тот же Майкл Стоунбрейкер как результат коммерциализации Postgres в 1992 году. В 2001 году она была куплена IBM, которая приобретала немалое количество пользователей Informix и технологию. Таким образом, DB2 также приобрела немного объектно-реляционности.</p>\r\n<p>Проект Postgres возник как результат осмысления ошибок Ingres и желания преодолеть ограниченность типов данных, за счет возможности определения новых типов данных. Работа над проектом началась в 1985 и в период 1985-1988 было опубликовано несколько статей, описывающих модель данных, язык запросов POSTQUEL, и хранилище Postgres. POSTGRES иногда еще относят к так называемым <strong>постреляционным СУБД</strong>. Ограниченность реляционной модели всегда являлась предметом критики, хотя все понимали, что это является следствием ее простоты и ее заслугой. Однако, проникновение компьютерных технологий во все сферы жизни требовали новых приложений, а от баз данных - поддержки новых типов данных и возможностей, например, поддержка наследования, создание и управление сложными объектами.</p>\r\n<p>Еще при проектировании оригинальной версии <strong>POSTGRES</strong> основное внимание было уделено расширяемости и объектно-ориентированным возможностям. Уже тогда было ясна необходимость расширения функциональности DMBS от управления данными (<strong>data management</strong>) в сторону управления объектами (<strong>object management</strong>) и знаниями (<strong>knowledge management</strong>). При этом объектная функциональность позволит эффективно хранить и манипулировать нетрадиционными типами данных, а управление знаниями позволяет хранить и обеспечивать выполнения коллекции правил (<strong>rules</strong>), которые несут семантику приложения. Стоунбрейкер так и определил основную задачу POSTGRES как <strong>\"обеспечить поддержку приложений, которые требуют службы управления данными, объектами и знаниями\"</strong>.</p>\r\n<p>Одним из фундаментальным понятием POSTGRES является <em>class</em>. Class есть именованная коллекция экземпляров (<em>instances</em>) объектов. Каждый экземпляр имеет коллекцию именованных <strong>атрибутов</strong> и каждый атрибут имеет определенный <strong>тип</strong>. Классы могут быть трех типов - это основной класс, чьи экземпляры хранятся в базе данных, виртуальный (view), чьи экземпляры материализуются только при запросе (они поддерживаются системой управления правилами), и может быть версией другого (<em>parent</em>) класса.</p>\r\n<p>Первая версия была выпущена в 1989 году, затем последовало еще несколько переписываний системы правил (rule system). Отметим, что коды Ingres и Postgres не имели ничего общего ! В POSTGRES была реализована поддержка таких типов как многомерные массивы, что уже шло в противоречие с реляционной моделью, timetravel - хранение версионности объектов (впоследствии, в версии 6.3 этот тип был удален, так как его поддержка требовала больших усилий, а версионность могла быть реализована на стороне приложения с помощью триггеров). В 1992 году была образована компания Illustra, а сам проект был закрыт в 1993 году выпуcком версии 4.2. Однако, несмотря на официальное закрытие проекта, открытый код и BSD лицензия сподвигли выпускников Беркли Andrew Yu и Jolly Chen в 1994 году взяться за его дальнейшее развитие. В 1995 году они заменили язык запросов POSTQUEL на общепринятый SQL, проект получил название <strong>Postgres95</strong>, изменилась нумерация версий, был создан веб сайт проекта и появились много новых пользователей (среди которых был и автор).</p>\r\n<p>&nbsp;</p>\r\n<p>К 1996 году стало ясно, что название \"Postgres95\" не выдержит испытанием временем и было выбрано новое имя - <strong>\"PostgreSQL\"</strong>, которое отражает связь с оригинальным проектом POSTGRES и приобретением SQL. Также, вернули старую нумерацию версий, таким образом новая версия стартовала как 6.0. В 1997 был предложен слон в качестве логотипа, сохранилось <a href=\"http://www.pgsql.ru/db/mw/msg.html?mid=1238939\">письмо</a> в архивах рассылки -hackers за 3 марта 1997 года и последующая дискуссия. Слон был предложен Дэвидом Янгом в честь романа Агаты Кристи \"Elephants can remember\" (Слоны могут вспоминать). До этого, логотипом был бегущий леопард (ягуар). Проект стал большой и управление на себя взяла небольшая вначале группа инициативных пользователей и разработчиков, которая и получила название PGDG (PostgreSQL Global Development Group). Дальнейшее развитие проекта полностью <a href=\"http://www.ru.postgresql.org/docs/current/static/release.html\">документировано</a> в документации и отражено в архивах списка рассылки -hackers.</p>\r\n<h3>Что есть PostgreSQL сегодня ?</h3>\r\n<p>На сегодняшний день выпущена версия PostgreSQL v8 (19 января 2005 года), которая является значительным событием в мире баз данных, так как количество новых возможностей добавленных в этой версии, позволяет говорить о возникновении интереса крупного бизнеса как в использовании, так и его продвижении. Так, крупнейшая компания в мире, Fujitsu поддержала работы над версией 8, выпустила коммерческий модуль<a href=\"http://www.fastware.com/postgresql.html\">Extended Storage Management</a>. Либеральная <a href=\"http://www.freebsd.org/copyright/freebsd-license.html\">BSD-лицензия</a> позволяет коммерческим компаниям выпускать свои версии PostgreSQL под своим именем и осуществлять коммерческую поддержку. Например, компания Pervasive объявила о выпуске <a href=\"http://www.pervasivepostgres.com/\">Pervasive Postgres</a>.</p>\r\n<p>PostgreSQL поддерживается на всех современных Unix системах (34 платформы), включая наиболее распространенные, такие как Linux, FreeBSD, NetBSD, OpenBSD, SunOS, Solaris, DUX, а также под Mac OS X. Начиная с версии 8.X PostgreSQL работает в \"native\" режиме под MS Windows NT, Win2000, WinXP, Win2003. Известно, что есть успешные попытки работать с PostgreSQL под Novell Netware 6 и OS2.</p>\r\n<p>PostgreSQL неоднократно признавалась базой года, например, <a href=\"http://www.linuxnewmedia.de/Award_2004/en\">Linux New Media AWARD 2004</a>, <a href=\"http://linuxjournal.com/article/6995\">2003 Editors\' Choice Awards</a>, <a href=\"http://linuxjournal.com/article/7564\">2004 Editors\' Choice Awards</a>.</p>\r\n<p>PostgreSQL используется как полигон для исследований нового типа баз данных, ориентированных на работу с <strong>потоками данных</strong> - это проект <a href=\"http://telegraph.cs.berkeley.edu/\"><strong>TelegraphCQ</strong></a>, стартовавший в 2002 году в Беркли после успешного проекта <strong>Telegraph</strong> (название главной улицы в Беркли). Интересно, что компания <a href=\"http://www.streambase.com/\">Streambase</a>, которая была основана Майком Стоунбрейкером в 2003 году (изначально \"Grassy Brook\") для коммерческого продвижения этого нового поколения баз данных, никаким образом не ассоциируется с проектом Беркли.</p>',3,'Введение в PostgreSQL',0),(16,'2016-09-14 12:41:54','Резервное копирование и восстановление',1,'Lecture','<h2>Резервное копирование и восстановление</h2>\r\n<p>Операции резервного копирования и восстановления в Oracle можно разделить на три вида:</p>\r\n<p>1. Логическое резервное копирование - производится при помощи входящей в состав Oracle утилиты ехр, которая позволяет экспортиро&shy;вать всю базу, заданные схемы или таблицы. В случае экспорта всей базы выполняется так называемый полный экспорт (при этом экс&shy;портируются все таблицы базы данных) или инкрементный (выгру&shy;жаются таблицы, изменившиеся с момента последнего экспорта). Для Oracle 10g ХЕ, в котором объем базы не превышает 4 Гбайт, можно пользоваться полным экспортом.</p>\r\n<p>2. Физическое резервное копирование - выполняется после установки базы и предполагает копирование файлов данных, управляющих фай&shy;лов, оперативных журналов повтора и файла init.ora с настройками базы.</p>\r\n<p>3. Оперативное резервное копирование - осуществляется в базе, функционирующей в режиме ARCHIVELOG. В этом режиме производит&shy;ся архивация оперативных журналов повтора и ведется журнал всех транзакций.</p>\r\n<p>&nbsp;</p>\r\n<div id=\"ya_direct\">&nbsp;</div>\r\n<p>Для небольших учебных баз данных наиболее простым и на&shy;дежным является полное логическое резервное копирование и фи&shy;зическое резервное копирование. Логическое резервное копирование выполняется при помощи утилиты ехр.ехе, размещенной в папке oraclexe\\app\\oracle\\product\\10.2.0\\server\\BIN\\. Утилита является консольным приложением, получающим параметры через командную строку. Поскольку параметров обычно бывает много (5-10 штук), удоб&shy;но создать профиль с параметрами и затем передать его утилите экспорта при помощи параметра parfile.</p>\r\n<p>Рассмотрим пример типовых профилей. Для начала решим наиболее распространенную задачу &mdash; создание резервной копии одной или несколь&shy;ких схем. В качестве примера рассмотрим копирование схемы STUDENT с учебным примером. Для этого создадим текстовый файл exp_stud.prm, содержащий следующие строки:</p>\r\n<p><strong>USERID = имя/пароль <br />LOG = oralOstud.log FILE = oralOstud.dmp 0WNER= STUDENT</strong></p>\r\n<p>Затем произведем экспорт, выполнив команду ехр parfile=exp_stud.prm, в результате чего будет создан файл ora10stud.dmp, содержащий резервную копию схемы STUDENT. Этот файл имеет бинар&shy;ный формат и очень хорошо сжимается любым архиватором, поэтому для автоматизации процедуры резервного копирования удобно создать ВАТ- файл, содержащий команду экспорта и вызов архиватора для сжатия полученного дампа.</p>\r\n<p>В нашем случае параметр USERID содержит имя и пароль для доступа к базе данных, параметр LOG задает имя файла, в который записывает&shy;ся протокол работы, параметр FILE задает имя файла резервной копии, OWNER &mdash; одна или несколько экспортируемых схем (если указывается несколько схем, то они перечисляются через запятую).</p>\r\n<p>Для выполнения полного экспорта профиль немного изменится:</p>\r\n<p><strong>USERID = имя/пароль <br />LOG = oralOfull.log FILE = oralOfull.dmp FULL = Y</strong></p>\r\n<p>Важным моментом является то, что экспорт конкретной схемы можно выполнять от имени ее владельца, но для полного экспорта необходимо обладать ролью DBA, в противном случае попытка полного экспорта за&shy;вершится ошибкой ЕХР-00023 с сообщением &laquo;Must be a DBA to do Full Database or Tablespace export&raquo;. Размер дампа в случае полного экспорта пустой базы Oracle 10g ХЕ составляет 43 Мбайт (9 Мбайт после сжатия WinRar). Настоятельно рекомендуется выполнять периодическое резерв&shy;ное копирование даже на учебной базе &mdash; известны десятки и сотни случа&shy;ев, когда в ходе изучения Oracle происходит повреждение базы, удаление пользователя или иная операция, приводящая к потере созданных объек&shy;тов.</p>\r\n<p>Логический импорт является зеркальной операцией по отношению к экспорту и выполняется при помощи утилиты IMP. В ходе импорта необя&shy;зательно импортировать всю имеющуюся в дампе информацию &mdash; можно произвести импорт заданных схем или таблиц. Параметры утилиты IMP удобно размещать в профилях, например для импорта схемы STUDENT можно применить профиль следующего вида:</p>\r\n<p><strong>USERID = student/student LOG = oralOstudimp.log FILE = oralOstud.dmp <br />ROWS = Y <br />GRANTS = Y <br />INDEXES = Y <br />FR0MUSER= STUDENT <br />T0USER= STUDENT</strong></p>\r\n<p>Параметр FROMUSER указывает, из каких учетных записей в дампе берется информация, a TOUSER &mdash; в какие учетные записи она импор&shy;тируется. Это очень удобная возможность утилиты импорта, так как она позволяет импортировать данные одной схемы в другую.</p>\r\n<p>Параметры ROWS (строки таблиц), GRANTS (полномочия на объек&shy;ты), INDEXES (индексы) указывают, какие типы объектов импортируют&shy;ся.</p>\r\n<p>Рассмотрим несколько типичных ситуаций, встречающихся на практи&shy;ке:</p>\r\n<p>необходимо импортировать объекты учетной записи STUDENT в учетную запись STUDENT1. В этом случае следует задать параметры FROMUSER=STUDENT и TOUSER= STUDENT1;</p>\r\n<p>Перед импортом необходимо удалить все объекты из схемы, иначе в про&shy;цессе импорта будут выдаваться ошибки IMP-00015 для каждой импор&shy;тируемой таблицы (импорт данных в этом случае не производится). Если по каким-либо причинам необходимо загрузить данные в существующую таблицу, то можно применить параметр IGNORE=Y. что приведет к иг&shy;норированию ошибок при создании объектов и к продолжению импорта данных. Однако в случае применения параметра IGNORE=Y необходимо учитывать, что в таблицах без первичного ключа может возникнуть удво&shy;ение записей (так как каждая операция импорта загружает новые данные, а старые при этом не уничтожаются).</p>\r\n<p>У IMP есть одна интересная функция &mdash; вместо выполнения команд в базе данных эта утилита выводит их в протокол, генерируя тем са&shy;мым скрипты, содержащие DML-операторы. Для включения этой функ&shy;ции необходимо указать параметр SHOW=Y.</p>',4,'Операции резервного копирования и восстановления в Oracle можно разделить на три вида',0),(17,'2016-09-14 13:12:47','Настройка и оптимизация MySQL сервера',1,'Lecture','<p>В этой статье будут описаны различные настройки MySQL, преимущественно те, которые влияют на производительность. Для удобства все переменные разделены по разделам (базовые настройки, ограничения, настройки потоки, кэширование запросов, тайминги, буферы, InnoDB). Сначала уточним имена некоторых переменных, которые изменились в версии 4 MySQL, а в сети продолжают встречаться и старые и новые варианты имен, что вызывает вопросы.<br /><br />Итак, в 4 версии у ряда переменных появилось окончание <code>_size</code>. Это касается переменной&nbsp;<code>thread_cache_size</code> и переменных из раздела <em>Буферы</em>. А переменная&nbsp;<code>read_buffer_size</code> до версии 4 называлась <code>record_buffer</code>. Также переменная&nbsp;<code>skip_external_locking</code> из раздела <em>Базовые настройки</em> до версии 4 называлась <code>skip_locking</code>.<br />Переменные делятся на две основных категории: переменные со значениями и переменные-флаги. Переменные со значениями записываются в конфигурационном файле в виде <code>variable = value</code>, а переменные-флаги просто указываются.&nbsp;Также вы наверное заметили, что в некоторых случаях в названиях переменных используется \"<code>-</code>\", а в некоторых \"<code>_</code>\". Переменные с дефисом являются стартовыми опциями сервера и их нельзя изменить при работе сервера (при помощи SET); переменные с подчеркиванием являются опциями работы сервера и их возможно изменять на лету. Если речь идет о &laquo;переменной состояния&raquo; или рекомендуется наблюдать за значением переменной, название которой записано в виде <code>Variable_Name</code>, то следует выполнять запрос&nbsp;<code>SHOW STATUS LIKE \"Variable_Name\"</code> для получения значения этой переменной, либо заглянуть на вкладку состояние в phpMyAdmin, где дополнительно будут комментарии по значению этой переменной.<br />А теперь займемся описанием переменных и их возможными значениями.<br /><br /></p>\r\n<h4>Базовые настройки</h4>\r\n<p>&nbsp;</p>\r\n<ul>\r\n<li><code><strong>low-priority-updates</strong></code> &mdash; эта опция снижает приоритет операций INSERT/UPDATE по сравнению с SELECT. Актуально, если данные важно быстрее прочитать, чем быстрее записать.</li>\r\n<li><code><strong>skip-external-locking</strong></code> &mdash; опция установлена по умолчанию, начиная с версии 4. Указывает MySQL-серверу не использовать внешние блокировки при работе с базой. Внешние блокировки необходимы в ситуациях, когда несколько серверов работают с одними и теми же файлами данных, т.е. имеют одинаковую&nbsp;<code>datadir</code>, что на практике не используется.</li>\r\n<li><code><strong>skip-name-resolve</strong></code> &mdash; не определять доменные имена для IP-адресов подключающихся клиентов. При этом пользовательские разрешения нужно настраивать не на хосты, а на IP-адреса (за исключением localhost). Если вы соединяетесь с сервером только с локальной машины, то особого значения не имеет. Для внешних соединений ускорит установку соединения.</li>\r\n<li><code><strong>skip-networking</strong></code> &mdash; не использовать сеть, т.е. вообще не обрабатывать TCP/IP соединения. Общение с сервером при этом будет происходить исключительно через сокет. Рекомендуется, если у вас нет ПО, которое использует только TCP/IP для связи с сервером.</li>\r\n</ul>\r\n<p>&nbsp;</p>\r\n<h4>Ограничения</h4>\r\n<p>&nbsp;</p>\r\n<ul>\r\n<li><code><strong>bind-address</strong></code> &mdash; интерфейс, который будет слушать сервер. В целях безопасности рекомендуется установить здесь 127.0.0.1, если вы не используете внешние соединения с сервером.</li>\r\n<li><code><strong>max_allowed_packet</strong></code> &mdash; максимальный размер данных, которые могут быть переданы за один запрос. Следует увеличить, если столкнетесь с ошибкой &laquo;Packet too large&raquo;.</li>\r\n<li><code><strong>max_connections</strong></code> &mdash; максимальное количество параллельных соединений к серверу. Увеличьте его, если сталкиваетесь с проблемой &laquo;Too many connections&raquo;.</li>\r\n<li><code><strong>max_join_size</strong></code> &mdash; запрещает SELECT операторы, которые предположительно будут анализировать более указанного числа строк или больше указанного числа поисков по диску. Используется для защиты от кривых запросов, которые пытаются считать миллионы строк. Значение по умолчанию более 4 миллиардов, поэтому вы скорее всего захотите его значительно уменьшить.</li>\r\n<li><code><strong>max_sort_length</strong></code> &mdash; указывает, сколько байт из начала полей типа BLOB или TEXT использовать при сортировке. Значение по умолчанию 1024, если вы опасаетесь некорректно спроектированных таблиц или запросов, то следует его уменьшить.</li>\r\n</ul>\r\n<p>&nbsp;</p>\r\n<h4>Настройки потоков</h4>\r\n<p>&nbsp;</p>\r\n<ul>\r\n<li><code><strong>thread_cache_size</strong></code> &mdash; указывает число кэшируемых потоков. После обработки запроса сервер не будет завершать поток, а разместит его в кэше, если число потоков, находящих в кэше меньше, чем указанное значение. Значение по умолчанию 0, увеличьте его до 8 или сразу до 16. Если наблюдается рост значения переменной состояния&nbsp;<code>Threads_Created</code>, то следует еще увеличить <code>thread_cache_size</code>.</li>\r\n<li><code><strong>thread_concurrency</strong></code> &mdash; актуально только для Solaris/SunOS вопреки тому, что пишут в сети. &laquo;Подсказывает&raquo; системе сколько потоков запускать одновременно, выполняя вызов функции <em>thr_setconcurrency</em>. Рекомендованное значение &mdash; двойное или утроенное число ядер процессора.</li>\r\n</ul>\r\n<p>&nbsp;</p>\r\n<h4>Кэширование запросов</h4>\r\n<p>&nbsp;</p>\r\n<ul>\r\n<li><code><strong>query_cache_limit</strong></code> &mdash; максимальный размер кэшируемого запроса.</li>\r\n<li><code><strong>query_cache_min_res_unit</strong></code> &mdash; минимальный размер хранимого в кэше блока.</li>\r\n<li><code><strong>query_cache_size</strong></code> &mdash; размер кэша. 0 отключает использование кэша. Для выбора оптимального значения необходимо наблюдать за переменной состояния <code>Qcache_lowmem_prunes</code> и добиться, чтобы ее значение увеличивалось незначительно. Также нужно помнить, что излишне большой кэш будет создавать ненужную нагрузку.</li>\r\n<li><code><strong>query_cache_type</strong></code> &mdash; (OFF, DEMAND, ON). <em>OFF</em> отключает кэширование, <em>DEMAND</em> &ndash;&nbsp;кэширование будет производиться только при наличии директивы&nbsp;<em>SQL_CACHE</em> в запросе, <em>ON</em> включает кэширование.</li>\r\n<li><code><strong>query_cache_wlock_invalidate</strong></code> &mdash; определяет будут ли данные браться из кеша, если таблица, к которым они относятся, заблокирована на чтение.</li>\r\n</ul>\r\n<p><br />Кэш запросов можно представить себе как хэш-массив, ключами которого являются запросы, а значениями &mdash; результаты запросов. Кроме результатов, MySQL хранит в кэше список таблиц, выборка из которых закэширована. Если в любой из таблиц, выборка из которой есть в кэше, проиcходят изменения, то MySQL удаляет из кэша такие выборки. Также&nbsp;MySQL не кеширует запросы, результаты которых могут измениться.<br />При запуске MySQL выделяет блок памяти размером в <code>query_cache_size</code>. При выполнении запроса, как только получены первые строки результата сервер начинает кэшировать их: он выделяет в кэше блок памяти, равный<code>query_cache_min_res_unit</code>, записывает в него результат выборки. Если не вся выборка поместилась в блок, то сервер выделяет следующий блок и так далее.&nbsp;В момент начала записи MySQL не знает о размере получившейся выборки, поэтому если записанный в кэш размер выборки больше, чем <code>query_cache_limit</code>, то запись прекращается и занятое место освобождается, следовательно, если вы знаете наперед, что результат выборки будет большим, стоит выполнять его с директивой <em>SQL_NO_CACHE</em>.<br /><br /></p>\r\n<h4>Тайминги</h4>\r\n<p>&nbsp;</p>\r\n<ul>\r\n<li><code><strong>interactive_timeout</strong></code> &mdash; время&nbsp;в секундах, в течение которого сервер ожидает активности со стороны интерактивного соединения (использующего флаг&nbsp;<em>CLIENT_INTERACTIVE</em>), прежде чем закрыть его.</li>\r\n<li><code><strong>log_slow_queries</strong></code> &mdash; указывает серверу логировать долгие (&laquo;медленные&raquo;) запросы (выполняющиеся дольше<code>long_query_time</code>). В качестве значения передается полное имя файла (например <code>/var/log/slow_queries</code>).</li>\r\n<li><code><strong>long_query_time</strong></code> &mdash; если запрос выполняется дольше указанного времени (в секундах), то он будет считаться &laquo;медленным&raquo;.</li>\r\n<li><code><strong>net_read_timeout</strong></code> &mdash; время в секундах, в течение которого сервер будет ожидать получения данных, прежде чем соединение будет прервано. Если сервер не обслуживает клиентов с очень медленными или нестабильными каналами, то 15 секунд здесь будет достаточно.</li>\r\n<li><code><strong>net_write_timeout</strong></code> &mdash; время в секундах, в течение которого сервер будет ожидать получения данных, прежде чем соединение будет прервано.&nbsp;Если сервер не обслуживает клиентов с очень медленными или нестабильными каналами, то 15 секунд здесь будет достаточно.</li>\r\n<li><code><strong>wait_timeout</strong></code> &mdash; время в секундах, в течение которого сервер ожидает активности соединения, прежде чем прервет его. В общем случае 30 секунд будет достаточно.</li>\r\n</ul>\r\n<p>&nbsp;</p>\r\n<h4>Буферы</h4>\r\n<p><br />У всех буферов есть общая черта&nbsp;&mdash; если из-за установки большого размера буфера данные будут уходить в файл подкачки, то от буфера будет больше вреда, чем пользы. Поэтому всегда ориентируйтесь на доступный вам объем физической ОЗУ.</p>\r\n<ul>\r\n<li><code><strong>key_buffer_size</strong></code> &mdash; размер буфера, выделяемого под индексы и доступного всем потокам. Весьма важная настройка, влияющая на производительность. Значение по умолчанию 8 МБ, его однозначно стоит увеличить.&nbsp;Рекомендуется 15-30% от общего объема ОЗУ, однако нет смысла устанавливать больше, чем общий размер всех .MYI файлов. Наблюдайте за переменными состояния&nbsp;<code>Key_reads</code> и&nbsp;<code>Key_read_requests</code>, отношение&nbsp;<code>Key_reads/Key_read_requests</code> должно быть как можно меньше (&lt; 0,01). Если это отношение велико, то размер буфера стоит увеличить.</li>\r\n<li><code><strong>max_heap_table_size</strong></code> &mdash; максимальный допустимый размер таблицы, хранящейся в памяти (типа MEMORY). Значение по умолчанию 16 МБ, если вы не используете MEMORY таблиц, то установите это значение равным<code>tmp_table_size</code>.</li>\r\n<li><code><strong>myisam_sort_buffer_size</strong></code> &mdash; размер буфера, выделяемого MyISAM для сортировки индексов при <em>REPAIR TABLE</em> или для создания индексов при <em>CREATE INDEX, ALTER TABLE</em>. Значение по умолчанию 8 МБ, его стоит увеличить вплоть до 30-40% ОЗУ. Выигрыш в производительности соответственно будет только при выполнении вышеупомянутых запросов.</li>\r\n<li><code><strong>net_buffer_length</strong></code> &mdash; объем памяти, выделяемый для буфера соединения и для буфера результатов на каждый поток. Буфер соединения будет указанного размера и буфер результатов будет такого же размера, т.е. на каждый поток будет выделен двойной размер <code>net_buffer_length</code>. Указанное значение является начальным и при необходимости буферы будут увеличиваться вплоть до <code>max_allowed_packet</code>. Размер по умолчанию 16 КБ. В случае ограниченной памяти или использования только небольших запросов значение можно уменьшить. В случае же постоянного использования больших запросов и достаточного объема памяти, значение стоит увеличить до предполагаемого среднего размера запроса.</li>\r\n<li><code><strong>read_buffer_size</strong></code> &mdash; каждый поток при последовательном сканировании таблиц выделяет указанный объем памяти для каждой таблицы. Как показывают тесты, это значение не следует особо увеличивать. Размер по умолчанию 128 КБ, попробуйте увеличить его до 256 КБ, а затем до 512 КБ и понаблюдайте за скоростью выполнения запросов типа&nbsp;<code>SELECT COUNT(*) FROM table WHERE expr LIKE \"a%\";</code> на больших таблицах.</li>\r\n<li><code><strong>read_rnd_buffer_size</strong></code> &mdash; актуально для запросов с \"<em>ORDER BY</em>\", т.е. для запросов, результат которых должен быть отсортирован и которые обращаются к таблице, имеющей индексы. Значение по умолчанию 256 КБ, увеличьте его до 1 МБ или выше, если позволяет память. Учтите, что указанное значение памяти также выделяется на каждый поток.</li>\r\n<li><code><strong>sort_buffer_size</strong></code> &mdash; каждый поток, производящий операции сортировки (<em>ORDER BY</em>) или группировки (<em>GROUP BY</em>), выделяет буфер указанного размера. Значение по умолчанию 2 МБ, если вы используете указанные типы запросов и если позволяет память, то значение стоит увеличить. Большое значение переменной состояния&nbsp;<code>Sort_merge_passes</code> указывает на необходимость увеличения <code>sort_buffer_size</code>. Также стоит проверить скорость выполнения запросов вида&nbsp;<code>SELECT *&nbsp;FROM table&nbsp;ORDER BY name&nbsp;DESC</code> на больших таблицах, возможно увеличение буфера лишь замедлит работу (в некоторых тестах это так).</li>\r\n<li><code><strong>table_cache</strong></code> (<code><strong>table_open_cache</strong></code> с версии 5.1.3) &mdash; количество кэшированных открытых таблиц для всех потоков. Открытие файла таблицы может быть достаточно ресурсоемкой операцией, поэтому лучше держать открытые таблицы в кэше. Следует учесть, что каждая запись в этом кэше использует системный дескриптор, поэтому возможно придется увеличивать ограничения на количество дескрипторов (<em>ulimit</em>).&nbsp;Значение по умолчанию 64, его лучше всего увеличить до общего количества таблиц, если их количество в допустимых рамках. Переменная состояния&nbsp;<code>Opened_tables</code> позволяет отслеживать число таблиц, открытых в обход кэша, желательно, чтобы ее значение было как можно ниже.</li>\r\n<li><code><strong>tmp_table_size</strong></code> &mdash; максимальный размер памяти, выделяемой для временных таблиц, создаваемых MySQL для своих внутренних нужд. Это значение также ограничивается переменной&nbsp;<code>max_heap_table_size</code>, поэтому в итоге будет выбрано минимальное значение из&nbsp;<code>max_heap_table_size</code> и <code>tmp_table_size</code>, а остальные временные таблицы будут создаваться на диске. Значение по умолчанию зависит от системы, попробуйте установить его равным 32 МБ и понаблюдать за переменной состояния&nbsp;<code>Created_tmp_disk_tables</code>, ее значение должно быть как можно меньше.</li>\r\n</ul>\r\n<p><br />Значения в конфигурационном файле задаются в байтах, соответственно килобайты и мегабайты нужно переводить в байты.<br /><br /></p>\r\n<h4>&nbsp;</h4>',5,'Настройка и оптимизация MySQL сервера',0);
/*!40000 ALTER TABLE `material` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `program`
--

DROP TABLE IF EXISTS `program`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `program` (
  `program_id` int(11) NOT NULL AUTO_INCREMENT,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `program_name` varchar(100) NOT NULL,
  `program_description` text NOT NULL,
  `program_min_level` int(1) NOT NULL DEFAULT '0',
  `program_level` int(1) NOT NULL,
  `program_state` varchar(10) NOT NULL DEFAULT 'created',
  `program_duration` int(3) NOT NULL,
  `user` int(11) NOT NULL,
  `area` int(11) NOT NULL,
  `program_controled` int(1) NOT NULL DEFAULT '0',
  `program_typ` varchar(10) NOT NULL,
  `program_deleted` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`program_id`),
  KEY `fk_program_user` (`user`),
  KEY `fk_program_area1` (`area`),
  CONSTRAINT `fk_program_area1` FOREIGN KEY (`area`) REFERENCES `area` (`area_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `fk_program_user` FOREIGN KEY (`user`) REFERENCES `user` (`user_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `program`
--

LOCK TABLES `program` WRITE;
/*!40000 ALTER TABLE `program` DISABLE KEYS */;
INSERT INTO `program` VALUES (1,'2016-09-14 06:02:05','Базовый курс по MySQL','Курс знакомит студентов с теоретическими и практическими аспектами использования корпоративных баз данных Oracle и Microsoft SQL Server. Подробное рассматривает вопросы администрирования и управления базами данных. В курсе предусмотрено использование инструментов и языка запросов SQL. Особое внимание уделяется администрированию баз данных . ',0,1,'active',15,3,1,0,'Standart',0),(2,'2016-09-13 11:38:16','Введение в СУБД MySQL: Информация','Курс посвящен системе управления базами данных MySQL. Рассматриваются основы MySQL: запросы, модели баз данных, а также транзакции. На примерах рассмотрен весь спектр вопросов, касающихся языковой структуры, допустимых типов столбцов, операторов, операций и функций, а также существующих расширений MySQL.\r\nКурс рассчитан на разработчиков Web-приложений и администраторов любой квалификации, а также на студентов и преподавателей соответствующих \r\n дисциплин. Рассматриваются основы системы MySQL и языка SQL: от моделей баз данных, до сложных запросов. Курс содержит множество примеров: на практике рассмотрен весь спектр вопросов, касающихся языковой структуры, допустимых типов столбцов, операторов, операций и функций, а также существующих расширений MySQL. Кроме того, рассмотрены вопросы \r\n взаимодействия системы MySql с языками PHP и Perl.',0,1,'active',2,4,1,0,'Standart',0),(3,'2016-09-13 12:14:07','Администрирование PostgreSQL. Базовый курс.','Предварительные знания:\r\n\r\nВладение Unix\r\nМинимальные сведения о базах данных и SQL\r\nКакие навыки будут получены:\r\n\r\nОбщее представление о PostgreSQL и его архитектуре\r\nУстановка базовая настройка, запуск СУБД\r\nУправление пользователями, данными, доступом\r\nБазовые задачи сопровождения и мониторинга\r\nРезервное копирование и восстановление',0,1,'active',3,4,2,0,'Standart',0),(4,'2016-09-13 12:38:46','Oracle 12c. Практикум по резервированию и восстановлению','В курсе подробно рассматриваются вопросы резервирования базы данных, шаги и методы ее восстановления после различных сбоев. Слушатели учатся эффективно управлять памятью и выполнять некоторые задачи по оценке и настройке производительности, в том числе с использованием ряда консультантов. Курсом охвачены все типы технологии Flashback, планирование заданий внутри и вне базы данных, управление системными ресурсами.\r\n\r\nВ ходе обучения рассматриваются следующие вопросы:\r\n\r\nМетоды резервирования и восстановления базы данных Oracle\r\nАрхитектура базы данных Oracle в части, касающейся резервирования и восстановления\r\nЭффективные процедуры резервирования и восстановления\r\nКонфигурирование базы данных для восстановления\r\nИспользование Recovery Manager (RMAN) для выполнения резервирования и восстановления\r\nИспользование консультанта по восстановлению данных для диагностики и устранения сбоев\r\nИспользование технологии Flashback для восстановления после ошибок, вызванных \"человеческим фактором\"\r\nВыполнение резервирования и восстановления с использованием шифрованных резервных копий\r\nВыполнение восстановления табличного пространства к моменту времени\r\nДополнительные возможности достижения высокой доступности (такие, как Oracle Data Guard)',0,1,'active',3,4,3,0,'Standart',0),(5,'2016-09-12 13:08:12','Оптимизация производительности MySQL','Курс охватывает различные аспекты оптимизации производительности MySQL. Вы научитесь повышать производительность серверов и приложений своей компании под руководством специалиста.\r\n\r\nПредварительная подготовка:\r\nПредполагается, что участник курса умеет подключаться к серверу MySQL, знаком с синтаксисом запросов SELECT, INSERT, UPDATE, ALTER TABLE и CREATE TABLE, может построить составной запрос с использованием JOIN, имеет базовые навыки работы в Unix-shell.',1,2,'active',2,4,1,0,'Standart',0);
/*!40000 ALTER TABLE `program` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `schedule_has_material`
--

DROP TABLE IF EXISTS `schedule_has_material`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `schedule_has_material` (
  `material` int(11) NOT NULL,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `course` int(11) NOT NULL,
  `date_time` datetime NOT NULL,
  `schedule_has_material_deleted` int(1) DEFAULT '0',
  PRIMARY KEY (`material`,`course`),
  KEY `fk_material_has_schedule_schedule1` (`course`),
  CONSTRAINT `fk_material_has_schedule_material1` FOREIGN KEY (`material`) REFERENCES `material` (`material_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `fk_material_has_schedule_schedule1` FOREIGN KEY (`course`) REFERENCES `course` (`course_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `schedule_has_material`
--

LOCK TABLES `schedule_has_material` WRITE;
/*!40000 ALTER TABLE `schedule_has_material` DISABLE KEYS */;
INSERT INTO `schedule_has_material` VALUES (1,'2016-09-14 14:03:57',1,'2016-09-15 00:00:00',0),(1,'2016-09-14 14:05:52',2,'2016-09-15 00:00:00',0),(1,'2016-09-14 14:07:02',3,'2016-09-15 00:00:00',0),(1,'2016-09-15 03:54:05',4,'2016-09-16 00:00:00',0),(2,'2016-09-14 14:03:57',1,'2016-09-16 00:00:00',0),(2,'2016-09-14 14:05:52',2,'2016-09-16 00:00:00',0),(2,'2016-09-14 14:07:02',3,'2016-09-16 00:00:00',0),(2,'2016-09-15 03:54:05',4,'2016-09-17 00:00:00',0),(3,'2016-09-14 14:03:57',1,'2016-09-17 00:00:00',0),(3,'2016-09-14 14:05:52',2,'2016-09-17 00:00:00',0),(3,'2016-09-14 14:07:02',3,'2016-09-17 00:00:00',0),(3,'2016-09-15 03:54:05',4,'2016-09-18 00:00:00',0),(4,'2016-09-14 14:03:57',1,'2016-09-18 00:00:00',0),(4,'2016-09-14 14:05:52',2,'2016-09-18 00:00:00',0),(4,'2016-09-14 14:07:02',3,'2016-09-18 00:00:00',0),(4,'2016-09-15 03:54:05',4,'2016-09-19 00:00:00',0),(5,'2016-09-14 14:03:57',1,'2016-09-19 00:00:00',0),(5,'2016-09-14 14:05:52',2,'2016-09-19 00:00:00',0),(5,'2016-09-14 14:07:02',3,'2016-09-19 00:00:00',0),(5,'2016-09-15 03:54:05',4,'2016-09-20 00:00:00',0),(6,'2016-09-14 14:03:57',1,'2016-09-20 00:00:00',0),(6,'2016-09-14 14:05:52',2,'2016-09-20 00:00:00',0),(6,'2016-09-14 14:07:02',3,'2016-09-20 00:00:00',0),(6,'2016-09-15 03:54:05',4,'2016-09-21 00:00:00',0),(7,'2016-09-14 14:03:57',1,'2016-09-21 00:00:00',0),(7,'2016-09-14 14:05:52',2,'2016-09-21 00:00:00',0),(7,'2016-09-14 14:07:02',3,'2016-09-21 00:00:00',0),(7,'2016-09-15 03:54:05',4,'2016-09-22 00:00:00',0),(8,'2016-09-14 14:03:57',1,'2016-09-22 00:00:00',0),(8,'2016-09-14 14:05:52',2,'2016-09-22 00:00:00',0),(8,'2016-09-14 14:07:02',3,'2016-09-22 00:00:00',0),(8,'2016-09-15 03:54:05',4,'2016-09-23 00:00:00',0),(9,'2016-09-14 14:03:57',1,'2016-09-23 00:00:00',0),(9,'2016-09-14 14:05:52',2,'2016-09-23 00:00:00',0),(9,'2016-09-14 14:07:02',3,'2016-09-23 00:00:00',0),(9,'2016-09-15 03:54:05',4,'2016-09-24 00:00:00',0),(10,'2016-09-14 14:03:57',1,'2016-09-24 00:00:00',0),(10,'2016-09-14 14:05:52',2,'2016-09-24 00:00:00',0),(10,'2016-09-14 14:07:02',3,'2016-09-24 00:00:00',0),(10,'2016-09-15 03:54:05',4,'2016-09-25 00:00:00',0),(11,'2016-09-14 14:03:57',1,'2016-09-25 00:00:00',0),(11,'2016-09-14 14:05:52',2,'2016-09-25 00:00:00',0),(11,'2016-09-14 14:07:03',3,'2016-09-25 00:00:00',0),(11,'2016-09-15 03:54:05',4,'2016-09-26 00:00:00',0),(12,'2016-09-14 14:03:57',1,'2016-09-26 00:00:00',0),(12,'2016-09-14 14:05:52',2,'2016-09-26 00:00:00',0),(12,'2016-09-14 14:07:03',3,'2016-09-26 00:00:00',0),(12,'2016-09-15 03:54:05',4,'2016-09-27 00:00:00',0),(13,'2016-09-14 14:03:57',1,'2016-09-27 00:00:00',0),(13,'2016-09-14 14:05:52',2,'2016-09-27 00:00:00',0),(13,'2016-09-14 14:07:03',3,'2016-09-27 00:00:00',0),(13,'2016-09-15 03:54:05',4,'2016-09-28 00:00:00',0);
/*!40000 ALTER TABLE `schedule_has_material` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `schedule_has_task`
--

DROP TABLE IF EXISTS `schedule_has_task`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `schedule_has_task` (
  `task` int(11) NOT NULL,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `course` int(11) NOT NULL,
  `date_time` datetime NOT NULL,
  `schedule_has_task_deleted` int(1) DEFAULT '0',
  PRIMARY KEY (`task`,`course`),
  KEY `fk_task_has_schedule_schedule1` (`course`),
  CONSTRAINT `fk_task_has_schedule_schedule1` FOREIGN KEY (`course`) REFERENCES `course` (`course_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `fk_task_has_schedule_task1` FOREIGN KEY (`task`) REFERENCES `task` (`task_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `schedule_has_task`
--

LOCK TABLES `schedule_has_task` WRITE;
/*!40000 ALTER TABLE `schedule_has_task` DISABLE KEYS */;
INSERT INTO `schedule_has_task` VALUES (1,'2016-09-14 14:03:57',1,'2016-09-16 00:00:00',0),(1,'2016-09-14 14:05:52',2,'2016-09-16 00:00:00',0),(1,'2016-09-14 14:07:03',3,'2016-09-16 00:00:00',0),(1,'2016-09-15 03:54:05',4,'2016-09-17 00:00:00',0),(2,'2016-09-14 14:03:57',1,'2016-09-18 00:00:00',0),(2,'2016-09-14 14:05:52',2,'2016-09-18 00:00:00',0),(2,'2016-09-14 14:07:03',3,'2016-09-18 00:00:00',0),(2,'2016-09-15 03:54:05',4,'2016-09-19 00:00:00',0),(3,'2016-09-14 14:03:58',1,'2016-09-20 00:00:00',0),(3,'2016-09-14 14:05:52',2,'2016-09-20 00:00:00',0),(3,'2016-09-14 14:07:03',3,'2016-09-20 00:00:00',0),(3,'2016-09-15 03:54:05',4,'2016-09-21 00:00:00',0),(4,'2016-09-14 14:03:58',1,'2016-09-24 00:00:00',0),(4,'2016-09-14 14:05:52',2,'2016-09-24 00:00:00',0),(4,'2016-09-14 14:07:03',3,'2016-09-24 00:00:00',0),(4,'2016-09-15 03:54:05',4,'2016-09-25 00:00:00',0),(5,'2016-09-14 14:03:58',1,'2016-09-25 00:00:00',0),(5,'2016-09-14 14:05:53',2,'2016-09-25 00:00:00',0),(5,'2016-09-14 14:07:03',3,'2016-09-25 00:00:00',0),(5,'2016-09-15 03:54:06',4,'2016-09-26 00:00:00',0);
/*!40000 ALTER TABLE `schedule_has_task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `schedule_has_test`
--

DROP TABLE IF EXISTS `schedule_has_test`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `schedule_has_test` (
  `course` int(11) NOT NULL,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `test` int(11) NOT NULL,
  `date_time` datetime NOT NULL,
  `schedule_has_test_deleted` int(1) DEFAULT '0',
  PRIMARY KEY (`course`,`test`),
  KEY `fk_schedule_has_test_test1` (`test`),
  CONSTRAINT `fk_schedule_has_test_schedule1` FOREIGN KEY (`course`) REFERENCES `course` (`course_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `fk_schedule_has_test_test1` FOREIGN KEY (`test`) REFERENCES `test` (`test_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `schedule_has_test`
--

LOCK TABLES `schedule_has_test` WRITE;
/*!40000 ALTER TABLE `schedule_has_test` DISABLE KEYS */;
INSERT INTO `schedule_has_test` VALUES (1,'2016-09-14 14:03:57',1,'2016-09-29 00:00:00',0),(1,'2016-09-14 14:03:57',2,'2016-09-21 00:00:00',0),(2,'2016-09-14 14:05:52',1,'2016-09-29 00:00:00',0),(2,'2016-09-14 14:05:52',2,'2016-09-21 00:00:00',0),(3,'2016-09-14 14:07:03',1,'2016-09-29 00:00:00',0),(3,'2016-09-14 14:07:03',2,'2016-09-21 00:00:00',0),(4,'2016-09-15 03:54:05',1,'2016-09-30 00:00:00',0),(4,'2016-09-15 03:54:05',2,'2016-09-22 00:00:00',0);
/*!40000 ALTER TABLE `schedule_has_test` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_conf`
--

DROP TABLE IF EXISTS `sys_conf`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_conf` (
  `name` varchar(25) NOT NULL,
  `value` varchar(225) NOT NULL,
  PRIMARY KEY (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_conf`
--

LOCK TABLES `sys_conf` WRITE;
/*!40000 ALTER TABLE `sys_conf` DISABLE KEYS */;
INSERT INTO `sys_conf` VALUES ('FileDir','uploadFiles/'),('LogPath','/home/ksinn/Log.txt'),('RealPath','/srv/tomcat8/webapps/elearning/');
/*!40000 ALTER TABLE `sys_conf` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `task`
--

DROP TABLE IF EXISTS `task`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `task` (
  `task_id` int(11) NOT NULL AUTO_INCREMENT,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `task_name` varchar(45) NOT NULL,
  `task_day` int(3) NOT NULL,
  `task_type` varchar(10) NOT NULL,
  `task_text` text NOT NULL,
  `program` int(11) NOT NULL,
  `task_db_index` varchar(45) NOT NULL,
  `task_answer` text NOT NULL,
  `task_ball` int(11) NOT NULL,
  `task_time` int(11) NOT NULL,
  `task_deleted` int(1) NOT NULL DEFAULT '0',
  `task_inventory` text NOT NULL,
  PRIMARY KEY (`task_id`),
  KEY `fk_task_program1` (`program`),
  CONSTRAINT `fk_task_program1` FOREIGN KEY (`program`) REFERENCES `program` (`program_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `task`
--

LOCK TABLES `task` WRITE;
/*!40000 ALTER TABLE `task` DISABLE KEYS */;
INSERT INTO `task` VALUES (1,'2016-09-14 09:13:49','Выборка',2,'row','<p>Описание таблицы:</p>\r\n<p>CREATE TABLE Product (</p>\r\n<p>maker varchar (10) NOT NULL ,</p>\r\n<p>model varchar (50) NOT NULL ,</p>\r\n<p>type varchar (50) NOT NULL,</p>\r\n<p>CONSTRAINT PK_product PRIMARY KEY ( model )</p>\r\n<p>);</p>\r\n<p>Покажите все продукты</p>',1,'none','SELECT * FROM 1_product;',1,1,0,'Задание на простую выборку'),(2,'2016-09-14 09:31:22','Выборка 2',4,'row','<p>Описание таблицы:</p>\r\n<p style=\"padding-left: 30px;\">CREATE TABLE 1_Product (</p>\r\n<p style=\"padding-left: 30px;\">maker varchar (10) NOT NULL ,</p>\r\n<p style=\"padding-left: 30px;\">model varchar (50) NOT NULL ,</p>\r\n<p style=\"padding-left: 30px;\">type varchar (50) NOT NULL,</p>\r\n<p style=\"padding-left: 30px;\">CONSTRAINT PK_product PRIMARY KEY ( model )</p>\r\n<p style=\"padding-left: 30px;\">);</p>\r\n<p style=\"padding-left: 30px;\">&nbsp;</p>\r\n<p>Покажите все модели&nbsp;продуктов типа pc отсортированные по производителя в алфавитном порядке</p>',1,'none','select model from 1_product where type=\'pc\' order by maker;',1,2,0,'Задание на выборку данных с условием'),(3,'2016-09-14 11:40:02','Обьединение',6,'row','<p>Описание таблиц:</p>\r\n<p>CREATE TABLE 1_PC (<br /> code int NOT NULL ,<br /> model varchar (50) NOT NULL ,<br /> speed smallint NOT NULL ,<br /> ram smallint NOT NULL ,<br /> hd real NOT NULL ,<br /> cd varchar (10) NOT NULL ,<br /> price decimal(12,2) NULL,<br />CONSTRAINT PK_pc PRIMARY KEY(code),<br />CONSTRAINT FK_pc_product FOREIGN KEY (model) REFERENCES 1_Product (model)<br />);</p>\r\n<p><br />CREATE TABLE 1_Product (<br /> maker varchar (10) NOT NULL ,<br /> model varchar (50) NOT NULL ,<br /> type varchar (50) NOT NULL,<br />CONSTRAINT PK_product PRIMARY KEY (model)<br />);</p>\r\n<p>&nbsp;</p>\r\n<p>Выведете производителя, тип, скорость и оперативную память всех продуктов из таблицы pc</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>',1,'none','select maker, type, speed, ram from 1_pc join 1_product on 1_pc.model = 1_product.model',2,5,0,'Задание на объединение нескольких таблиц'),(4,'2016-09-14 13:43:51','Книжное дело. Выбор',10,'row','<p><img src=\"https://drive.i-cloud.uz/index.php/apps/files_sharing/ajax/publicpreview.php?x=1301&amp;y=255&amp;a=true&amp;file=%25D0%25A1%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25BE%25D0%25BA%2520%25D1%258D%25D0%25BA%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B0%2520%25D0%25BE%25D1%2582%25202016-09-14%252017%253A47%253A50.png&amp;t=WbQBXJqfYcvPJrx&amp;scalingup=0\" alt=\"\" width=\"547\" height=\"255\" /></p>\r\n<p>&nbsp;</p>\r\n<p>Выбрать коды авторов (поле Code_author), имена авторов (поле&nbsp;Name_author), названия соответствующих книг (поле Title_book), если код&nbsp;&nbsp;находится в диапазоне от 10 до 25 и&nbsp;количество страниц (поле Pages) в книге больше 120.</p>',1,'none','select 1_books.code_author, 1_authors.name_author, 1_books.title_book from 1_authors join \r\n((1_books join 1_purchases on 1_books.code_book = 1_purchases.code_book) \r\njoin 1_publishing_house on 1_books.code_publish = 1_publishing_house.code_publish)\r\non 1_authors.code_author = 1_books.code_author \r\nwhere (1_books.code_publish between 2 and 4) and pages>120;',5,10,0,'Выбор записей по нескольким условиям'),(5,'2016-09-14 13:49:30','Книжное дело. Агрегатные функций',11,'row','<p><img src=\"https://drive.i-cloud.uz/index.php/apps/files_sharing/ajax/publicpreview.php?x=1301&amp;y=255&amp;a=true&amp;file=%25D0%25A1%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25BE%25D0%25BA%2520%25D1%258D%25D0%25BA%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B0%2520%25D0%25BE%25D1%2582%25202016-09-14%252017%253A47%253A50.png&amp;t=WbQBXJqfYcvPJrx&amp;scalingup=0\" alt=\"\" width=\"547\" height=\"255\" /></p>\r\n<p>Префикс таблиц \"1_\"</p>\r\n<p>Вывести общую сумму поставок книг (использовать поле Cost),&nbsp;выполненных &lsquo;Мир книг&rsquo; (условие по полю Name_company).</p>',1,'none','select sum(cost * amount) from 1_deliveries join 1_purchases on 1_deliveries.code_delivery = 1_purchases.code_delivery \r\nwhere name_company = \'Мир книг\';',5,10,0,'Вычисление итоговых значений с использованием агрегатных функций');
/*!40000 ALTER TABLE `task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `test`
--

DROP TABLE IF EXISTS `test`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `test` (
  `test_id` int(11) NOT NULL AUTO_INCREMENT,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `test_name` varchar(50) NOT NULL,
  `test_day` int(3) NOT NULL,
  `test_time` int(5) NOT NULL,
  `test_text` text NOT NULL,
  `program` int(11) NOT NULL,
  `test_deleted` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`test_id`),
  KEY `fk_test_program1` (`program`),
  CONSTRAINT `fk_test_program1` FOREIGN KEY (`program`) REFERENCES `program` (`program_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `test`
--

LOCK TABLES `test` WRITE;
/*!40000 ALTER TABLE `test` DISABLE KEYS */;
INSERT INTO `test` VALUES (1,'2016-09-14 06:02:05','Exam',15,30,'Required final exam for the program Базовый курс по MySQL',1,0),(2,'2016-09-14 07:19:06','Тест_1',7,10,'Мини-тест для проверки усвояемости материала',1,0),(3,'2016-09-14 11:38:16','Exam',2,60,'Required final exam for the program Введение в СУБД MySQL: Информация',2,0),(4,'2016-09-14 12:14:07','Exam',3,60,'Required final exam for the program Администрирование PostgreSQL. Базовый курс.',3,0),(5,'2016-09-14 12:38:46','Exam',3,60,'Required final exam for the program Oracle 12c. Практикум по резервированию и восстановлению',4,0),(6,'2016-09-14 13:08:12','Exam',2,60,'Required final exam for the program Оптимизация производительности MySQL',5,0);
/*!40000 ALTER TABLE `test` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Temporary table structure for view `test_result`
--

DROP TABLE IF EXISTS `test_result`;
/*!50001 DROP VIEW IF EXISTS `test_result`*/;
SET @saved_cs_client     = @@character_set_client;
SET character_set_client = utf8;
/*!50001 CREATE TABLE `test_result` (
  `user` tinyint NOT NULL,
  `test` tinyint NOT NULL,
  `ball` tinyint NOT NULL,
  `max` tinyint NOT NULL
) ENGINE=MyISAM */;
SET character_set_client = @saved_cs_client;

--
-- Table structure for table `test_task`
--

DROP TABLE IF EXISTS `test_task`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `test_task` (
  `test_task_id` int(11) NOT NULL AUTO_INCREMENT,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `test_task_text` varchar(200) NOT NULL,
  `test_task_answer` varchar(200) NOT NULL,
  `test_task_v1` varchar(200) NOT NULL,
  `test_task_v2` varchar(200) NOT NULL,
  `test_task_v3` varchar(200) NOT NULL,
  `test_task_v4` varchar(200) NOT NULL,
  `test_task_ball` int(3) NOT NULL DEFAULT '0',
  `test_task_deleted` int(1) NOT NULL DEFAULT '0',
  `test` int(11) NOT NULL,
  PRIMARY KEY (`test_task_id`),
  KEY `fk_test_task_test1` (`test`),
  CONSTRAINT `fk_test_task_test1` FOREIGN KEY (`test`) REFERENCES `test` (`test_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `test_task`
--

LOCK TABLES `test_task` WRITE;
/*!40000 ALTER TABLE `test_task` DISABLE KEYS */;
INSERT INTO `test_task` VALUES (1,'2016-09-14 06:55:23','Дайте определение базе данных','Структурированная совокупность данных, хранимых в соответствии с определенной схемой данных','Представление фактов и идей в формализованном виде, пригодном для передачи и обработки.','Множество значений, набор операций, которые можно применять к таким значениям, и, возможно, способ реализации хранения значений и выполнения операций','комплекс средств для создание структур данных','Множество значений',1,0,1),(2,'2016-09-14 06:57:19','Как называется комплекс языковых и программных средств, предназначенный для создания, ведения и совместного использования БД многими пользователями?','Система Управления Базами Данных','База данных','Словарь данных','Вычислительная система','Приложение',1,0,1),(3,'2016-09-14 06:58:19','Что помогает управлять файлами','файловая система','каталоги','роли пользователей','имена файлов','база данных',1,0,1),(4,'2016-09-14 07:01:04','Администратор базы данных','Специалист, имеющий полное представление об одной или нескольких базах данных, занимающийся проектированием и контролирующий использование этих баз данных','Специалист, имеющий полное представление об одной или нескольких базах данных, занимающийся обслуживанием этих баз данных','Специалист, имеющий полное представление об одной или нескольких базах данных, занимающийся техническим обслуживанием этих баз данных','Специалист, имеющий полное представление об одной или нескольких базах данных, занимающийся обслуживанием этих баз данных в сети','Специалист ИТ',1,0,1),(5,'2016-09-14 07:07:10','Какую проблему файловых систем решают современные СУБД','многопользовательский доступ ','удобство отображеня','сортировка данных.','Формировать данных','безопасность',1,0,1),(6,'2016-09-14 07:07:45','Назовите уровень абстракции в СУБД, близкий к пользователям','внешний','концептуальный','внутренний','физический','программный',1,0,1),(7,'2016-09-14 07:08:20','Назовите вариант ответа, который не является уровнем архитектуры СУБД','физический','внешний','концептуальный','внутренний','программный',2,0,1),(8,'2016-09-14 07:08:53','Назовите уровень абстракции в СУБД, показывающий все логическую структуру базы данных','концептуальный','внешний','внутренний','физический','программный',4,0,1),(9,'2016-09-14 07:09:43','Что не относится к функциям СУБД','сокращение избыточности данных','обработка данных','безопасность и целостность данных','востановление и дублирование данных','безопасность ос',2,0,1),(10,'2016-09-14 07:11:09','Что включает в себя система баз данных.','данные, аппаратное обеспечение, программное обеспечение, пользователи','Данные и пользователей','аппаратное обеспечение и пользователей','программное обеспечение и  пользователей','данные',1,0,1),(11,'2016-09-14 07:12:03','Назовите уровень абстрации в СУБД, близкий к физическому хранению информации','внутренний','концептуальный','внешний','физический','программный',1,0,1),(12,'2016-09-14 07:13:15','Система искусственного интеллекта, включающая знания об определенной слабо структурированной и трудно формализуемой узкой предметной области называется','экспертной системой','информационной системой','продукционной моделью','Модел данных','базой данных',2,0,1),(13,'2016-09-14 07:15:13','Укажите что не является классификацией баз данных','по скорости обработки информации','по моделям представления данных','по организации храннения данных и обращения к ним','по типу хранимой информации','по обращению к данным',2,0,1),(14,'2016-09-14 07:16:41','В каком варианте представлена классификация по типу хранимой информации','документальные, фактографические, лексикографические','иерархические, сетевые, реляционные, объектно-ориентированные','локальные, сетевые, распределенные','правильная классификация не указана','медленная, быстрая, сверхбыстрая',2,0,1),(15,'2016-09-14 07:17:22','В каком варианте представлена классификация по моделям представления данных','иерархические, сетевые, реляционные, объектно-ориентированные','локальные, сетевые, распределенные','документальные, фактографические, лексикографические','правильная классификация не указана','нормированная и не нормированная',2,0,1),(16,'2016-09-14 07:20:31','В каком варианте представлена классификация по организации хранения данных и обращения к ним','локальные, сетевые, распределенные','документальные, фактографические, лексикографические','иерархические, сетевые, реляционные, объектно-ориентированные','правильная классификация не указана','текстовые, табличные',1,0,2),(17,'2016-09-14 07:21:06','Реляционная модель представления данных - данные для пользователя передаются в виде','таблиц','списков','графа типа дерева','произвольного графа','очередь',2,0,2),(18,'2016-09-14 07:21:52','Что такое модель представления данных','Логическая структура данных, хранимых в базе данных','Физическая структура данных, хранимых в базе данных','Иерархическая структура данных','Сетевая структура данных','рисунок таблицы',1,0,2),(19,'2016-09-14 07:22:34','Какая модель представления данных является самой распространенной','реляционная','сетевая','объектно-ориентированная','иерархическая','файловая',2,0,2),(20,'2016-09-14 07:23:08','Иерархическая модель представления данных - данные представлены в виде','графа типа дерева','произвольного графа','списков','таблиц','очередь',1,0,2),(21,'2016-09-14 11:58:55','Какой вариант кода создает таблицу с одной колонкой строкового типа?','create table tests ( test_id varchar(10) not null );','create table tests ( test_id int primary key );','create table tests ( test_id unsigned varchar(10) primary key );','create table tests ( test_id varchar(10) auto_increment );','create table tests ( test_id varchar(10) is not null primary key );',1,0,3),(22,'2016-09-14 12:01:21','Какой тип не является символьным типом?','VARCHAR','Datetime','integer','boolean','double',1,0,3),(23,'2016-09-14 12:26:36','У любого столбца в таблице есть значение по умолчанию.','Для указания значения по умолчанию всегда необходимо использовать ключевое слово DEFAULT','Значение по умолчанию есть только у числовых типов и равно нулю','Значение по умолчанию есть только у строковых типов и равно пустой строке','Значение по умолчанию есть только у строковых типов и равно NULL','Да должно быть',1,0,4),(24,'2016-09-14 12:44:07','Каким способом можно создать новую базу animals?','create new database animals;','create database if not exists;','create animals as database;','create schema animals;','create schema database;',1,0,5),(25,'2016-09-14 13:17:19','Что произойдет после выполнения такого запроса? UPDATE tbl SET visible =   ( SELECT !visible as visible  FROM tbl  WHERE id = 2 )  WHERE id = 2','Поле visible примет значение 1','Запрос проигнорируется','Значение поля visible инвертируется','Запрос не выполнится и будет возвращена ошибка','Поле visible примет значение 2',1,0,6);
/*!40000 ALTER TABLE `test_task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user` (
  `user_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(32) NOT NULL,
  `user_surname` varchar(32) NOT NULL,
  `birthday` date NOT NULL,
  `gender` char(1) NOT NULL,
  `user_mail` varchar(45) NOT NULL,
  `passwords` varchar(45) NOT NULL,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `user_deleted` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `user_mail` (`user_mail`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES (1,'Kseniya','Andreeva','1994-03-09','w','ksinn@mail.ru','qwerty','2016-09-08 11:25:55',0),(2,'Vataliy','Pak','1986-05-18','m','vitalik.pak@gmail.com','qwerty','2016-08-27 08:48:00',0),(3,'Nata','Kim','1993-08-24','w','kim@mail.ru','qwerty','2016-08-27 08:54:43',0),(4,'Жавлонбой','Обидов','1993-04-09','m','javlonboy09@gmail.com','qwerty','2016-08-31 06:32:34',0),(5,'Джавлон','Обидов','1993-05-09','m','4javlonboy09@gmail.com','qwerty','2015-08-24 06:32:34',0),(6,'Alisher','Kayumov','1994-03-09','m','ksinn1@mail.ru','qwerty','2015-09-01 13:31:26',0),(7,'Наталья','Шивцова','1994-03-09','w','ksinn2@mail.ru','qwerty','2015-09-01 13:31:26',0),(8,'Бобур','Джураев','1994-03-09','m','ksinn3@mail.ru','qwerty','2015-09-01 13:31:26',0),(9,'Азизa','Хакимовa','1994-03-09','w','ksinn4@mail.ru','qwerty','2015-09-01 13:31:26',0),(10,'Гияс','Мухомедов','1994-03-09','m','ksinn5@mail.ru','qwerty','2015-09-01 13:31:26',0),(11,'Парвина','Азизова','1994-03-09','w','ksinn6@mail.ru','qwerty','2015-09-01 13:31:26',0),(12,'Дима','Бавент','1994-03-09','m','ksinn7@mail.ru','qwerty','2015-09-01 13:31:26',0),(13,'Ихтиерa','Нерматовa','1994-03-09','w','ksinn8@mail.ru','qwerty','2015-09-01 13:31:26',0),(14,'Фахридина','Мирзаирова','1994-03-09','w','ksinn9@mail.ru','qwerty','2015-09-01 13:31:26',0),(15,'Шохрух','Комолов','1994-03-09','m','ksinn10@mail.ru','qwerty','2015-09-01 13:31:26',0),(16,'Анвар','Ашерматов','1994-03-09','m','ksinn11@mail.ru','qwerty','2015-09-01 13:31:26',0),(17,'Атоджон','Атоев','1994-03-09','m','ksinn12@mail.ru','qwerty','2015-09-01 13:31:26',0),(18,'Эдуард','Маер','1994-03-09','m','ksinn13@mail.ru','qwerty','2015-09-01 13:31:26',0),(19,'Мохинабону','Нуридинова','1994-03-09','w','ksinn14@mail.ru','qwerty','2015-09-01 13:31:26',0),(20,'Дамир','Зияддинов','1994-03-09','m','ksinn15@mail.ru','qwerty','2015-09-01 13:31:26',0),(21,' Гарик','Азимбеков','2016-02-19','m','phontom@mail.ru','qwerty','2016-09-15 16:14:28',0);
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_has_course`
--

DROP TABLE IF EXISTS `user_has_course`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user_has_course` (
  `user` int(11) NOT NULL,
  `addDate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `course` int(11) NOT NULL,
  `user_has_course_datetime` datetime NOT NULL,
  `user_has_course_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_has_course_deleted` int(11) NOT NULL DEFAULT '0',
  `user_has_course_complited` datetime DEFAULT NULL,
  PRIMARY KEY (`user_has_course_id`),
  UNIQUE KEY `user` (`user`,`course`),
  KEY `fk_user_has_course_course1` (`course`),
  CONSTRAINT `fk_user_has_course_course1` FOREIGN KEY (`course`) REFERENCES `course` (`course_id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `fk_user_has_course_user1` FOREIGN KEY (`user`) REFERENCES `user` (`user_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_has_course`
--

LOCK TABLES `user_has_course` WRITE;
/*!40000 ALTER TABLE `user_has_course` DISABLE KEYS */;
INSERT INTO `user_has_course` VALUES (4,'2016-09-14 14:03:58',1,'2016-09-14 19:03:58',1,0,NULL),(2,'2016-09-14 14:05:53',2,'2016-09-14 19:05:53',2,0,NULL),(6,'2016-09-14 14:07:03',3,'2016-09-14 19:07:03',3,0,NULL),(7,'2016-09-15 03:54:06',4,'2016-09-15 08:54:06',4,0,NULL);
/*!40000 ALTER TABLE `user_has_course` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Final view structure for view `test_result`
--

/*!50001 DROP TABLE IF EXISTS `test_result`*/;
/*!50001 DROP VIEW IF EXISTS `test_result`*/;
/*!50001 SET @saved_cs_client          = @@character_set_client */;
/*!50001 SET @saved_cs_results         = @@character_set_results */;
/*!50001 SET @saved_col_connection     = @@collation_connection */;
/*!50001 SET character_set_client      = utf8 */;
/*!50001 SET character_set_results     = utf8 */;
/*!50001 SET collation_connection      = utf8_general_ci */;
/*!50001 CREATE ALGORITHM=UNDEFINED */
/*!50013 DEFINER=`root`@`localhost` SQL SECURITY DEFINER */
/*!50001 VIEW `test_result` AS select (select `user_has_course`.`user` from `user_has_course` where (`user_has_course`.`user_has_course_id` = `accept_test`.`user_has_course`)) AS `user`,`accept_test`.`test` AS `test`,max(`accept_test`.`accept_test_ball`) AS `ball`,(select sum(`test_task`.`test_task_ball`) from `test_task` where ((`test_task`.`test` = `accept_test`.`test`) and (`test_task`.`test_task_deleted` = 0))) AS `max` from `accept_test` group by (select `user_has_course`.`user` from `user_has_course` where (`user_has_course`.`user_has_course_id` = `accept_test`.`user_has_course`)),`accept_test`.`test` */;
/*!50001 SET character_set_client      = @saved_cs_client */;
/*!50001 SET character_set_results     = @saved_cs_results */;
/*!50001 SET collation_connection      = @saved_col_connection */;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2016-09-15 22:55:48

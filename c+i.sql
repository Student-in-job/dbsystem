drop database elearning;
create schema if not exists elearning default character set utf8 collate utf8_general_ci ;
use elearning;

create table if not exists sys_conf (
name varchar(25) not null,
value varchar(225) not null,
primary key(name)
);

create table if not exists user (
  user_id int(11) not null auto_increment,
  user_name varchar(20) not null,
  user_surname varchar(20) not null,
  birthday date not null,
  gender char(1) not null,
  user_mail varchar(45) not null,
  passwords varchar(45) not null,
  date_reg date not null,
  user_deleted int(1) not null default 0,
  primary key (user_id),
  unique (user_mail)
);

create table if not exists area (
  area_id int(11) not null auto_increment,
  area_name varchar(45) not null,
  area_img varchar(255) not null,
  area_deleted int(1) not null default 0,
  primary key (area_id));

create table if not exists program (
  program_id int(11) not null auto_increment,
  program_name varchar(45) not null,
  program_description text(2000) not null,
  program_min_level int(1) not null default 0,
  program_level int(1) not null,
  program_state varchar(10) not null default 'created',
  program_duration int(3) not null,
  user int(11) not null,
  area int(11) not null,
  program_date date not null,
  program_controled int(1) not null default 0,
  program_typ varchar(10) not null,
  program_deleted int(1) not null default 0,
  primary key (program_id),
  constraint fk_program_user  foreign key (user) references user (user_id) on delete no action on update no action,
  constraint fk_program_area1 foreign key (area) references area (area_id) on delete no action on update no action);

create table if not exists material (
  material_id int(11) not null auto_increment,
  material_name varchar(200) not null,
  material_day int(3) not null,
  material_type varchar(10) not null,
  material_file text,
  program int(11) not null,
  material_text text(200) not null,
  material_deleted int(1) not null default 0,
  primary key (material_id),
  constraint fk_material_program1 foreign key (program) references program (program_id) on delete no action on update no action
);

create table if not exists files (
  files_id int(11) not null auto_increment,
  files_name varchar(100) not null,
  material int(11) not null,
  files_type varchar(10),
  files_deleted int(1) not null default 0,
  primary key (files_id),
  constraint fk_files_program1 foreign key (material) references material (material_id) on delete no action on update no action

);

create table if not exists task (
  task_id int(11) not null auto_increment,
  task_name varchar(45) not null,
  task_day int(3) not null,
  task_type varchar(10) not null,
  task_text text(2000) not null,
  program int(11) not null,
  task_db_index varchar(45) not null,
  task_answer varchar(200) not null,
  task_ball int(11) not null,
  primary key (task_id),
  constraint fk_task_program1 foreign key (program) references program (program_id) on delete no action on update no action
);

create table if not exists course (
  course_id int(11) not null auto_increment,
  course_date date not null,
  program int(11) not null,
  course_public varchar(45) not null,
  course_deleted int(11) not null default 0,
  primary key (course_id),
  constraint fk_course_program1 foreign key (program) references program (program_id) on delete no action on update no action
);

create table if not exists user_has_course (
  user int(11) not null,
  course int(11) not null,
  user_has_course_datetime datetime not null,
  user_has_course_id int(11) not null auto_increment,
  user_has_course_deleted int(11) not null default 0,
  primary key (user_has_course_id),
  unique(user, course),
  constraint fk_user_has_course_user1  foreign key (user) references user (user_id) on delete no action on update no action,
  constraint fk_user_has_course_course1 foreign key (course) references course (course_id) on delete no action on update no action
);

create table if not exists accept_task (
  accept_id int(11) not null auto_increment,
  accept_datetime datetime not null,
  user_has_course int(11) not null,
  task int(11) not null,
  accept_state varchar(10) not null,
  primary key (accept_id),
  constraint fk_mark_user_has_course1  foreign key (user_has_course)  references user_has_course (user_has_course_id)    on delete no action    on update no action,
  constraint fk_mark_task1  foreign key (task)  references task (task_id)    on delete no action    on update no action
);

create table if not exists externe (
  externe_id int(11) not null auto_increment,
  user int(11) not null,
  program int(11) not null,
  externe_datetime datetime not null,
  primary key (externe_id),
  constraint fk_externe_user1  foreign key (user)  references user (user_id)    on delete no action    on update no action,
  constraint fk_externe_program1  foreign key (program)  references program (program_id)    on delete no action    on update no action);

create table if not exists comments (
  comment_id int(11) not null auto_increment,
  comment_text text(2000) not null,
  user int(11) not null,
  course int(11) not null,
  commen_datetime datetime not null,
  commen_deleted int(1) not null default 0,
  primary key (comment_id),
  constraint fk_comment_user1  foreign key (user)  references user (user_id)    on delete no action    on update no action,
  constraint fk_comment_course1  foreign key (course)  references course (course_id)    on delete no action    on update no action);

/*create table if not exists schedules (
  schedules_id int(11) not null auto_increment,
  course int(11) not null,
  schedules_deleted int(1) not null default 0,
  primary key (schedules_id),
  constraint fk_schedule_course1  foreign key (course)  references course (course_id)    on delete no action    on update no action);*/


create table if not exists schedule_has_material (
  material int(11) not null,
  course int(11) not null,
  date_time datetime not null,
  schedule_has_material_deleted int (1) default 0,
  primary key (material, course),
  constraint fk_material_has_schedule_material1  foreign key (material)  references material (material_id)    on delete no action    on update no action,
  constraint fk_material_has_schedule_schedule1  foreign key (course)  references course (course_id)    on delete no action    on update no action);

create table if not exists schedule_has_task (
  task int(11) not null,
  course int(11) not null,
  date_time datetime not null,
  schedule_has_tsak_deleted int(1) default 0,
  primary key (task, course),
  constraint fk_task_has_schedule_task1  foreign key (task)  references task (task_id)    on delete no action    on update no action,
  constraint fk_task_has_schedule_schedule1  foreign key (course)  references course (course_id)    on delete no action    on update no action);

create table if not exists test (
  test_id int(11) not null auto_increment,
  test_name varchar(45) not null,
  test_day int(3) not null,
  test_text text not null,
  program int(11) not null,
  test_deleted int(1) not null default 0,
  primary key (test_id),
  constraint fk_test_program1  foreign key (program)  references program (program_id)    on delete no action    on update no action);

create table if not exists test_task (
  test_task_id int(11) not null auto_increment,
  test_task_no int(3) not null,
  test_task_text varchar(200) not null,
  test_task_answer varchar(100) not null,
  test_task_v1 varchar(100) not null,
  test_task_v2 varchar(100) not null,
  test_task_v3 varchar(100) not null,
  test_task_v4 varchar(100) not null,
  test_task_ball int(3) not null default 0,
  test_task_deleted int(1) not null default 0,
  test int(11) not null,
  primary key (test_task_id),
  constraint fk_test_task_test1  foreign key (test)  references test (test_id)    on delete no action    on update no action);

create table if not exists schedule_has_test (
  course int(11) not null,
  test int(11) not null,
  date_time datetime not null,
  schedule_has_test_deleted int(1) default 0,
  primary key (course, test),
  constraint fk_schedule_has_test_schedule1  foreign key (course)  references course (course_id)    on delete no action    on update no action,
  constraint fk_schedule_has_test_test1  foreign key (test)  references test (test_id)    on delete no action    on update no action);

create table if not exists accept_test (
  accept_test_id int(11) not null auto_increment,
  accept_test_date datetime not null,
  accept_test_ball int(11) null default null,
  user_has_course int(11) not null,
  test int(11) not null,
  accept_test_deleted int(1) default 0,
  primary key (accept_test_id),
  constraint fk_accept_test_user_has_course1  foreign key (user_has_course)  references user_has_course (user_has_course_id)    on delete no action    on update no action,
  constraint fk_accept_test_task1  foreign key (test)  references test (test_id)    on delete no action    on update no action);

create table if not exists externe_has_test (
  externe int(11) not null,
  test int(11) not null,
  externe_has_test_datetime datetime not null,
  externe_has_test_ball int(11) not null,
  primary key (externe, test),
  constraint fk_externe_has_test1_externe1  foreign key (externe)  references externe (externe_id)    on delete no action    on update no action,
  constraint fk_externe_has_test1_test1  foreign key (test)  references test (test_id)    on delete no action    on update no action);

create table if not exists externe_has_task (
  externe int(11) not null,
  task int(11) not null,
  externe_has_task_datetime datetime not null,
  externe_has_task_accept varchar(10) not null,
  primary key (externe, task),
  constraint fk_externe_has_task_externe1  foreign key (externe)  references externe (externe_id)    on delete no action    on update no action,
  constraint fk_externe_has_task_task1  foreign key (task)  references task (task_id)    on delete no action    on update no action);









INSERT INTO user(user_name, user_surname, birthday, gender, user_mail, passwords, date_reg, user_deleted) VALUES 
('Kseniya','Andreeva','1994-03-09','w','ksinn@mail.ru','qwerty','2016-07-15',0),
('Student','First','1994-03-09','w','ksinnd@mail.ru','qwerty','2016-07-15',0); 


INSERT INTO area(area_name) VALUES 
('MySQL'),
('MariaDB'); 


INSERT INTO program(program_name, program_description, program_min_level, program_level, program_state, program_duration, user, area, program_date, program_controled, program_typ, program_deleted) VALUES 
('DML and DDL','Data Definition Language (DDL) statements are used to define the database structure or schema. Data Manipulation Language (DML) statements are used for managing data within schema objects.',0,1,'created',5,1,1,'2016-07-15',0,'Mini',0),
('Введение в реляционные базы данных','В курсе излагаются основные понятия и методы организации реляционных баз данных и манипулирования ими, а также описываются базовые подходы к проектированию реляционных баз данных. Вводится понятие реляционной модели данных, обсуждаются структурная, манипуляционная и целостная составляющие модели. Обсуждаются важные аспекты теории баз данных, связанные с функциональными зависимостями. Описываются процесс проектирования реляционных баз данных на основе принципов нормализации, а также подходы к проектированию реляционных баз данных с использованием диаграммных семантических моделей данных. В первой, вводной лекции обосновывается потребность в технологии баз данных и обсуждаются основные функции СУБД. В лекции 2 предлагается общее введение в реляционную модель данных. Вводятся основные термины, обсуждаются структурная и целостная части модели. Лекции 3-5 посвящаются манипуляционной части реляционной модели данных. В лекции 3 описываются классический вариант реляционной алгебры, восходящий к основоположнику реляционного подхода Эдгару Кодду, а в лекции 4 – современная версия алгебры Криса Дейта и Хью Дарвена. В лекции 5 обсуждаются две разновидности реляционных исчислений – исчисления кортежей и доменов. В лекции 6 приводятся основные определения, утверждения и теоремы теории реляционных баз данных, связанные с функциональными зависимостями. В лекции 7 рассматриваются фундаментальные методы проектирования реляционных баз данных путем нормализации отношений на основе учета функциональных зависимостей, а лекция 8 посвящена методам дальнейшей нормализации реляционных баз данных с принятием во внимание и многозначных зависимостей и зависимостей проекции/соединения. Наконец, материал лекций 9-10 посвящен более практическим методам проектирования реляционных баз данных с использованием семантических моделей данных. Мы ограничиваемся двумя разновидностями диаграммных семантических моделей, а именно диаграммами “сущность/связь”, введенными в обиход Питером Ченом, и диаграммами классов языка UML. Вводятся основные понятия этих моделей и обсуждаются методы перехода от концептуальных схем баз данных, представленных в терминах диаграммных моделей, к реляционным схемам баз данных.',0,1,'active',20,1,1,'2016-07-20',0,'Mini',0); 


INSERT INTO material(material_name, material_day, material_type, material_file, program, material_text, material_deleted) VALUES 
('What are the difference between DDL and DML commands?',1,'lecture','<h3>DDL</h3> <p> Data Definition Language (DDL) statements are used to define the database structure or schema. Some examples: CREATE - to create objects in the database ALTER - alters the structure of the database DROP - delete objects from the database TRUNCATE - remove all records from a table, including all spaces allocated for the records are removed COMMENT - add comments to the data dictionary RENAME - rename an object </p> <h3>DML</h3> <p> Data Manipulation Language (DML) statements are used for managing data within schema objects. Some examples: SELECT - retrieve data from the a database INSERT - insert data into a table UPDATE - updates existing data within a table DELETE - deletes all records from a table, the space for the records remain MERGE - UPSERT operation (insert or update) CALL - call a PL/SQL or Java subprogram EXPLAIN PLAN - explain access path to data LOCK TABLE - control concurrency </p> <h3>DCL</h3> <p> Data Control Language (DCL) statements. Some examples: GRANT - gives user\'s access privileges to database REVOKE - withdraw access privileges given with the GRANT command </p> <h3>TCL</h3> <p> Transaction Control (TCL) statements are used to manage the changes made by DML statements. It allows statements to be grouped together into logical transactions. COMMIT - save work done SAVEPOINT - identify a point in a transaction to which you can later roll back ROLLBACK - restore database to original since the last COMMIT SET TRANSACTION - Change transaction options like isolation level and what rollback segment to use</p>',1,'What are the difference between DDL, DML and DCL commands?',0), 
('Лекция 1: Эволюция устройств внешней памяти и программных систем управления данными',1,'Lecture','<h3>Устройства внешней памяти</h3> <p id=\"id_1\"><a name=\"keyword-context1\"></a>В самом широком смысле <span class=\"keyword_def\"><a name=\"keyword1\"></a><span class=\"keyword\">информационная система</span></span> представляет собой программный комплекс, функции которого состоят в поддержке надежного хранения информации в памяти компьютера, выполнении специфических для данного приложения преобразований информации и/или вычислений, предоставлении пользователям удобного и легко осваиваемого интерфейса. Обычно объемы данных, с которыми приходится иметь дело таким системам, достаточно велики, а сами данные обладают достаточно сложной структурой. Классическими примерами<a name=\"keyword2\"></a><span class=\"keyword\">информационных систем</span> являются банковские системы, системы резервирования авиационных или железнодорожных билетов, мест в гостиницах и т. д.</p> <div id=\"mark_1\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_2\">О надежном и долговременном хранении информации можно говорить только при наличии запоминающих устройств, сохраняющих информацию после выключения электропитания. Оперативная (основная) <a name=\"keyword3\"></a><span class=\"keyword\">память</span> этим свойством обычно не обладает. В первые десятилетия развития вычислительной техники использовались два вида <a name=\"keyword4\"></a><span class=\"keyword\">устройств внешней памяти</span>: магнитные ленты и магнитные барабаны. При этом емкость магнитных лент была достаточно велика, но <a name=\"keyword5\"></a><span class=\"keyword\">по</span> своей природе они обеспечивали последовательный <a name=\"keyword6\"></a><span class=\"keyword\">доступ</span> к данным. Емкость магнитной ленты пропорциональна ее длине. Чтобы получить <a name=\"keyword7\"></a><span class=\"keyword\">доступ</span> к требуемой порции данных, нужно в среднем перемотать половину ее длины. Но чисто механическую операцию перемотки нельзя выполнить очень быстро. Поэтому быстрый произвольный <a name=\"keyword8\"></a><span class=\"keyword\">доступ</span> к данным на магнитной ленте, очевидно, невозможен.</p> <div id=\"mark_2\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_3\">Магнитный барабан представлял собой массивный металлический цилиндр с намагниченной внешней поверхностью и неподвижным пакетом магнитных головок. Такие устройства обеспечивали возможность достаточно быстрого произвольного доступа к данным, но позволяли сохранять сравнительно небольшой объем данных. Быстрый произвольный <a name=\"keyword9\"></a><span class=\"keyword\">доступ</span> осуществлялся благодаря высокой скорости вращения барабана и наличию отдельной головки на каждую дорожку магнитной поверхности; ограниченность объема была обусловлена наличием всего одной магнитной поверхности.</p> <div id=\"mark_3\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_4\">Указанные ограничения не очень существенны для систем численных расчетов. Обсудим более подробно, какие реальные потребности возникают у разработчиков систем численных расчетов. Прежде всего, для получения требуемых результатов серьезные вычислительные программы должны проработать достаточно долгое время (недели, месяцы и даже, может быть, годы). Наличие гарантий надежности со стороны производителей аппаратных компьютерных средств не избавляет программистов от необходимости использования программного сохранения <a name=\"keyword10\"></a><span class=\"keyword\">частичных результатов</span> вычислений, чтобы при возникновении непредвиденных сбоев аппаратуры можно было продолжить выполнение расчетов с некоторой контрольной точки. Для сохранения промежуточных результатов идеально подходят магнитные ленты: при выполнении процедуры установки контрольной точки данные последовательно сбрасываются на ленту, а при необходимости перезапуска от сохраненной контрольной точки данные также последовательно с ленты считываются.</p> <div id=\"mark_4\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_5\">Вторая традиционная потребность численных программистов &ndash; максимально большой объем оперативной памяти. Большая <a name=\"keyword11\"></a><span class=\"keyword\">оперативная память</span> требуется, во-первых, для того, чтобы обеспечить программе быстрый <a name=\"keyword12\"></a><span class=\"keyword\">доступ</span> к большому количеству обрабатываемых данных. Во-вторых, сложные вычислительные программы сами могут иметь большой объем. Поскольку объем реально доступной в ЭВМ оперативной памяти всегда являлся недостаточным для удовлетворения текущих потребностей вычислений, требовалась быстрая <a name=\"keyword13\"></a><span class=\"keyword\">внешняя память</span> для организации оверлеев и/или виртуальной памяти. Мы не будем здесь вдаваться в детали организации этих механизмов программного расширения оперативной памяти, но заметим, что для этого идеально подходили магнитные барабаны. Они обеспечивают быстрый <a name=\"keyword14\"></a><span class=\"keyword\">доступ</span> к<a name=\"keyword15\"></a><span class=\"keyword\">внешней памяти</span>, а для расширения оперативной памяти одной программы (сложные вычислительные программы, как правило, выполняются на компьютере в одиночку) большой объем <a name=\"keyword16\"></a><span class=\"keyword\">внешней памяти</span> не требуется.</p> <div id=\"mark_5\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_6\">Далее заметим, что, даже если <a name=\"keyword17\"></a><span class=\"keyword\">программа</span> должна обработать (или произвести) большой объем информации, при программировании можно продумать расположение этой информации во <a name=\"keyword18\"></a><span class=\"keyword\">внешней памяти</span>, чтобы <a name=\"keyword19\"></a><span class=\"keyword\">программа</span> работала как можно быстрее. Развитая <a name=\"keyword20\"></a><span class=\"keyword\">поддержка</span> работы с<a name=\"keyword21\"></a><span class=\"keyword\">внешней памятью</span> со стороны общесистемных программных средств не обязательна, а иногда и вредна, поскольку приводит к дополнительным накладным расходам аппаратных ресурсов.</p> <div id=\"mark_6\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_7\">Однако для <a name=\"keyword22\"></a><span class=\"keyword\">информационных систем</span>, в которых объем постоянно хранимых данных определяется спецификой бизнес-приложения, а потребность в текущих данных определяется пользователем приложения, одних только магнитных барабанов и лент недостаточно. Емкость магнитного барабана просто не позволяет долговременно хранить данные большого объема. Что же касается лент, то представьте себе состояние человека, который, стоя у билетной кассы, должен дождаться полной перемотки магнитной ленты. Естественным требованием к таким системам является обеспечение высокой средней скорости выполнения операций при наличии больших объемов данных.</p> <div id=\"mark_7\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_8\">Именно требования к <a name=\"keyword23\"></a><span class=\"keyword\">устройствам внешней памяти</span> со стороны бизнес-приложений вызвали появление <a name=\"keyword24\"></a><span class=\"keyword\">устройств внешней памяти</span> со съемными пакетами <a name=\"keyword25\"></a><span class=\"keyword\">магнитных дисков</span> и подвижными головками чтения/записи, что явилось революцией в истории вычислительной техники. Эти <a name=\"keyword26\"></a><span class=\"keyword\">устройства памяти</span> обладали существенно большей емкостью, чем магнитные барабаны (за счет наличия нескольких магнитных поверхностей), обеспечивали удовлетворительную скорость доступа к данным в режиме произвольной выборки, а возможность смены дискового пакета на <a name=\"keyword27\"></a><span class=\"keyword\">устройстве</span> позволяла иметь <a name=\"keyword28\"></a><span class=\"keyword\">архив</span> данных практически неограниченного объема.</p> <div id=\"mark_8\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_9\"><a name=\"keyword-context2\"></a><span class=\"keyword_def\"><a name=\"keyword29\"></a><span class=\"keyword\">Магнитные диски</span></span> представляют собой пакеты магнитных пластин (поверхностей), между которыми на одном рычаге двигается пакет магнитных головок (<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27901?page=1#image.1.1\">рис. 1.1</a>). Шаг движения пакета головок является дискретным, и каждому положению пакета головок логически соответствует цилиндр пакета <a name=\"keyword30\"></a><span class=\"keyword\">магнитных дисков</span>. На каждой поверхности цилиндр \"высекает\" дорожку, так что каждая поверхность содержит число дорожек, равное числу цилиндров. При разметке <a name=\"keyword31\"></a><span class=\"keyword\">магнитного диска</span> (специальном действии, предшествующем использованию диска) каждая дорожка размечается на одно и то же количество блоков; таким образом, предельная емкость каждого блока составляет одно и то же число байтов. Для произведения обмена с <a name=\"keyword32\"></a><span class=\"keyword\">магнитным диском</span> на уровне аппаратуры нужно указать номер цилиндра, номер поверхности, номер блока на соответствующей дорожке и число байтов, которое нужно записать или прочитать от начала этого блока.</p> <div id=\"mark_9\" class=\"lecture_mark\">&nbsp;</div> <div id=\"id_10\"><a name=\"image.1.1\"></a> <div><img src=\"http://www.intuit.ru/EDI/14_02_16_4/1455402139-23616/tutorial/157/objects/1/files/1_1.gif\" alt=\"Грубая схема дискового устройства памяти с подвижными головками\" /></div> <br /><strong>Рис. 1.1. </strong>Грубая схема дискового устройства памяти с подвижными головками</div> <div id=\"mark_10\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_11\">При выполнении обмена с диском аппаратура выполняет три основных действия: подвод головок к нужному цилиндру (обозначим <a name=\"keyword33\"></a><span class=\"keyword\">время выполнения</span> этого действия как <span class=\"texample\">t<sub>пг</sub></span> ), <a name=\"keyword34\"></a><span class=\"keyword\">поиск</span> на дорожке нужного блока (<a name=\"keyword35\"></a><span class=\"keyword\">время выполнения</span> &ndash; <span class=\"texample\">t<sub>пб</sub></span> ) и собственно обмен с этим блоком (<a name=\"keyword36\"></a><span class=\"keyword\">время выполнения</span> &ndash; <span class=\"texample\">t<sub>об</sub></span> ). Тогда, как правило, <span class=\"texample\">t<sub>пг</sub>&gt;&gt;t<sub>пб</sub>&gt;&gt;t<sub>об</sub>,</span> потому что подвод головок &ndash; это механическое действие, причем в среднем нужно переместить головки на <a name=\"keyword37\"></a><span class=\"keyword\">расстояние</span>, равное половине радиуса поверхности, а скорость передвижения головок не может быть слишком большой <a name=\"keyword38\"></a><span class=\"keyword\">по</span> физическим соображениям. <a name=\"keyword39\"></a><span class=\"keyword\">Поиск</span> блока на дорожке требует прокручивания пакета <a name=\"keyword40\"></a><span class=\"keyword\">магнитных дисков</span> в среднем на половину длины внешней окружности; скорость вращения диска может быть существенно больше скорости движения головок, но она тоже ограничена законами физики. Для выполнения же обмена нужно прокрутить пакет дисков всего лишь на угловое <a name=\"keyword41\"></a><span class=\"keyword\">расстояние</span>, соответствующее размеру блока. Таким образом, из всех этих действий в среднем наибольшее время занимает первое, и поэтому существенный выигрыш в суммарном времени обмена при считывании или записи только части блока получить практически невозможно.</p> <div id=\"mark_11\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_16\">С появлением <a name=\"keyword42\"></a><span class=\"keyword\">магнитных дисков</span> началась история систем управления данными во <a name=\"keyword43\"></a><span class=\"keyword\">внешней памяти</span>. До этого каждая <a name=\"keyword44\"></a><span class=\"keyword\">прикладная программа</span>, которой требовалось хранить данные во <a name=\"keyword45\"></a><span class=\"keyword\">внешней памяти</span>, сама определяла расположение каждой порции данных на магнитной ленте или барабане и выполняла обмены между оперативной и <a name=\"keyword46\"></a><span class=\"keyword\">внешней памятью</span> с помощью программно-аппаратных средств низкого уровня (машинных команд или вызовов соответствующих программ операционной системы). Такой режим работы не позволял или очень затруднял поддержание на одном внешнем носителе нескольких архивов долговременно хранимой информации. Кроме того, каждой прикладной программе приходилось решать проблемы именования частей данных и структуризации данных во <a name=\"keyword47\"></a><span class=\"keyword\">внешней памяти</span>.</p>',2,'В этой вводной лекции мы, прежде всего, обсудим предпосылки появления в компьютерах устройств внешней памяти, а также обоснуем принципиальную важность дисковых устройств с подвижными магнитными головками для организации информационных систем. Далее будут рассмотрены особенности организации и основное функциональное назначение одного из ключевых компонентов современных операционных систем – систем управления файлами. Наконец, в третьем разделе лекции мы покажем, почему возможностей файловых систем недостаточно для создания информационных программных систем. Будет продемонстрировано, что естественные требования информационных систем к средствам управления данными во внешней памяти приводят к необходимости наличия систем управления базами данных (СУБД). В ходе этого анализа будут определены основные черты, которыми должны обладать СУБД.',0), 
('Лекция 2: Введение в реляционную модель данных',2,'Lecture','<h3>Основные понятия реляционных баз данных</h3> <p id=\"id_1\">Выделим следующие основные понятия <a name=\"keyword1\"></a><span class=\"keyword\">реляционных баз данных</span>: <a name=\"keyword2\"></a><span class=\"keyword\">тип данных</span>, <a name=\"keyword3\"></a><span class=\"keyword\">домен</span>, <a name=\"keyword4\"></a><span class=\"keyword\">атрибут</span>, <a name=\"keyword5\"></a><span class=\"keyword\">кортеж</span>, <a name=\"keyword6\"></a><span class=\"keyword\">отношение</span>, <a name=\"keyword7\"></a><span class=\"keyword\">первичный ключ</span>.</p> <div id=\"mark_1\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_2\">Для начала покажем смысл этих понятий на примере <a name=\"keyword8\"></a><span class=\"keyword\">отношения</span> СЛУЖАЩИЕ, содержащего информацию о служащих некоторого предприятия (<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>).</p> <div id=\"mark_2\" class=\"lecture_mark\">&nbsp;</div> <div id=\"id_3\"><a name=\"image.2.1\"></a> <div><img src=\"http://www.intuit.ru/EDI/14_02_16_4/1455402139-23616/tutorial/157/objects/2/files/2_1.gif\" alt=\"Соотношение основных понятий реляционного подхода\" /></div> <br /><strong>Рис. 2.1. </strong>Соотношение основных понятий реляционного подхода</div> <div id=\"mark_3\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect2\"></a></h3> <h4>Тип данных</h4> <p id=\"id_4\">Значения данных, хранимые в <a name=\"keyword9\"></a><span class=\"keyword\">реляционной базе данных</span>, являются типизированными, т. е. известен тип каждого хранимого значения. Понятие<a name=\"keyword10\"></a><span class=\"keyword\">типа данных</span> в <a name=\"keyword11\"></a><span class=\"keyword\">реляционной модели данных</span> полностью соответствует понятию <a name=\"keyword12\"></a><span class=\"keyword\">типа данных</span> в языках программирования. <a name=\"keyword-context1\"></a>Напомним, что традиционное (нестрогое) определение <span class=\"keyword_def\"><a name=\"keyword13\"></a><span class=\"keyword\">типа данных</span></span> состоит из трех основных компонентов: определение множества значений данного типа; определение набора операций, применимых к значениям типа; определение способа внешнего представления значений типа (литералов).</p> <div id=\"mark_4\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_5\">Обычно в современных <a name=\"keyword14\"></a><span class=\"keyword\">реляционных базах данных</span> допускается хранение символьных, числовых данных (точных и приблизительных), специализированных числовых данных (таких, как \"деньги\"), а также специальных \"темпоральных\" данных (дата, время, временной интервал). Кроме того, в реляционных системах поддерживается возможность определения пользователями собственных <a name=\"keyword15\"></a><span class=\"keyword\">типов данных</span> (более подробно мы обсудим это в лекции 9, курса \"Введение в модель данных SQL\").</p> <div id=\"mark_5\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_6\">В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> мы имеем дело с данными трех <a name=\"keyword16\"></a><span class=\"keyword\">типов</span>: строки символов, целые числа и \"деньги\".</p> <div id=\"mark_6\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect3\"></a></h3> <h4>Домен</h4> <p id=\"id_7\">Понятие <a name=\"keyword17\"></a><span class=\"keyword\">домена</span> более специфично для баз данных, хотя и имеются аналогии с подтипами в некоторых языках программирования (более того, в своем <strong>\"Третьем манифесте\"</strong> Кристофер Дейт и Хью Дарвен вообще ликвидируют различие между <a name=\"keyword18\"></a><span class=\"keyword\">доменом</span> и <a name=\"keyword19\"></a><span class=\"keyword\">типом данных</span> ). В общем виде<a name=\"keyword20\"></a><span class=\"keyword\">домен</span> определяется путем задания некоторого базового <a name=\"keyword21\"></a><span class=\"keyword\">типа данных</span>, к которому относятся элементы <a name=\"keyword22\"></a><span class=\"keyword\">домена</span>, и произвольного логического выражения, применяемого к элементу этого <a name=\"keyword23\"></a><span class=\"keyword\">типа данных</span> ( <span class=\"keyword_def\"><a name=\"keyword24\"></a><span class=\"keyword\">ограничения домена</span></span> ). Элемент данных является элементом <a name=\"keyword25\"></a><span class=\"keyword\">домена</span> в том и только в том случае, если вычисление этого логического выражения дает результат <strong>истина</strong> (для логических значений мы будем попеременно использовать обозначения <strong>истина</strong> и <strong>ложь</strong> или <strong>true</strong> и <strong>false</strong> ). С каждым <a name=\"keyword26\"></a><span class=\"keyword\">доменом</span> связывается имя, уникальное среди имен всех <a name=\"keyword27\"></a><span class=\"keyword\">доменов</span>соответствующей базы данных.</p> <div id=\"mark_7\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_8\"><a name=\"keyword-context3\"></a>Наиболее правильной интуитивной трактовкой понятия <span class=\"keyword_def\"><a name=\"keyword28\"></a><span class=\"keyword\">домена</span></span> является его восприятие как допустимого потенциального, ограниченного подмножества значений данного типа. Например, <a name=\"keyword29\"></a><span class=\"keyword\">домен</span> <span class=\"texample\">ИМЕНА</span> в нашем примере определен на базовом <a name=\"keyword30\"></a><span class=\"keyword\">типе символьных строк</span>, но в число его значений могут входить только те строки, которые могут представлять имена (в частности, для возможности представления русских имен такие строки не могут начинаться с мягкого или твердого знака и не могут быть длиннее, например, 20 символов). Если некоторый <a name=\"keyword31\"></a><span class=\"keyword\">атрибут</span><a name=\"keyword32\"></a><span class=\"keyword\">отношения</span> определяется на некотором <a name=\"keyword33\"></a><span class=\"keyword\">домене</span> (как, например, на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword34\"></a><span class=\"keyword\">атрибут</span> <span class=\"texample\">СЛУ_ИМЯ</span> определяется на <a name=\"keyword35\"></a><span class=\"keyword\">домене</span> <span class=\"texample\">ИМЕНА</span> ), то в дальнейшем <a name=\"keyword36\"></a><span class=\"keyword\">ограничение домена</span> играет роль <a name=\"keyword37\"></a><span class=\"keyword\">ограничения целостности</span>, накладываемого на значения этого <a name=\"keyword38\"></a><span class=\"keyword\">атрибута</span>.</p> <div id=\"mark_8\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_12\">Следует отметить также семантическую нагрузку понятия <a name=\"keyword39\"></a><span class=\"keyword\">домена</span>: данные считаются сравнимыми только в том случае, когда они относятся к одному <a name=\"keyword40\"></a><span class=\"keyword\">домену</span>. В нашем примере значения <a name=\"keyword41\"></a><span class=\"keyword\">доменов</span> <span class=\"texample\">НОМЕРА ПРОПУСКОВ</span> и <span class=\"texample\">НОМЕРА ОТДЕЛОВ</span> относятся к типу целых чисел, но не являются сравнимыми (допускать их сравнение было бы бессмысленно).</p> <div id=\"mark_12\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect4\"></a></h3> <h4>Заголовок отношения, кортеж, тело отношения, значение отношения, переменная отношения</h4> <p id=\"id_15\">Понятие <a name=\"keyword42\"></a><span class=\"keyword\">отношения</span> является наиболее фундаментальным в <a name=\"keyword43\"></a><span class=\"keyword\">реляционном подходе к организации баз данных</span>, поскольку <span class=\"texample\">n</span> -арное<a name=\"keyword44\"></a><span class=\"keyword\">отношение</span> является единственной родовой структурой данных, хранящихся в <a name=\"keyword45\"></a><span class=\"keyword\">реляционной базе данных</span>. Это отражено и в общем названии<a name=\"keyword46\"></a><span class=\"keyword\">подхода</span> &ndash; термин <strong>реляционный (relational)</strong> происходит от <strong>relation (отношение)</strong>. Однако сам термин <a name=\"keyword47\"></a><span class=\"keyword\">отношение</span> является исключительно неточным, поскольку, говоря про любые сохраняемые данные, мы должны иметь в виду <strong>тип</strong> этих данных, <strong>значения</strong> этого <a name=\"keyword48\"></a><span class=\"keyword\">типа</span> и <strong>переменные</strong>, в которых сохраняются значения. Соответственно, для уточнения термина <a name=\"keyword49\"></a><span class=\"keyword\">отношение</span> выделяются понятия <a name=\"keyword50\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword51\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword52\"></a><span class=\"keyword\">переменной отношения</span>. Кроме того, нам потребуется вспомогательное понятие <a name=\"keyword53\"></a><span class=\"keyword\">кортежа</span>.</p> <div id=\"mark_15\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_17\"><a name=\"keyword-context4\"></a>Итак, <span class=\"keyword_def\"><a name=\"keyword54\"></a><span class=\"keyword\">заголовком (или схемой) отношения</span></span> <span class=\"texample\">r</span> ( <span class=\"texample\">Hr</span> ) называется конечное множество упорядоченных пар вида <span class=\"texample\">&lt;A, T&gt;</span>, где <span class=\"texample\">A</span>называется именем <a name=\"keyword55\"></a><span class=\"keyword\">атрибута</span>, а <span class=\"texample\">T</span> обозначает имя некоторого базового <a name=\"keyword56\"></a><span class=\"keyword\">типа</span> или ранее определенного <a name=\"keyword57\"></a><span class=\"keyword\">домена</span> . По определению требуется, чтобы все имена <a name=\"keyword58\"></a><span class=\"keyword\">атрибутов</span> в <a name=\"keyword59\"></a><span class=\"keyword\">заголовке отношения</span> были различны. В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword60\"></a><span class=\"keyword\">заголовком отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> является множество пар <span class=\"texample\">{&lt;слу_номер, номера_пропусков&gt;, &lt;слу_имя, имена&gt;, &lt;слу_зарп, размеры_выплат&gt;, &lt;слу_отд_номер, номера_отделов&gt;}</span>.</p> <div id=\"mark_17\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_25\">Если все <a name=\"keyword61\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword62\"></a><span class=\"keyword\">заголовка отношения</span> определены на разных <a name=\"keyword63\"></a><span class=\"keyword\">доменах</span>, то, чтобы не плодить лишних имен, разумно использовать для именования <a name=\"keyword64\"></a><span class=\"keyword\">атрибутов</span> имена соответствующих <a name=\"keyword65\"></a><span class=\"keyword\">доменов</span> (не забывая, конечно, о том, что это всего лишь удобный способ именования, который не устраняет различия между понятиями <a name=\"keyword66\"></a><span class=\"keyword\">домена</span> и <a name=\"keyword67\"></a><span class=\"keyword\">атрибута</span> ).</p> <div id=\"mark_25\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_26\"><a name=\"keyword-context5\"></a><span class=\"keyword_def\"><a name=\"keyword68\"></a><span class=\"keyword\">Кортежем</span></span> <span class=\"texample\">tr</span>, соответствующим <a name=\"keyword69\"></a><span class=\"keyword\">заголовку</span> <span class=\"texample\">Hr</span>, называется множество упорядоченных триплетов вида <span class=\"texample\">&lt;A, T, v&gt;</span>, по одному такому триплету для каждого <a name=\"keyword70\"></a><span class=\"keyword\">атрибута</span> в <span class=\"texample\">Hr</span> . Третий элемент &ndash; <span class=\"texample\">v</span> &ndash; триплета <span class=\"texample\">&lt;A, T, v&gt;</span> должен являться допустимым значением <a name=\"keyword71\"></a><span class=\"keyword\">типа данных</span>или <a name=\"keyword72\"></a><span class=\"keyword\">домена</span> <span class=\"texample\">T</span>. <a name=\"keyword73\"></a><span class=\"keyword\">Заголовку отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> соответствуют, например, следующие <a name=\"keyword74\"></a><span class=\"keyword\">кортежи</span>: <span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2934&gt;, &lt;слу_имя, имена, Иванов&gt;, &lt;слу_зарп, размеры_выплат, 22.000&gt;, &lt;слу_отд_номер, номера_отделов, 310&gt;}</span>,<span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2940&gt;, &lt;слу_имя, имена, Кузнецов&gt;, &lt;слу_зарп, размеры_выплат, 35.000&gt;, &lt;слу_отд_номер, номера_отделов, 320&gt;}</span>.</p> <div id=\"mark_26\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_37\"><a name=\"keyword-context6\"></a><span class=\"keyword_def\"><a name=\"keyword75\"></a><span class=\"keyword\">Телом</span></span> <span class=\"texample\">Br</span> <a name=\"keyword76\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется произвольное множество <a name=\"keyword77\"></a><span class=\"keyword\">кортежей</span> <span class=\"texample\">tr</span> . Одно из возможных <a name=\"keyword78\"></a><span class=\"keyword\">тел отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">на рис. 2.1</a>. Заметим, что в общем случае, как это демонстрируют, в частности, <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> и пример предыдущего абзаца, могут существовать такие <a name=\"keyword79\"></a><span class=\"keyword\">кортежи</span> <span class=\"texample\">tr</span>, которые соответствуют <span class=\"texample\">Hr</span>, но не входят в <span class=\"texample\">Br</span>.</p> <div id=\"mark_37\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_45\"><a name=\"keyword-context7\"></a><span class=\"keyword_def\"><a name=\"keyword80\"></a><span class=\"keyword\">Значением</span></span> <span class=\"texample\">Vr</span> <a name=\"keyword81\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется пара множеств <span class=\"texample\">Hr</span> и <span class=\"texample\">Br</span> . Одно из допустимых <a name=\"keyword82\"></a><span class=\"keyword\">значений отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано на<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>.</p> <div id=\"mark_45\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_51\">В изменчивой <a name=\"keyword83\"></a><span class=\"keyword\">реляционной базе данных</span> хранятся <a name=\"keyword84\"></a><span class=\"keyword\">отношения</span>, <a name=\"keyword85\"></a><span class=\"keyword\">значения</span> которых изменяются во времени. <a name=\"keyword-context8\"></a><span class=\"keyword_def\"><a name=\"keyword86\"></a><span class=\"keyword\">Переменной</span></span> <span class=\"texample\">VARr</span> называется именованный контейнер, который может содержать любое допустимое <a name=\"keyword87\"></a><span class=\"keyword\">значение</span> <span class=\"texample\">Vr</span> . Естественно, что при определении любой <span class=\"texample\">VARr</span>требуется указывать соответствующий <a name=\"keyword88\"></a><span class=\"keyword\">заголовок отношения</span> <span class=\"texample\">Hr</span>.</p> <div id=\"mark_51\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_56\">Здесь стоит подчеркнуть, что любая принятая на практике операция обновления <a name=\"keyword89\"></a><span class=\"keyword\">базы данных</span> &ndash; <span class=\"texample\">INSERT</span> (вставка <a name=\"keyword90\"></a><span class=\"keyword\">кортежа</span> в <a name=\"keyword91\"></a><span class=\"keyword\">переменную отношения</span> ), <span class=\"texample\">DELETE</span> (удаление <a name=\"keyword92\"></a><span class=\"keyword\">кортежа</span> из значения- <a name=\"keyword93\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword94\"></a><span class=\"keyword\">переменной отношения</span> ) и <span class=\"texample\">UPDATE</span> (модификация <a name=\"keyword95\"></a><span class=\"keyword\">кортежа</span> значения-<a name=\"keyword96\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword97\"></a><span class=\"keyword\">переменной отношения</span> ) &ndash; с модельной точки зрения является операцией присваивания <a name=\"keyword98\"></a><span class=\"keyword\">переменной отношения</span> некоторого нового значения- <a name=\"keyword99\"></a><span class=\"keyword\">отношения</span>. Это совсем не означает, что перечисленные операции должны выполняться именно таким образом в СУБД: главное, чтобы результат операций соответствовал этой модельной семантике.</p> <div id=\"mark_56\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_60\">Заметим, что в дальнейшем в тех случаях, когда точный смысл термина понятен из контекста, мы будем использовать термин <a name=\"keyword100\"></a><span class=\"keyword\">отношение</span> как в смысле <a name=\"keyword101\"></a><span class=\"keyword\">значение отношения</span>, так и в смысле <a name=\"keyword102\"></a><span class=\"keyword\">переменная отношения</span>.</p> <div id=\"mark_60\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_61\"><a name=\"keyword-context9\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword103\"></a><span class=\"keyword\">степенью, или \"арностью\"</span></span>, <a name=\"keyword104\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword105\"></a><span class=\"keyword\">кортежа</span>, соответствующего этому <a name=\"keyword106\"></a><span class=\"keyword\">заголовку</span>, <a name=\"keyword107\"></a><span class=\"keyword\">тела отношения</span>,<a name=\"keyword108\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword109\"></a><span class=\"keyword\">переменной отношения</span> является мощность <a name=\"keyword110\"></a><span class=\"keyword\">заголовка отношения</span> . Например, <a name=\"keyword111\"></a><span class=\"keyword\">степень отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> равна четырем, т. е. оно является 4-арным ( <strong>кватернарным</strong> ).</p> <div id=\"mark_61\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_63\"><a name=\"keyword-context10\"></a>При приведенных определениях разумно считать <span class=\"keyword_def\"><a name=\"keyword112\"></a><span class=\"keyword\">схемой реляционной базы данных</span></span> набор пар <span class=\"texample\">&lt;имя_VARr, Hr&gt;</span>, включающий имена и заголовки всех <a name=\"keyword113\"></a><span class=\"keyword\">переменных отношения</span>, которые определены в <a name=\"keyword114\"></a><span class=\"keyword\">базе данных</span> . <a name=\"keyword-context11\"></a><span class=\"keyword_def\"><a name=\"keyword115\"></a><span class=\"keyword\">Реляционная база данных</span></span> &ndash; это набор пар <span class=\"texample\">&lt;VARr, Hr&gt;</span>(конечно, каждая <a name=\"keyword116\"></a><span class=\"keyword\">переменная отношения</span> в любой момент времени содержит некоторое значение- <a name=\"keyword117\"></a><span class=\"keyword\">отношение</span>, в частности, пустое).</p> <div id=\"mark_63\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_66\">Заметим, что в классических <a name=\"keyword118\"></a><span class=\"keyword\">реляционных базах данных</span> после определения <a name=\"keyword119\"></a><span class=\"keyword\">схемы базы данных</span> могли изменяться только значения<a name=\"keyword120\"></a><span class=\"keyword\">переменных отношений</span>. Однако теперь в большинстве реализаций допускается и изменение <a name=\"keyword121\"></a><span class=\"keyword\">схемы базы данных</span>: определение новых и изменение заголовков существующих <a name=\"keyword122\"></a><span class=\"keyword\">переменных отношений</span>. Это принято называть <strong>эволюцией </strong><a name=\"keyword123\"></a><span class=\"keyword\">схемы базы данных</span>.</p> <div id=\"mark_66\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect5\"></a></h3> <h4>Первичный ключ и интуитивная интерпретация реляционных понятий</h4> <p id=\"id_67\"><a name=\"keyword-context12\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword124\"></a><span class=\"keyword\">первичным ключом</span></span> <a name=\"keyword125\"></a><span class=\"keyword\">переменной отношения</span> является такое подмножество<sup>1</sup> <span class=\"texample\">S</span> множества <a name=\"keyword129\"></a><span class=\"keyword\">атрибутов</span> ее заголовка, что в любое время значение <a name=\"keyword130\"></a><span class=\"keyword\">первичного ключа</span> (составное, если в состав <a name=\"keyword131\"></a><span class=\"keyword\">первичного ключа</span> входит более одного <a name=\"keyword132\"></a><span class=\"keyword\">атрибута</span> ) в любом <a name=\"keyword133\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword134\"></a><span class=\"keyword\">тела отношения</span> отличается от значения <a name=\"keyword135\"></a><span class=\"keyword\">первичного ключа</span> в любом другом <a name=\"keyword136\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword137\"></a><span class=\"keyword\">тела</span> этого <a name=\"keyword138\"></a><span class=\"keyword\">отношения</span>, а никакое собственное подмножество<sup>2</sup><span class=\"texample\">S</span> этим свойством не обладает. В следующем разделе мы покажем, что существование <a name=\"keyword139\"></a><span class=\"keyword\">первичного ключа</span> у любого <a name=\"keyword140\"></a><span class=\"keyword\">значения отношения</span>является следствием одного из фундаментальных свойств <a name=\"keyword141\"></a><span class=\"keyword\">отношений</span>, а именно того свойства, что <a name=\"keyword142\"></a><span class=\"keyword\">тело отношения</span> является множеством<a name=\"keyword143\"></a><span class=\"keyword\">кортежей</span>.</p> <div id=\"mark_67\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_78\">Обычным житейским представлением <a name=\"keyword144\"></a><span class=\"keyword\">отношения</span> является <strong>таблица</strong>, <strong>заголовком</strong> которой является схема <a name=\"keyword145\"></a><span class=\"keyword\">отношения</span>, а <strong>строками</strong> &ndash; <a name=\"keyword146\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword147\"></a><span class=\"keyword\">отношения</span> -экземпляра; в этом случае имена <a name=\"keyword148\"></a><span class=\"keyword\">атрибутов</span> соответствуют именам <strong>столбцов</strong> данной таблицы. Поэтому иногда говорят про \"столбцы таблицы\", имея в виду \" <a name=\"keyword149\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword150\"></a><span class=\"keyword\">отношения</span> \".</p> <div id=\"mark_78\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_79\">Конечно, это достаточно грубая терминология, поскольку у обычных таблиц и строки, и столбцы упорядочены, тогда как <a name=\"keyword151\"></a><span class=\"keyword\">атрибуты</span> и <a name=\"keyword152\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword153\"></a><span class=\"keyword\">отношений</span> являются элементами неупорядоченных множеств. Тем не менее, когда мы перейдем к рассмотрению практических вопросов организации <a name=\"keyword154\"></a><span class=\"keyword\">реляционных баз данных</span> и средств управления, то будем использовать эту \"житейскую\" терминологию. Подобной терминологии придерживаются в большинстве коммерческих реляционных СУБД. Иногда также используются термины <strong>файл</strong> как аналог таблицы, <strong>запись</strong> как аналог строки и <strong>поле</strong> как аналог столбца. Напомню, что этой терминологией мы пользовались в лекции 1.</p>',2,' В этом курсе, главным образом, обсуждаются различные аспекты реляционных баз данных. Принято считать, что реляционный подход к организации баз данных был заложен в конце 1960-х гг. Эдгаром Коддом. В последние десятилетия этот подход является наиболее распространенным (с оговоркой, что в называемых в обиходе реляционными системах баз данных, основанных на языке SQL, в действительности нарушаются некоторые важные принципы классического реляционного подхода). Достоинствами реляционного подхода принято считать следующие свойства: реляционный подход основывается на небольшом числе интуитивно понятных абстракций, на основе которых возможно простое моделирование наиболее распространенных предметных областей; эти абстракции могут быть точно и формально определены; теоретическим базисом реляционного подхода к организации баз данных служит простой и мощный математический аппарат теории множеств и математической логики; реляционный подход обеспечивает возможность ненавигационного манипулирования данными без необходимости знания конкретной физической организации баз данных во внешней памяти. Компьютерный мир далеко не сразу признал реляционные системы. В 70-е года прошлого века, когда уже были получены почти все основные теоретические результаты и даже существовали первые прототипы реляционных СУБД, многие авторитетные специалисты отрицали возможность добиться эффективной реализации таких систем. Однако преимущества реляционного подхода и развитие методов и алгоритмов организации и управления реляционными базами данных привели к тому, что к концу 80-х годов реляционные системы заняли на мировом рынке СУБД доминирующее положение. В этой лекции на сравнительно неформальном уровне вводятся основные понятия реляционных баз данных, а также определяется сущность реляционной модели данных. Основной целью лекции является демонстрация простоты и возможности интуитивной интерпретации этих понятий. В следующих лекциях будут приводиться более формальные определения, на которых основана теория реляционных баз данных.',0), 
('Лекция 3: Базисные средства манипулирования реляционными данными: ',3,'Lecture','<h3>Основные понятия реляционных баз данных</h3> <p id=\"id_1\">Выделим следующие основные понятия <a name=\"keyword1\"></a><span class=\"keyword\">реляционных баз данных</span>: <a name=\"keyword2\"></a><span class=\"keyword\">тип данных</span>, <a name=\"keyword3\"></a><span class=\"keyword\">домен</span>, <a name=\"keyword4\"></a><span class=\"keyword\">атрибут</span>, <a name=\"keyword5\"></a><span class=\"keyword\">кортеж</span>, <a name=\"keyword6\"></a><span class=\"keyword\">отношение</span>, <a name=\"keyword7\"></a><span class=\"keyword\">первичный ключ</span>.</p> <div id=\"mark_1\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_2\">Для начала покажем смысл этих понятий на примере <a name=\"keyword8\"></a><span class=\"keyword\">отношения</span> СЛУЖАЩИЕ, содержащего информацию о служащих некоторого предприятия (<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>).</p> <div id=\"mark_2\" class=\"lecture_mark\">&nbsp;</div> <div id=\"id_3\"><a name=\"image.2.1\"></a> <div><img src=\"http://www.intuit.ru/EDI/14_02_16_4/1455402139-23616/tutorial/157/objects/2/files/2_1.gif\" alt=\"Соотношение основных понятий реляционного подхода\" /></div> <br /><strong>Рис. 2.1. </strong>Соотношение основных понятий реляционного подхода</div> <div id=\"mark_3\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect2\"></a></h3> <h4>Тип данных</h4> <p id=\"id_4\">Значения данных, хранимые в <a name=\"keyword9\"></a><span class=\"keyword\">реляционной базе данных</span>, являются типизированными, т. е. известен тип каждого хранимого значения. Понятие<a name=\"keyword10\"></a><span class=\"keyword\">типа данных</span> в <a name=\"keyword11\"></a><span class=\"keyword\">реляционной модели данных</span> полностью соответствует понятию <a name=\"keyword12\"></a><span class=\"keyword\">типа данных</span> в языках программирования. <a name=\"keyword-context1\"></a>Напомним, что традиционное (нестрогое) определение <span class=\"keyword_def\"><a name=\"keyword13\"></a><span class=\"keyword\">типа данных</span></span> состоит из трех основных компонентов: определение множества значений данного типа; определение набора операций, применимых к значениям типа; определение способа внешнего представления значений типа (литералов).</p> <div id=\"mark_4\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_5\">Обычно в современных <a name=\"keyword14\"></a><span class=\"keyword\">реляционных базах данных</span> допускается хранение символьных, числовых данных (точных и приблизительных), специализированных числовых данных (таких, как \"деньги\"), а также специальных \"темпоральных\" данных (дата, время, временной интервал). Кроме того, в реляционных системах поддерживается возможность определения пользователями собственных <a name=\"keyword15\"></a><span class=\"keyword\">типов данных</span> (более подробно мы обсудим это в лекции 9, курса \"Введение в модель данных SQL\").</p> <div id=\"mark_5\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_6\">В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> мы имеем дело с данными трех <a name=\"keyword16\"></a><span class=\"keyword\">типов</span>: строки символов, целые числа и \"деньги\".</p> <div id=\"mark_6\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect3\"></a></h3> <h4>Домен</h4> <p id=\"id_7\">Понятие <a name=\"keyword17\"></a><span class=\"keyword\">домена</span> более специфично для баз данных, хотя и имеются аналогии с подтипами в некоторых языках программирования (более того, в своем <strong>\"Третьем манифесте\"</strong> Кристофер Дейт и Хью Дарвен вообще ликвидируют различие между <a name=\"keyword18\"></a><span class=\"keyword\">доменом</span> и <a name=\"keyword19\"></a><span class=\"keyword\">типом данных</span> ). В общем виде<a name=\"keyword20\"></a><span class=\"keyword\">домен</span> определяется путем задания некоторого базового <a name=\"keyword21\"></a><span class=\"keyword\">типа данных</span>, к которому относятся элементы <a name=\"keyword22\"></a><span class=\"keyword\">домена</span>, и произвольного логического выражения, применяемого к элементу этого <a name=\"keyword23\"></a><span class=\"keyword\">типа данных</span> ( <span class=\"keyword_def\"><a name=\"keyword24\"></a><span class=\"keyword\">ограничения домена</span></span> ). Элемент данных является элементом <a name=\"keyword25\"></a><span class=\"keyword\">домена</span> в том и только в том случае, если вычисление этого логического выражения дает результат <strong>истина</strong> (для логических значений мы будем попеременно использовать обозначения <strong>истина</strong> и <strong>ложь</strong> или <strong>true</strong> и <strong>false</strong> ). С каждым <a name=\"keyword26\"></a><span class=\"keyword\">доменом</span> связывается имя, уникальное среди имен всех <a name=\"keyword27\"></a><span class=\"keyword\">доменов</span>соответствующей базы данных.</p> <div id=\"mark_7\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_8\"><a name=\"keyword-context3\"></a>Наиболее правильной интуитивной трактовкой понятия <span class=\"keyword_def\"><a name=\"keyword28\"></a><span class=\"keyword\">домена</span></span> является его восприятие как допустимого потенциального, ограниченного подмножества значений данного типа. Например, <a name=\"keyword29\"></a><span class=\"keyword\">домен</span> <span class=\"texample\">ИМЕНА</span> в нашем примере определен на базовом <a name=\"keyword30\"></a><span class=\"keyword\">типе символьных строк</span>, но в число его значений могут входить только те строки, которые могут представлять имена (в частности, для возможности представления русских имен такие строки не могут начинаться с мягкого или твердого знака и не могут быть длиннее, например, 20 символов). Если некоторый <a name=\"keyword31\"></a><span class=\"keyword\">атрибут</span><a name=\"keyword32\"></a><span class=\"keyword\">отношения</span> определяется на некотором <a name=\"keyword33\"></a><span class=\"keyword\">домене</span> (как, например, на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword34\"></a><span class=\"keyword\">атрибут</span> <span class=\"texample\">СЛУ_ИМЯ</span> определяется на <a name=\"keyword35\"></a><span class=\"keyword\">домене</span> <span class=\"texample\">ИМЕНА</span> ), то в дальнейшем <a name=\"keyword36\"></a><span class=\"keyword\">ограничение домена</span> играет роль <a name=\"keyword37\"></a><span class=\"keyword\">ограничения целостности</span>, накладываемого на значения этого <a name=\"keyword38\"></a><span class=\"keyword\">атрибута</span>.</p> <div id=\"mark_8\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_12\">Следует отметить также семантическую нагрузку понятия <a name=\"keyword39\"></a><span class=\"keyword\">домена</span>: данные считаются сравнимыми только в том случае, когда они относятся к одному <a name=\"keyword40\"></a><span class=\"keyword\">домену</span>. В нашем примере значения <a name=\"keyword41\"></a><span class=\"keyword\">доменов</span> <span class=\"texample\">НОМЕРА ПРОПУСКОВ</span> и <span class=\"texample\">НОМЕРА ОТДЕЛОВ</span> относятся к типу целых чисел, но не являются сравнимыми (допускать их сравнение было бы бессмысленно).</p> <div id=\"mark_12\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect4\"></a></h3> <h4>Заголовок отношения, кортеж, тело отношения, значение отношения, переменная отношения</h4> <p id=\"id_15\">Понятие <a name=\"keyword42\"></a><span class=\"keyword\">отношения</span> является наиболее фундаментальным в <a name=\"keyword43\"></a><span class=\"keyword\">реляционном подходе к организации баз данных</span>, поскольку <span class=\"texample\">n</span> -арное<a name=\"keyword44\"></a><span class=\"keyword\">отношение</span> является единственной родовой структурой данных, хранящихся в <a name=\"keyword45\"></a><span class=\"keyword\">реляционной базе данных</span>. Это отражено и в общем названии<a name=\"keyword46\"></a><span class=\"keyword\">подхода</span> &ndash; термин <strong>реляционный (relational)</strong> происходит от <strong>relation (отношение)</strong>. Однако сам термин <a name=\"keyword47\"></a><span class=\"keyword\">отношение</span> является исключительно неточным, поскольку, говоря про любые сохраняемые данные, мы должны иметь в виду <strong>тип</strong> этих данных, <strong>значения</strong> этого <a name=\"keyword48\"></a><span class=\"keyword\">типа</span> и <strong>переменные</strong>, в которых сохраняются значения. Соответственно, для уточнения термина <a name=\"keyword49\"></a><span class=\"keyword\">отношение</span> выделяются понятия <a name=\"keyword50\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword51\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword52\"></a><span class=\"keyword\">переменной отношения</span>. Кроме того, нам потребуется вспомогательное понятие <a name=\"keyword53\"></a><span class=\"keyword\">кортежа</span>.</p> <div id=\"mark_15\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_17\"><a name=\"keyword-context4\"></a>Итак, <span class=\"keyword_def\"><a name=\"keyword54\"></a><span class=\"keyword\">заголовком (или схемой) отношения</span></span> <span class=\"texample\">r</span> ( <span class=\"texample\">Hr</span> ) называется конечное множество упорядоченных пар вида <span class=\"texample\">&lt;A, T&gt;</span>, где <span class=\"texample\">A</span>называется именем <a name=\"keyword55\"></a><span class=\"keyword\">атрибута</span>, а <span class=\"texample\">T</span> обозначает имя некоторого базового <a name=\"keyword56\"></a><span class=\"keyword\">типа</span> или ранее определенного <a name=\"keyword57\"></a><span class=\"keyword\">домена</span> . По определению требуется, чтобы все имена <a name=\"keyword58\"></a><span class=\"keyword\">атрибутов</span> в <a name=\"keyword59\"></a><span class=\"keyword\">заголовке отношения</span> были различны. В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword60\"></a><span class=\"keyword\">заголовком отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> является множество пар <span class=\"texample\">{&lt;слу_номер, номера_пропусков&gt;, &lt;слу_имя, имена&gt;, &lt;слу_зарп, размеры_выплат&gt;, &lt;слу_отд_номер, номера_отделов&gt;}</span>.</p> <div id=\"mark_17\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_25\">Если все <a name=\"keyword61\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword62\"></a><span class=\"keyword\">заголовка отношения</span> определены на разных <a name=\"keyword63\"></a><span class=\"keyword\">доменах</span>, то, чтобы не плодить лишних имен, разумно использовать для именования <a name=\"keyword64\"></a><span class=\"keyword\">атрибутов</span> имена соответствующих <a name=\"keyword65\"></a><span class=\"keyword\">доменов</span> (не забывая, конечно, о том, что это всего лишь удобный способ именования, который не устраняет различия между понятиями <a name=\"keyword66\"></a><span class=\"keyword\">домена</span> и <a name=\"keyword67\"></a><span class=\"keyword\">атрибута</span> ).</p> <div id=\"mark_25\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_26\"><a name=\"keyword-context5\"></a><span class=\"keyword_def\"><a name=\"keyword68\"></a><span class=\"keyword\">Кортежем</span></span> <span class=\"texample\">tr</span>, соответствующим <a name=\"keyword69\"></a><span class=\"keyword\">заголовку</span> <span class=\"texample\">Hr</span>, называется множество упорядоченных триплетов вида <span class=\"texample\">&lt;A, T, v&gt;</span>, по одному такому триплету для каждого <a name=\"keyword70\"></a><span class=\"keyword\">атрибута</span> в <span class=\"texample\">Hr</span> . Третий элемент &ndash; <span class=\"texample\">v</span> &ndash; триплета <span class=\"texample\">&lt;A, T, v&gt;</span> должен являться допустимым значением <a name=\"keyword71\"></a><span class=\"keyword\">типа данных</span>или <a name=\"keyword72\"></a><span class=\"keyword\">домена</span> <span class=\"texample\">T</span>. <a name=\"keyword73\"></a><span class=\"keyword\">Заголовку отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> соответствуют, например, следующие <a name=\"keyword74\"></a><span class=\"keyword\">кортежи</span>: <span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2934&gt;, &lt;слу_имя, имена, Иванов&gt;, &lt;слу_зарп, размеры_выплат, 22.000&gt;, &lt;слу_отд_номер, номера_отделов, 310&gt;}</span>,<span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2940&gt;, &lt;слу_имя, имена, Кузнецов&gt;, &lt;слу_зарп, размеры_выплат, 35.000&gt;, &lt;слу_отд_номер, номера_отделов, 320&gt;}</span>.</p> <div id=\"mark_26\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_37\"><a name=\"keyword-context6\"></a><span class=\"keyword_def\"><a name=\"keyword75\"></a><span class=\"keyword\">Телом</span></span> <span class=\"texample\">Br</span> <a name=\"keyword76\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется произвольное множество <a name=\"keyword77\"></a><span class=\"keyword\">кортежей</span> <span class=\"texample\">tr</span> . Одно из возможных <a name=\"keyword78\"></a><span class=\"keyword\">тел отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">на рис. 2.1</a>. Заметим, что в общем случае, как это демонстрируют, в частности, <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> и пример предыдущего абзаца, могут существовать такие <a name=\"keyword79\"></a><span class=\"keyword\">кортежи</span> <span class=\"texample\">tr</span>, которые соответствуют <span class=\"texample\">Hr</span>, но не входят в <span class=\"texample\">Br</span>.</p> <div id=\"mark_37\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_45\"><a name=\"keyword-context7\"></a><span class=\"keyword_def\"><a name=\"keyword80\"></a><span class=\"keyword\">Значением</span></span> <span class=\"texample\">Vr</span> <a name=\"keyword81\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется пара множеств <span class=\"texample\">Hr</span> и <span class=\"texample\">Br</span> . Одно из допустимых <a name=\"keyword82\"></a><span class=\"keyword\">значений отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано на<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>.</p> <div id=\"mark_45\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_51\">В изменчивой <a name=\"keyword83\"></a><span class=\"keyword\">реляционной базе данных</span> хранятся <a name=\"keyword84\"></a><span class=\"keyword\">отношения</span>, <a name=\"keyword85\"></a><span class=\"keyword\">значения</span> которых изменяются во времени. <a name=\"keyword-context8\"></a><span class=\"keyword_def\"><a name=\"keyword86\"></a><span class=\"keyword\">Переменной</span></span> <span class=\"texample\">VARr</span> называется именованный контейнер, который может содержать любое допустимое <a name=\"keyword87\"></a><span class=\"keyword\">значение</span> <span class=\"texample\">Vr</span> . Естественно, что при определении любой <span class=\"texample\">VARr</span>требуется указывать соответствующий <a name=\"keyword88\"></a><span class=\"keyword\">заголовок отношения</span> <span class=\"texample\">Hr</span>.</p> <div id=\"mark_51\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_56\">Здесь стоит подчеркнуть, что любая принятая на практике операция обновления <a name=\"keyword89\"></a><span class=\"keyword\">базы данных</span> &ndash; <span class=\"texample\">INSERT</span> (вставка <a name=\"keyword90\"></a><span class=\"keyword\">кортежа</span> в <a name=\"keyword91\"></a><span class=\"keyword\">переменную отношения</span> ), <span class=\"texample\">DELETE</span> (удаление <a name=\"keyword92\"></a><span class=\"keyword\">кортежа</span> из значения- <a name=\"keyword93\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword94\"></a><span class=\"keyword\">переменной отношения</span> ) и <span class=\"texample\">UPDATE</span> (модификация <a name=\"keyword95\"></a><span class=\"keyword\">кортежа</span> значения-<a name=\"keyword96\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword97\"></a><span class=\"keyword\">переменной отношения</span> ) &ndash; с модельной точки зрения является операцией присваивания <a name=\"keyword98\"></a><span class=\"keyword\">переменной отношения</span> некоторого нового значения- <a name=\"keyword99\"></a><span class=\"keyword\">отношения</span>. Это совсем не означает, что перечисленные операции должны выполняться именно таким образом в СУБД: главное, чтобы результат операций соответствовал этой модельной семантике.</p> <div id=\"mark_56\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_60\">Заметим, что в дальнейшем в тех случаях, когда точный смысл термина понятен из контекста, мы будем использовать термин <a name=\"keyword100\"></a><span class=\"keyword\">отношение</span> как в смысле <a name=\"keyword101\"></a><span class=\"keyword\">значение отношения</span>, так и в смысле <a name=\"keyword102\"></a><span class=\"keyword\">переменная отношения</span>.</p> <div id=\"mark_60\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_61\"><a name=\"keyword-context9\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword103\"></a><span class=\"keyword\">степенью, или \"арностью\"</span></span>, <a name=\"keyword104\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword105\"></a><span class=\"keyword\">кортежа</span>, соответствующего этому <a name=\"keyword106\"></a><span class=\"keyword\">заголовку</span>, <a name=\"keyword107\"></a><span class=\"keyword\">тела отношения</span>,<a name=\"keyword108\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword109\"></a><span class=\"keyword\">переменной отношения</span> является мощность <a name=\"keyword110\"></a><span class=\"keyword\">заголовка отношения</span> . Например, <a name=\"keyword111\"></a><span class=\"keyword\">степень отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> равна четырем, т. е. оно является 4-арным ( <strong>кватернарным</strong> ).</p> <div id=\"mark_61\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_63\"><a name=\"keyword-context10\"></a>При приведенных определениях разумно считать <span class=\"keyword_def\"><a name=\"keyword112\"></a><span class=\"keyword\">схемой реляционной базы данных</span></span> набор пар <span class=\"texample\">&lt;имя_VARr, Hr&gt;</span>, включающий имена и заголовки всех <a name=\"keyword113\"></a><span class=\"keyword\">переменных отношения</span>, которые определены в <a name=\"keyword114\"></a><span class=\"keyword\">базе данных</span> . <a name=\"keyword-context11\"></a><span class=\"keyword_def\"><a name=\"keyword115\"></a><span class=\"keyword\">Реляционная база данных</span></span> &ndash; это набор пар <span class=\"texample\">&lt;VARr, Hr&gt;</span>(конечно, каждая <a name=\"keyword116\"></a><span class=\"keyword\">переменная отношения</span> в любой момент времени содержит некоторое значение- <a name=\"keyword117\"></a><span class=\"keyword\">отношение</span>, в частности, пустое).</p> <div id=\"mark_63\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_66\">Заметим, что в классических <a name=\"keyword118\"></a><span class=\"keyword\">реляционных базах данных</span> после определения <a name=\"keyword119\"></a><span class=\"keyword\">схемы базы данных</span> могли изменяться только значения<a name=\"keyword120\"></a><span class=\"keyword\">переменных отношений</span>. Однако теперь в большинстве реализаций допускается и изменение <a name=\"keyword121\"></a><span class=\"keyword\">схемы базы данных</span>: определение новых и изменение заголовков существующих <a name=\"keyword122\"></a><span class=\"keyword\">переменных отношений</span>. Это принято называть <strong>эволюцией </strong><a name=\"keyword123\"></a><span class=\"keyword\">схемы базы данных</span>.</p> <div id=\"mark_66\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect5\"></a></h3> <h4>Первичный ключ и интуитивная интерпретация реляционных понятий</h4> <p id=\"id_67\"><a name=\"keyword-context12\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword124\"></a><span class=\"keyword\">первичным ключом</span></span> <a name=\"keyword125\"></a><span class=\"keyword\">переменной отношения</span> является такое подмножество<sup>1</sup> <span class=\"texample\">S</span> множества <a name=\"keyword129\"></a><span class=\"keyword\">атрибутов</span> ее заголовка, что в любое время значение <a name=\"keyword130\"></a><span class=\"keyword\">первичного ключа</span> (составное, если в состав <a name=\"keyword131\"></a><span class=\"keyword\">первичного ключа</span> входит более одного <a name=\"keyword132\"></a><span class=\"keyword\">атрибута</span> ) в любом <a name=\"keyword133\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword134\"></a><span class=\"keyword\">тела отношения</span> отличается от значения <a name=\"keyword135\"></a><span class=\"keyword\">первичного ключа</span> в любом другом <a name=\"keyword136\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword137\"></a><span class=\"keyword\">тела</span> этого <a name=\"keyword138\"></a><span class=\"keyword\">отношения</span>, а никакое собственное подмножество<sup>2</sup><span class=\"texample\">S</span> этим свойством не обладает. В следующем разделе мы покажем, что существование <a name=\"keyword139\"></a><span class=\"keyword\">первичного ключа</span> у любого <a name=\"keyword140\"></a><span class=\"keyword\">значения отношения</span>является следствием одного из фундаментальных свойств <a name=\"keyword141\"></a><span class=\"keyword\">отношений</span>, а именно того свойства, что <a name=\"keyword142\"></a><span class=\"keyword\">тело отношения</span> является множеством<a name=\"keyword143\"></a><span class=\"keyword\">кортежей</span>.</p> <div id=\"mark_67\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_78\">Обычным житейским представлением <a name=\"keyword144\"></a><span class=\"keyword\">отношения</span> является <strong>таблица</strong>, <strong>заголовком</strong> которой является схема <a name=\"keyword145\"></a><span class=\"keyword\">отношения</span>, а <strong>строками</strong> &ndash; <a name=\"keyword146\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword147\"></a><span class=\"keyword\">отношения</span> -экземпляра; в этом случае имена <a name=\"keyword148\"></a><span class=\"keyword\">атрибутов</span> соответствуют именам <strong>столбцов</strong> данной таблицы. Поэтому иногда говорят про \"столбцы таблицы\", имея в виду \" <a name=\"keyword149\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword150\"></a><span class=\"keyword\">отношения</span> \".</p> <div id=\"mark_78\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_79\">Конечно, это достаточно грубая терминология, поскольку у обычных таблиц и строки, и столбцы упорядочены, тогда как <a name=\"keyword151\"></a><span class=\"keyword\">атрибуты</span> и <a name=\"keyword152\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword153\"></a><span class=\"keyword\">отношений</span> являются элементами неупорядоченных множеств. Тем не менее, когда мы перейдем к рассмотрению практических вопросов организации <a name=\"keyword154\"></a><span class=\"keyword\">реляционных баз данных</span> и средств управления, то будем использовать эту \"житейскую\" терминологию. Подобной терминологии придерживаются в большинстве коммерческих реляционных СУБД. Иногда также используются термины <strong>файл</strong> как аналог таблицы, <strong>запись</strong> как аналог строки и <strong>поле</strong> как аналог столбца. Напомню, что этой терминологией мы пользовались в лекции 1.</p>',2,' В этом курсе, главным образом, обсуждаются различные аспекты реляционных баз данных. Принято считать, что реляционный подход к организации баз данных был заложен в конце 1960-х гг. Эдгаром Коддом. В последние десятилетия этот подход является наиболее распространенным (с оговоркой, что в называемых в обиходе реляционными системах баз данных, основанных на языке SQL, в действительности нарушаются некоторые важные принципы классического реляционного подхода). Достоинствами реляционного подхода принято считать следующие свойства: реляционный подход основывается на небольшом числе интуитивно понятных абстракций, на основе которых возможно простое моделирование наиболее распространенных предметных областей; эти абстракции могут быть точно и формально определены; теоретическим базисом реляционного подхода к организации баз данных служит простой и мощный математический аппарат теории множеств и математической логики; реляционный подход обеспечивает возможность ненавигационного манипулирования данными без необходимости знания конкретной физической организации баз данных во внешней памяти. Компьютерный мир далеко не сразу признал реляционные системы. В 70-е года прошлого века, когда уже были получены почти все основные теоретические результаты и даже существовали первые прототипы реляционных СУБД, многие авторитетные специалисты отрицали возможность добиться эффективной реализации таких систем. Однако преимущества реляционного подхода и развитие методов и алгоритмов организации и управления реляционными базами данных привели к тому, что к концу 80-х годов реляционные системы заняли на мировом рынке СУБД доминирующее положение. В этой лекции на сравнительно неформальном уровне вводятся основные понятия реляционных баз данных, а также определяется сущность реляционной модели данных. Основной целью лекции является демонстрация простоты и возможности интуитивной интерпретации этих понятий. В следующих лекциях будут приводиться более формальные определения, на которых основана теория реляционных баз данных.',0), 
('Лекция 4: Базисные средства манипулирования реляционными данными: алгебра A Дейта и Дарвена',4,'Lecture','<h3>Основные понятия реляционных баз данных</h3> <p id=\"id_1\">Выделим следующие основные понятия <a name=\"keyword1\"></a><span class=\"keyword\">реляционных баз данных</span>: <a name=\"keyword2\"></a><span class=\"keyword\">тип данных</span>, <a name=\"keyword3\"></a><span class=\"keyword\">домен</span>, <a name=\"keyword4\"></a><span class=\"keyword\">атрибут</span>, <a name=\"keyword5\"></a><span class=\"keyword\">кортеж</span>, <a name=\"keyword6\"></a><span class=\"keyword\">отношение</span>, <a name=\"keyword7\"></a><span class=\"keyword\">первичный ключ</span>.</p> <div id=\"mark_1\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_2\">Для начала покажем смысл этих понятий на примере <a name=\"keyword8\"></a><span class=\"keyword\">отношения</span> СЛУЖАЩИЕ, содержащего информацию о служащих некоторого предприятия (<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>).</p> <div id=\"mark_2\" class=\"lecture_mark\">&nbsp;</div> <div id=\"id_3\"><a name=\"image.2.1\"></a> <div><img src=\"http://www.intuit.ru/EDI/14_02_16_4/1455402139-23616/tutorial/157/objects/2/files/2_1.gif\" alt=\"Соотношение основных понятий реляционного подхода\" /></div> <br /><strong>Рис. 2.1. </strong>Соотношение основных понятий реляционного подхода</div> <div id=\"mark_3\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect2\"></a></h3> <h4>Тип данных</h4> <p id=\"id_4\">Значения данных, хранимые в <a name=\"keyword9\"></a><span class=\"keyword\">реляционной базе данных</span>, являются типизированными, т. е. известен тип каждого хранимого значения. Понятие<a name=\"keyword10\"></a><span class=\"keyword\">типа данных</span> в <a name=\"keyword11\"></a><span class=\"keyword\">реляционной модели данных</span> полностью соответствует понятию <a name=\"keyword12\"></a><span class=\"keyword\">типа данных</span> в языках программирования. <a name=\"keyword-context1\"></a>Напомним, что традиционное (нестрогое) определение <span class=\"keyword_def\"><a name=\"keyword13\"></a><span class=\"keyword\">типа данных</span></span> состоит из трех основных компонентов: определение множества значений данного типа; определение набора операций, применимых к значениям типа; определение способа внешнего представления значений типа (литералов).</p> <div id=\"mark_4\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_5\">Обычно в современных <a name=\"keyword14\"></a><span class=\"keyword\">реляционных базах данных</span> допускается хранение символьных, числовых данных (точных и приблизительных), специализированных числовых данных (таких, как \"деньги\"), а также специальных \"темпоральных\" данных (дата, время, временной интервал). Кроме того, в реляционных системах поддерживается возможность определения пользователями собственных <a name=\"keyword15\"></a><span class=\"keyword\">типов данных</span> (более подробно мы обсудим это в лекции 9, курса \"Введение в модель данных SQL\").</p> <div id=\"mark_5\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_6\">В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> мы имеем дело с данными трех <a name=\"keyword16\"></a><span class=\"keyword\">типов</span>: строки символов, целые числа и \"деньги\".</p> <div id=\"mark_6\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect3\"></a></h3> <h4>Домен</h4> <p id=\"id_7\">Понятие <a name=\"keyword17\"></a><span class=\"keyword\">домена</span> более специфично для баз данных, хотя и имеются аналогии с подтипами в некоторых языках программирования (более того, в своем <strong>\"Третьем манифесте\"</strong> Кристофер Дейт и Хью Дарвен вообще ликвидируют различие между <a name=\"keyword18\"></a><span class=\"keyword\">доменом</span> и <a name=\"keyword19\"></a><span class=\"keyword\">типом данных</span> ). В общем виде<a name=\"keyword20\"></a><span class=\"keyword\">домен</span> определяется путем задания некоторого базового <a name=\"keyword21\"></a><span class=\"keyword\">типа данных</span>, к которому относятся элементы <a name=\"keyword22\"></a><span class=\"keyword\">домена</span>, и произвольного логического выражения, применяемого к элементу этого <a name=\"keyword23\"></a><span class=\"keyword\">типа данных</span> ( <span class=\"keyword_def\"><a name=\"keyword24\"></a><span class=\"keyword\">ограничения домена</span></span> ). Элемент данных является элементом <a name=\"keyword25\"></a><span class=\"keyword\">домена</span> в том и только в том случае, если вычисление этого логического выражения дает результат <strong>истина</strong> (для логических значений мы будем попеременно использовать обозначения <strong>истина</strong> и <strong>ложь</strong> или <strong>true</strong> и <strong>false</strong> ). С каждым <a name=\"keyword26\"></a><span class=\"keyword\">доменом</span> связывается имя, уникальное среди имен всех <a name=\"keyword27\"></a><span class=\"keyword\">доменов</span>соответствующей базы данных.</p> <div id=\"mark_7\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_8\"><a name=\"keyword-context3\"></a>Наиболее правильной интуитивной трактовкой понятия <span class=\"keyword_def\"><a name=\"keyword28\"></a><span class=\"keyword\">домена</span></span> является его восприятие как допустимого потенциального, ограниченного подмножества значений данного типа. Например, <a name=\"keyword29\"></a><span class=\"keyword\">домен</span> <span class=\"texample\">ИМЕНА</span> в нашем примере определен на базовом <a name=\"keyword30\"></a><span class=\"keyword\">типе символьных строк</span>, но в число его значений могут входить только те строки, которые могут представлять имена (в частности, для возможности представления русских имен такие строки не могут начинаться с мягкого или твердого знака и не могут быть длиннее, например, 20 символов). Если некоторый <a name=\"keyword31\"></a><span class=\"keyword\">атрибут</span><a name=\"keyword32\"></a><span class=\"keyword\">отношения</span> определяется на некотором <a name=\"keyword33\"></a><span class=\"keyword\">домене</span> (как, например, на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword34\"></a><span class=\"keyword\">атрибут</span> <span class=\"texample\">СЛУ_ИМЯ</span> определяется на <a name=\"keyword35\"></a><span class=\"keyword\">домене</span> <span class=\"texample\">ИМЕНА</span> ), то в дальнейшем <a name=\"keyword36\"></a><span class=\"keyword\">ограничение домена</span> играет роль <a name=\"keyword37\"></a><span class=\"keyword\">ограничения целостности</span>, накладываемого на значения этого <a name=\"keyword38\"></a><span class=\"keyword\">атрибута</span>.</p> <div id=\"mark_8\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_12\">Следует отметить также семантическую нагрузку понятия <a name=\"keyword39\"></a><span class=\"keyword\">домена</span>: данные считаются сравнимыми только в том случае, когда они относятся к одному <a name=\"keyword40\"></a><span class=\"keyword\">домену</span>. В нашем примере значения <a name=\"keyword41\"></a><span class=\"keyword\">доменов</span> <span class=\"texample\">НОМЕРА ПРОПУСКОВ</span> и <span class=\"texample\">НОМЕРА ОТДЕЛОВ</span> относятся к типу целых чисел, но не являются сравнимыми (допускать их сравнение было бы бессмысленно).</p> <div id=\"mark_12\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect4\"></a></h3> <h4>Заголовок отношения, кортеж, тело отношения, значение отношения, переменная отношения</h4> <p id=\"id_15\">Понятие <a name=\"keyword42\"></a><span class=\"keyword\">отношения</span> является наиболее фундаментальным в <a name=\"keyword43\"></a><span class=\"keyword\">реляционном подходе к организации баз данных</span>, поскольку <span class=\"texample\">n</span> -арное<a name=\"keyword44\"></a><span class=\"keyword\">отношение</span> является единственной родовой структурой данных, хранящихся в <a name=\"keyword45\"></a><span class=\"keyword\">реляционной базе данных</span>. Это отражено и в общем названии<a name=\"keyword46\"></a><span class=\"keyword\">подхода</span> &ndash; термин <strong>реляционный (relational)</strong> происходит от <strong>relation (отношение)</strong>. Однако сам термин <a name=\"keyword47\"></a><span class=\"keyword\">отношение</span> является исключительно неточным, поскольку, говоря про любые сохраняемые данные, мы должны иметь в виду <strong>тип</strong> этих данных, <strong>значения</strong> этого <a name=\"keyword48\"></a><span class=\"keyword\">типа</span> и <strong>переменные</strong>, в которых сохраняются значения. Соответственно, для уточнения термина <a name=\"keyword49\"></a><span class=\"keyword\">отношение</span> выделяются понятия <a name=\"keyword50\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword51\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword52\"></a><span class=\"keyword\">переменной отношения</span>. Кроме того, нам потребуется вспомогательное понятие <a name=\"keyword53\"></a><span class=\"keyword\">кортежа</span>.</p> <div id=\"mark_15\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_17\"><a name=\"keyword-context4\"></a>Итак, <span class=\"keyword_def\"><a name=\"keyword54\"></a><span class=\"keyword\">заголовком (или схемой) отношения</span></span> <span class=\"texample\">r</span> ( <span class=\"texample\">Hr</span> ) называется конечное множество упорядоченных пар вида <span class=\"texample\">&lt;A, T&gt;</span>, где <span class=\"texample\">A</span>называется именем <a name=\"keyword55\"></a><span class=\"keyword\">атрибута</span>, а <span class=\"texample\">T</span> обозначает имя некоторого базового <a name=\"keyword56\"></a><span class=\"keyword\">типа</span> или ранее определенного <a name=\"keyword57\"></a><span class=\"keyword\">домена</span> . По определению требуется, чтобы все имена <a name=\"keyword58\"></a><span class=\"keyword\">атрибутов</span> в <a name=\"keyword59\"></a><span class=\"keyword\">заголовке отношения</span> были различны. В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword60\"></a><span class=\"keyword\">заголовком отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> является множество пар <span class=\"texample\">{&lt;слу_номер, номера_пропусков&gt;, &lt;слу_имя, имена&gt;, &lt;слу_зарп, размеры_выплат&gt;, &lt;слу_отд_номер, номера_отделов&gt;}</span>.</p> <div id=\"mark_17\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_25\">Если все <a name=\"keyword61\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword62\"></a><span class=\"keyword\">заголовка отношения</span> определены на разных <a name=\"keyword63\"></a><span class=\"keyword\">доменах</span>, то, чтобы не плодить лишних имен, разумно использовать для именования <a name=\"keyword64\"></a><span class=\"keyword\">атрибутов</span> имена соответствующих <a name=\"keyword65\"></a><span class=\"keyword\">доменов</span> (не забывая, конечно, о том, что это всего лишь удобный способ именования, который не устраняет различия между понятиями <a name=\"keyword66\"></a><span class=\"keyword\">домена</span> и <a name=\"keyword67\"></a><span class=\"keyword\">атрибута</span> ).</p> <div id=\"mark_25\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_26\"><a name=\"keyword-context5\"></a><span class=\"keyword_def\"><a name=\"keyword68\"></a><span class=\"keyword\">Кортежем</span></span> <span class=\"texample\">tr</span>, соответствующим <a name=\"keyword69\"></a><span class=\"keyword\">заголовку</span> <span class=\"texample\">Hr</span>, называется множество упорядоченных триплетов вида <span class=\"texample\">&lt;A, T, v&gt;</span>, по одному такому триплету для каждого <a name=\"keyword70\"></a><span class=\"keyword\">атрибута</span> в <span class=\"texample\">Hr</span> . Третий элемент &ndash; <span class=\"texample\">v</span> &ndash; триплета <span class=\"texample\">&lt;A, T, v&gt;</span> должен являться допустимым значением <a name=\"keyword71\"></a><span class=\"keyword\">типа данных</span>или <a name=\"keyword72\"></a><span class=\"keyword\">домена</span> <span class=\"texample\">T</span>. <a name=\"keyword73\"></a><span class=\"keyword\">Заголовку отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> соответствуют, например, следующие <a name=\"keyword74\"></a><span class=\"keyword\">кортежи</span>: <span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2934&gt;, &lt;слу_имя, имена, Иванов&gt;, &lt;слу_зарп, размеры_выплат, 22.000&gt;, &lt;слу_отд_номер, номера_отделов, 310&gt;}</span>,<span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2940&gt;, &lt;слу_имя, имена, Кузнецов&gt;, &lt;слу_зарп, размеры_выплат, 35.000&gt;, &lt;слу_отд_номер, номера_отделов, 320&gt;}</span>.</p> <div id=\"mark_26\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_37\"><a name=\"keyword-context6\"></a><span class=\"keyword_def\"><a name=\"keyword75\"></a><span class=\"keyword\">Телом</span></span> <span class=\"texample\">Br</span> <a name=\"keyword76\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется произвольное множество <a name=\"keyword77\"></a><span class=\"keyword\">кортежей</span> <span class=\"texample\">tr</span> . Одно из возможных <a name=\"keyword78\"></a><span class=\"keyword\">тел отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">на рис. 2.1</a>. Заметим, что в общем случае, как это демонстрируют, в частности, <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> и пример предыдущего абзаца, могут существовать такие <a name=\"keyword79\"></a><span class=\"keyword\">кортежи</span> <span class=\"texample\">tr</span>, которые соответствуют <span class=\"texample\">Hr</span>, но не входят в <span class=\"texample\">Br</span>.</p> <div id=\"mark_37\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_45\"><a name=\"keyword-context7\"></a><span class=\"keyword_def\"><a name=\"keyword80\"></a><span class=\"keyword\">Значением</span></span> <span class=\"texample\">Vr</span> <a name=\"keyword81\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется пара множеств <span class=\"texample\">Hr</span> и <span class=\"texample\">Br</span> . Одно из допустимых <a name=\"keyword82\"></a><span class=\"keyword\">значений отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано на<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>.</p> <div id=\"mark_45\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_51\">В изменчивой <a name=\"keyword83\"></a><span class=\"keyword\">реляционной базе данных</span> хранятся <a name=\"keyword84\"></a><span class=\"keyword\">отношения</span>, <a name=\"keyword85\"></a><span class=\"keyword\">значения</span> которых изменяются во времени. <a name=\"keyword-context8\"></a><span class=\"keyword_def\"><a name=\"keyword86\"></a><span class=\"keyword\">Переменной</span></span> <span class=\"texample\">VARr</span> называется именованный контейнер, который может содержать любое допустимое <a name=\"keyword87\"></a><span class=\"keyword\">значение</span> <span class=\"texample\">Vr</span> . Естественно, что при определении любой <span class=\"texample\">VARr</span>требуется указывать соответствующий <a name=\"keyword88\"></a><span class=\"keyword\">заголовок отношения</span> <span class=\"texample\">Hr</span>.</p> <div id=\"mark_51\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_56\">Здесь стоит подчеркнуть, что любая принятая на практике операция обновления <a name=\"keyword89\"></a><span class=\"keyword\">базы данных</span> &ndash; <span class=\"texample\">INSERT</span> (вставка <a name=\"keyword90\"></a><span class=\"keyword\">кортежа</span> в <a name=\"keyword91\"></a><span class=\"keyword\">переменную отношения</span> ), <span class=\"texample\">DELETE</span> (удаление <a name=\"keyword92\"></a><span class=\"keyword\">кортежа</span> из значения- <a name=\"keyword93\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword94\"></a><span class=\"keyword\">переменной отношения</span> ) и <span class=\"texample\">UPDATE</span> (модификация <a name=\"keyword95\"></a><span class=\"keyword\">кортежа</span> значения-<a name=\"keyword96\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword97\"></a><span class=\"keyword\">переменной отношения</span> ) &ndash; с модельной точки зрения является операцией присваивания <a name=\"keyword98\"></a><span class=\"keyword\">переменной отношения</span> некоторого нового значения- <a name=\"keyword99\"></a><span class=\"keyword\">отношения</span>. Это совсем не означает, что перечисленные операции должны выполняться именно таким образом в СУБД: главное, чтобы результат операций соответствовал этой модельной семантике.</p> <div id=\"mark_56\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_60\">Заметим, что в дальнейшем в тех случаях, когда точный смысл термина понятен из контекста, мы будем использовать термин <a name=\"keyword100\"></a><span class=\"keyword\">отношение</span> как в смысле <a name=\"keyword101\"></a><span class=\"keyword\">значение отношения</span>, так и в смысле <a name=\"keyword102\"></a><span class=\"keyword\">переменная отношения</span>.</p> <div id=\"mark_60\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_61\"><a name=\"keyword-context9\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword103\"></a><span class=\"keyword\">степенью, или \"арностью\"</span></span>, <a name=\"keyword104\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword105\"></a><span class=\"keyword\">кортежа</span>, соответствующего этому <a name=\"keyword106\"></a><span class=\"keyword\">заголовку</span>, <a name=\"keyword107\"></a><span class=\"keyword\">тела отношения</span>,<a name=\"keyword108\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword109\"></a><span class=\"keyword\">переменной отношения</span> является мощность <a name=\"keyword110\"></a><span class=\"keyword\">заголовка отношения</span> . Например, <a name=\"keyword111\"></a><span class=\"keyword\">степень отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> равна четырем, т. е. оно является 4-арным ( <strong>кватернарным</strong> ).</p> <div id=\"mark_61\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_63\"><a name=\"keyword-context10\"></a>При приведенных определениях разумно считать <span class=\"keyword_def\"><a name=\"keyword112\"></a><span class=\"keyword\">схемой реляционной базы данных</span></span> набор пар <span class=\"texample\">&lt;имя_VARr, Hr&gt;</span>, включающий имена и заголовки всех <a name=\"keyword113\"></a><span class=\"keyword\">переменных отношения</span>, которые определены в <a name=\"keyword114\"></a><span class=\"keyword\">базе данных</span> . <a name=\"keyword-context11\"></a><span class=\"keyword_def\"><a name=\"keyword115\"></a><span class=\"keyword\">Реляционная база данных</span></span> &ndash; это набор пар <span class=\"texample\">&lt;VARr, Hr&gt;</span>(конечно, каждая <a name=\"keyword116\"></a><span class=\"keyword\">переменная отношения</span> в любой момент времени содержит некоторое значение- <a name=\"keyword117\"></a><span class=\"keyword\">отношение</span>, в частности, пустое).</p> <div id=\"mark_63\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_66\">Заметим, что в классических <a name=\"keyword118\"></a><span class=\"keyword\">реляционных базах данных</span> после определения <a name=\"keyword119\"></a><span class=\"keyword\">схемы базы данных</span> могли изменяться только значения<a name=\"keyword120\"></a><span class=\"keyword\">переменных отношений</span>. Однако теперь в большинстве реализаций допускается и изменение <a name=\"keyword121\"></a><span class=\"keyword\">схемы базы данных</span>: определение новых и изменение заголовков существующих <a name=\"keyword122\"></a><span class=\"keyword\">переменных отношений</span>. Это принято называть <strong>эволюцией </strong><a name=\"keyword123\"></a><span class=\"keyword\">схемы базы данных</span>.</p> <div id=\"mark_66\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect5\"></a></h3> <h4>Первичный ключ и интуитивная интерпретация реляционных понятий</h4> <p id=\"id_67\"><a name=\"keyword-context12\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword124\"></a><span class=\"keyword\">первичным ключом</span></span> <a name=\"keyword125\"></a><span class=\"keyword\">переменной отношения</span> является такое подмножество<sup>1</sup> <span class=\"texample\">S</span> множества <a name=\"keyword129\"></a><span class=\"keyword\">атрибутов</span> ее заголовка, что в любое время значение <a name=\"keyword130\"></a><span class=\"keyword\">первичного ключа</span> (составное, если в состав <a name=\"keyword131\"></a><span class=\"keyword\">первичного ключа</span> входит более одного <a name=\"keyword132\"></a><span class=\"keyword\">атрибута</span> ) в любом <a name=\"keyword133\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword134\"></a><span class=\"keyword\">тела отношения</span> отличается от значения <a name=\"keyword135\"></a><span class=\"keyword\">первичного ключа</span> в любом другом <a name=\"keyword136\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword137\"></a><span class=\"keyword\">тела</span> этого <a name=\"keyword138\"></a><span class=\"keyword\">отношения</span>, а никакое собственное подмножество<sup>2</sup><span class=\"texample\">S</span> этим свойством не обладает. В следующем разделе мы покажем, что существование <a name=\"keyword139\"></a><span class=\"keyword\">первичного ключа</span> у любого <a name=\"keyword140\"></a><span class=\"keyword\">значения отношения</span>является следствием одного из фундаментальных свойств <a name=\"keyword141\"></a><span class=\"keyword\">отношений</span>, а именно того свойства, что <a name=\"keyword142\"></a><span class=\"keyword\">тело отношения</span> является множеством<a name=\"keyword143\"></a><span class=\"keyword\">кортежей</span>.</p> <div id=\"mark_67\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_78\">Обычным житейским представлением <a name=\"keyword144\"></a><span class=\"keyword\">отношения</span> является <strong>таблица</strong>, <strong>заголовком</strong> которой является схема <a name=\"keyword145\"></a><span class=\"keyword\">отношения</span>, а <strong>строками</strong> &ndash; <a name=\"keyword146\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword147\"></a><span class=\"keyword\">отношения</span> -экземпляра; в этом случае имена <a name=\"keyword148\"></a><span class=\"keyword\">атрибутов</span> соответствуют именам <strong>столбцов</strong> данной таблицы. Поэтому иногда говорят про \"столбцы таблицы\", имея в виду \" <a name=\"keyword149\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword150\"></a><span class=\"keyword\">отношения</span> \".</p> <div id=\"mark_78\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_79\">Конечно, это достаточно грубая терминология, поскольку у обычных таблиц и строки, и столбцы упорядочены, тогда как <a name=\"keyword151\"></a><span class=\"keyword\">атрибуты</span> и <a name=\"keyword152\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword153\"></a><span class=\"keyword\">отношений</span> являются элементами неупорядоченных множеств. Тем не менее, когда мы перейдем к рассмотрению практических вопросов организации <a name=\"keyword154\"></a><span class=\"keyword\">реляционных баз данных</span> и средств управления, то будем использовать эту \"житейскую\" терминологию. Подобной терминологии придерживаются в большинстве коммерческих реляционных СУБД. Иногда также используются термины <strong>файл</strong> как аналог таблицы, <strong>запись</strong> как аналог строки и <strong>поле</strong> как аналог столбца. Напомню, что этой терминологией мы пользовались в лекции 1.</p>',2,' В этом курсе, главным образом, обсуждаются различные аспекты реляционных баз данных. Принято считать, что реляционный подход к организации баз данных был заложен в конце 1960-х гг. Эдгаром Коддом. В последние десятилетия этот подход является наиболее распространенным (с оговоркой, что в называемых в обиходе реляционными системах баз данных, основанных на языке SQL, в действительности нарушаются некоторые важные принципы классического реляционного подхода). Достоинствами реляционного подхода принято считать следующие свойства: реляционный подход основывается на небольшом числе интуитивно понятных абстракций, на основе которых возможно простое моделирование наиболее распространенных предметных областей; эти абстракции могут быть точно и формально определены; теоретическим базисом реляционного подхода к организации баз данных служит простой и мощный математический аппарат теории множеств и математической логики; реляционный подход обеспечивает возможность ненавигационного манипулирования данными без необходимости знания конкретной физической организации баз данных во внешней памяти. Компьютерный мир далеко не сразу признал реляционные системы. В 70-е года прошлого века, когда уже были получены почти все основные теоретические результаты и даже существовали первые прототипы реляционных СУБД, многие авторитетные специалисты отрицали возможность добиться эффективной реализации таких систем. Однако преимущества реляционного подхода и развитие методов и алгоритмов организации и управления реляционными базами данных привели к тому, что к концу 80-х годов реляционные системы заняли на мировом рынке СУБД доминирующее положение. В этой лекции на сравнительно неформальном уровне вводятся основные понятия реляционных баз данных, а также определяется сущность реляционной модели данных. Основной целью лекции является демонстрация простоты и возможности интуитивной интерпретации этих понятий. В следующих лекциях будут приводиться более формальные определения, на которых основана теория реляционных баз данных.',0), 
('Лекция 5: Базисные средства манипулирования реляционными данными: реляционное исчисление',5,'Lecture','<h3>Основные понятия реляционных баз данных</h3> <p id=\"id_1\">Выделим следующие основные понятия <a name=\"keyword1\"></a><span class=\"keyword\">реляционных баз данных</span>: <a name=\"keyword2\"></a><span class=\"keyword\">тип данных</span>, <a name=\"keyword3\"></a><span class=\"keyword\">домен</span>, <a name=\"keyword4\"></a><span class=\"keyword\">атрибут</span>, <a name=\"keyword5\"></a><span class=\"keyword\">кортеж</span>, <a name=\"keyword6\"></a><span class=\"keyword\">отношение</span>, <a name=\"keyword7\"></a><span class=\"keyword\">первичный ключ</span>.</p> <div id=\"mark_1\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_2\">Для начала покажем смысл этих понятий на примере <a name=\"keyword8\"></a><span class=\"keyword\">отношения</span> СЛУЖАЩИЕ, содержащего информацию о служащих некоторого предприятия (<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>).</p> <div id=\"mark_2\" class=\"lecture_mark\">&nbsp;</div> <div id=\"id_3\"><a name=\"image.2.1\"></a> <div><img src=\"http://www.intuit.ru/EDI/14_02_16_4/1455402139-23616/tutorial/157/objects/2/files/2_1.gif\" alt=\"Соотношение основных понятий реляционного подхода\" /></div> <br /><strong>Рис. 2.1. </strong>Соотношение основных понятий реляционного подхода</div> <div id=\"mark_3\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect2\"></a></h3> <h4>Тип данных</h4> <p id=\"id_4\">Значения данных, хранимые в <a name=\"keyword9\"></a><span class=\"keyword\">реляционной базе данных</span>, являются типизированными, т. е. известен тип каждого хранимого значения. Понятие<a name=\"keyword10\"></a><span class=\"keyword\">типа данных</span> в <a name=\"keyword11\"></a><span class=\"keyword\">реляционной модели данных</span> полностью соответствует понятию <a name=\"keyword12\"></a><span class=\"keyword\">типа данных</span> в языках программирования. <a name=\"keyword-context1\"></a>Напомним, что традиционное (нестрогое) определение <span class=\"keyword_def\"><a name=\"keyword13\"></a><span class=\"keyword\">типа данных</span></span> состоит из трех основных компонентов: определение множества значений данного типа; определение набора операций, применимых к значениям типа; определение способа внешнего представления значений типа (литералов).</p> <div id=\"mark_4\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_5\">Обычно в современных <a name=\"keyword14\"></a><span class=\"keyword\">реляционных базах данных</span> допускается хранение символьных, числовых данных (точных и приблизительных), специализированных числовых данных (таких, как \"деньги\"), а также специальных \"темпоральных\" данных (дата, время, временной интервал). Кроме того, в реляционных системах поддерживается возможность определения пользователями собственных <a name=\"keyword15\"></a><span class=\"keyword\">типов данных</span> (более подробно мы обсудим это в лекции 9, курса \"Введение в модель данных SQL\").</p> <div id=\"mark_5\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_6\">В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> мы имеем дело с данными трех <a name=\"keyword16\"></a><span class=\"keyword\">типов</span>: строки символов, целые числа и \"деньги\".</p> <div id=\"mark_6\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect3\"></a></h3> <h4>Домен</h4> <p id=\"id_7\">Понятие <a name=\"keyword17\"></a><span class=\"keyword\">домена</span> более специфично для баз данных, хотя и имеются аналогии с подтипами в некоторых языках программирования (более того, в своем <strong>\"Третьем манифесте\"</strong> Кристофер Дейт и Хью Дарвен вообще ликвидируют различие между <a name=\"keyword18\"></a><span class=\"keyword\">доменом</span> и <a name=\"keyword19\"></a><span class=\"keyword\">типом данных</span> ). В общем виде<a name=\"keyword20\"></a><span class=\"keyword\">домен</span> определяется путем задания некоторого базового <a name=\"keyword21\"></a><span class=\"keyword\">типа данных</span>, к которому относятся элементы <a name=\"keyword22\"></a><span class=\"keyword\">домена</span>, и произвольного логического выражения, применяемого к элементу этого <a name=\"keyword23\"></a><span class=\"keyword\">типа данных</span> ( <span class=\"keyword_def\"><a name=\"keyword24\"></a><span class=\"keyword\">ограничения домена</span></span> ). Элемент данных является элементом <a name=\"keyword25\"></a><span class=\"keyword\">домена</span> в том и только в том случае, если вычисление этого логического выражения дает результат <strong>истина</strong> (для логических значений мы будем попеременно использовать обозначения <strong>истина</strong> и <strong>ложь</strong> или <strong>true</strong> и <strong>false</strong> ). С каждым <a name=\"keyword26\"></a><span class=\"keyword\">доменом</span> связывается имя, уникальное среди имен всех <a name=\"keyword27\"></a><span class=\"keyword\">доменов</span>соответствующей базы данных.</p> <div id=\"mark_7\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_8\"><a name=\"keyword-context3\"></a>Наиболее правильной интуитивной трактовкой понятия <span class=\"keyword_def\"><a name=\"keyword28\"></a><span class=\"keyword\">домена</span></span> является его восприятие как допустимого потенциального, ограниченного подмножества значений данного типа. Например, <a name=\"keyword29\"></a><span class=\"keyword\">домен</span> <span class=\"texample\">ИМЕНА</span> в нашем примере определен на базовом <a name=\"keyword30\"></a><span class=\"keyword\">типе символьных строк</span>, но в число его значений могут входить только те строки, которые могут представлять имена (в частности, для возможности представления русских имен такие строки не могут начинаться с мягкого или твердого знака и не могут быть длиннее, например, 20 символов). Если некоторый <a name=\"keyword31\"></a><span class=\"keyword\">атрибут</span><a name=\"keyword32\"></a><span class=\"keyword\">отношения</span> определяется на некотором <a name=\"keyword33\"></a><span class=\"keyword\">домене</span> (как, например, на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword34\"></a><span class=\"keyword\">атрибут</span> <span class=\"texample\">СЛУ_ИМЯ</span> определяется на <a name=\"keyword35\"></a><span class=\"keyword\">домене</span> <span class=\"texample\">ИМЕНА</span> ), то в дальнейшем <a name=\"keyword36\"></a><span class=\"keyword\">ограничение домена</span> играет роль <a name=\"keyword37\"></a><span class=\"keyword\">ограничения целостности</span>, накладываемого на значения этого <a name=\"keyword38\"></a><span class=\"keyword\">атрибута</span>.</p> <div id=\"mark_8\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_12\">Следует отметить также семантическую нагрузку понятия <a name=\"keyword39\"></a><span class=\"keyword\">домена</span>: данные считаются сравнимыми только в том случае, когда они относятся к одному <a name=\"keyword40\"></a><span class=\"keyword\">домену</span>. В нашем примере значения <a name=\"keyword41\"></a><span class=\"keyword\">доменов</span> <span class=\"texample\">НОМЕРА ПРОПУСКОВ</span> и <span class=\"texample\">НОМЕРА ОТДЕЛОВ</span> относятся к типу целых чисел, но не являются сравнимыми (допускать их сравнение было бы бессмысленно).</p> <div id=\"mark_12\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect4\"></a></h3> <h4>Заголовок отношения, кортеж, тело отношения, значение отношения, переменная отношения</h4> <p id=\"id_15\">Понятие <a name=\"keyword42\"></a><span class=\"keyword\">отношения</span> является наиболее фундаментальным в <a name=\"keyword43\"></a><span class=\"keyword\">реляционном подходе к организации баз данных</span>, поскольку <span class=\"texample\">n</span> -арное<a name=\"keyword44\"></a><span class=\"keyword\">отношение</span> является единственной родовой структурой данных, хранящихся в <a name=\"keyword45\"></a><span class=\"keyword\">реляционной базе данных</span>. Это отражено и в общем названии<a name=\"keyword46\"></a><span class=\"keyword\">подхода</span> &ndash; термин <strong>реляционный (relational)</strong> происходит от <strong>relation (отношение)</strong>. Однако сам термин <a name=\"keyword47\"></a><span class=\"keyword\">отношение</span> является исключительно неточным, поскольку, говоря про любые сохраняемые данные, мы должны иметь в виду <strong>тип</strong> этих данных, <strong>значения</strong> этого <a name=\"keyword48\"></a><span class=\"keyword\">типа</span> и <strong>переменные</strong>, в которых сохраняются значения. Соответственно, для уточнения термина <a name=\"keyword49\"></a><span class=\"keyword\">отношение</span> выделяются понятия <a name=\"keyword50\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword51\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword52\"></a><span class=\"keyword\">переменной отношения</span>. Кроме того, нам потребуется вспомогательное понятие <a name=\"keyword53\"></a><span class=\"keyword\">кортежа</span>.</p> <div id=\"mark_15\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_17\"><a name=\"keyword-context4\"></a>Итак, <span class=\"keyword_def\"><a name=\"keyword54\"></a><span class=\"keyword\">заголовком (или схемой) отношения</span></span> <span class=\"texample\">r</span> ( <span class=\"texample\">Hr</span> ) называется конечное множество упорядоченных пар вида <span class=\"texample\">&lt;A, T&gt;</span>, где <span class=\"texample\">A</span>называется именем <a name=\"keyword55\"></a><span class=\"keyword\">атрибута</span>, а <span class=\"texample\">T</span> обозначает имя некоторого базового <a name=\"keyword56\"></a><span class=\"keyword\">типа</span> или ранее определенного <a name=\"keyword57\"></a><span class=\"keyword\">домена</span> . По определению требуется, чтобы все имена <a name=\"keyword58\"></a><span class=\"keyword\">атрибутов</span> в <a name=\"keyword59\"></a><span class=\"keyword\">заголовке отношения</span> были различны. В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword60\"></a><span class=\"keyword\">заголовком отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> является множество пар <span class=\"texample\">{&lt;слу_номер, номера_пропусков&gt;, &lt;слу_имя, имена&gt;, &lt;слу_зарп, размеры_выплат&gt;, &lt;слу_отд_номер, номера_отделов&gt;}</span>.</p> <div id=\"mark_17\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_25\">Если все <a name=\"keyword61\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword62\"></a><span class=\"keyword\">заголовка отношения</span> определены на разных <a name=\"keyword63\"></a><span class=\"keyword\">доменах</span>, то, чтобы не плодить лишних имен, разумно использовать для именования <a name=\"keyword64\"></a><span class=\"keyword\">атрибутов</span> имена соответствующих <a name=\"keyword65\"></a><span class=\"keyword\">доменов</span> (не забывая, конечно, о том, что это всего лишь удобный способ именования, который не устраняет различия между понятиями <a name=\"keyword66\"></a><span class=\"keyword\">домена</span> и <a name=\"keyword67\"></a><span class=\"keyword\">атрибута</span> ).</p> <div id=\"mark_25\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_26\"><a name=\"keyword-context5\"></a><span class=\"keyword_def\"><a name=\"keyword68\"></a><span class=\"keyword\">Кортежем</span></span> <span class=\"texample\">tr</span>, соответствующим <a name=\"keyword69\"></a><span class=\"keyword\">заголовку</span> <span class=\"texample\">Hr</span>, называется множество упорядоченных триплетов вида <span class=\"texample\">&lt;A, T, v&gt;</span>, по одному такому триплету для каждого <a name=\"keyword70\"></a><span class=\"keyword\">атрибута</span> в <span class=\"texample\">Hr</span> . Третий элемент &ndash; <span class=\"texample\">v</span> &ndash; триплета <span class=\"texample\">&lt;A, T, v&gt;</span> должен являться допустимым значением <a name=\"keyword71\"></a><span class=\"keyword\">типа данных</span>или <a name=\"keyword72\"></a><span class=\"keyword\">домена</span> <span class=\"texample\">T</span>. <a name=\"keyword73\"></a><span class=\"keyword\">Заголовку отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> соответствуют, например, следующие <a name=\"keyword74\"></a><span class=\"keyword\">кортежи</span>: <span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2934&gt;, &lt;слу_имя, имена, Иванов&gt;, &lt;слу_зарп, размеры_выплат, 22.000&gt;, &lt;слу_отд_номер, номера_отделов, 310&gt;}</span>,<span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2940&gt;, &lt;слу_имя, имена, Кузнецов&gt;, &lt;слу_зарп, размеры_выплат, 35.000&gt;, &lt;слу_отд_номер, номера_отделов, 320&gt;}</span>.</p> <div id=\"mark_26\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_37\"><a name=\"keyword-context6\"></a><span class=\"keyword_def\"><a name=\"keyword75\"></a><span class=\"keyword\">Телом</span></span> <span class=\"texample\">Br</span> <a name=\"keyword76\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется произвольное множество <a name=\"keyword77\"></a><span class=\"keyword\">кортежей</span> <span class=\"texample\">tr</span> . Одно из возможных <a name=\"keyword78\"></a><span class=\"keyword\">тел отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">на рис. 2.1</a>. Заметим, что в общем случае, как это демонстрируют, в частности, <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> и пример предыдущего абзаца, могут существовать такие <a name=\"keyword79\"></a><span class=\"keyword\">кортежи</span> <span class=\"texample\">tr</span>, которые соответствуют <span class=\"texample\">Hr</span>, но не входят в <span class=\"texample\">Br</span>.</p> <div id=\"mark_37\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_45\"><a name=\"keyword-context7\"></a><span class=\"keyword_def\"><a name=\"keyword80\"></a><span class=\"keyword\">Значением</span></span> <span class=\"texample\">Vr</span> <a name=\"keyword81\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется пара множеств <span class=\"texample\">Hr</span> и <span class=\"texample\">Br</span> . Одно из допустимых <a name=\"keyword82\"></a><span class=\"keyword\">значений отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано на<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>.</p> <div id=\"mark_45\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_51\">В изменчивой <a name=\"keyword83\"></a><span class=\"keyword\">реляционной базе данных</span> хранятся <a name=\"keyword84\"></a><span class=\"keyword\">отношения</span>, <a name=\"keyword85\"></a><span class=\"keyword\">значения</span> которых изменяются во времени. <a name=\"keyword-context8\"></a><span class=\"keyword_def\"><a name=\"keyword86\"></a><span class=\"keyword\">Переменной</span></span> <span class=\"texample\">VARr</span> называется именованный контейнер, который может содержать любое допустимое <a name=\"keyword87\"></a><span class=\"keyword\">значение</span> <span class=\"texample\">Vr</span> . Естественно, что при определении любой <span class=\"texample\">VARr</span>требуется указывать соответствующий <a name=\"keyword88\"></a><span class=\"keyword\">заголовок отношения</span> <span class=\"texample\">Hr</span>.</p> <div id=\"mark_51\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_56\">Здесь стоит подчеркнуть, что любая принятая на практике операция обновления <a name=\"keyword89\"></a><span class=\"keyword\">базы данных</span> &ndash; <span class=\"texample\">INSERT</span> (вставка <a name=\"keyword90\"></a><span class=\"keyword\">кортежа</span> в <a name=\"keyword91\"></a><span class=\"keyword\">переменную отношения</span> ), <span class=\"texample\">DELETE</span> (удаление <a name=\"keyword92\"></a><span class=\"keyword\">кортежа</span> из значения- <a name=\"keyword93\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword94\"></a><span class=\"keyword\">переменной отношения</span> ) и <span class=\"texample\">UPDATE</span> (модификация <a name=\"keyword95\"></a><span class=\"keyword\">кортежа</span> значения-<a name=\"keyword96\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword97\"></a><span class=\"keyword\">переменной отношения</span> ) &ndash; с модельной точки зрения является операцией присваивания <a name=\"keyword98\"></a><span class=\"keyword\">переменной отношения</span> некоторого нового значения- <a name=\"keyword99\"></a><span class=\"keyword\">отношения</span>. Это совсем не означает, что перечисленные операции должны выполняться именно таким образом в СУБД: главное, чтобы результат операций соответствовал этой модельной семантике.</p> <div id=\"mark_56\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_60\">Заметим, что в дальнейшем в тех случаях, когда точный смысл термина понятен из контекста, мы будем использовать термин <a name=\"keyword100\"></a><span class=\"keyword\">отношение</span> как в смысле <a name=\"keyword101\"></a><span class=\"keyword\">значение отношения</span>, так и в смысле <a name=\"keyword102\"></a><span class=\"keyword\">переменная отношения</span>.</p> <div id=\"mark_60\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_61\"><a name=\"keyword-context9\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword103\"></a><span class=\"keyword\">степенью, или \"арностью\"</span></span>, <a name=\"keyword104\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword105\"></a><span class=\"keyword\">кортежа</span>, соответствующего этому <a name=\"keyword106\"></a><span class=\"keyword\">заголовку</span>, <a name=\"keyword107\"></a><span class=\"keyword\">тела отношения</span>,<a name=\"keyword108\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword109\"></a><span class=\"keyword\">переменной отношения</span> является мощность <a name=\"keyword110\"></a><span class=\"keyword\">заголовка отношения</span> . Например, <a name=\"keyword111\"></a><span class=\"keyword\">степень отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> равна четырем, т. е. оно является 4-арным ( <strong>кватернарным</strong> ).</p> <div id=\"mark_61\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_63\"><a name=\"keyword-context10\"></a>При приведенных определениях разумно считать <span class=\"keyword_def\"><a name=\"keyword112\"></a><span class=\"keyword\">схемой реляционной базы данных</span></span> набор пар <span class=\"texample\">&lt;имя_VARr, Hr&gt;</span>, включающий имена и заголовки всех <a name=\"keyword113\"></a><span class=\"keyword\">переменных отношения</span>, которые определены в <a name=\"keyword114\"></a><span class=\"keyword\">базе данных</span> . <a name=\"keyword-context11\"></a><span class=\"keyword_def\"><a name=\"keyword115\"></a><span class=\"keyword\">Реляционная база данных</span></span> &ndash; это набор пар <span class=\"texample\">&lt;VARr, Hr&gt;</span>(конечно, каждая <a name=\"keyword116\"></a><span class=\"keyword\">переменная отношения</span> в любой момент времени содержит некоторое значение- <a name=\"keyword117\"></a><span class=\"keyword\">отношение</span>, в частности, пустое).</p> <div id=\"mark_63\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_66\">Заметим, что в классических <a name=\"keyword118\"></a><span class=\"keyword\">реляционных базах данных</span> после определения <a name=\"keyword119\"></a><span class=\"keyword\">схемы базы данных</span> могли изменяться только значения<a name=\"keyword120\"></a><span class=\"keyword\">переменных отношений</span>. Однако теперь в большинстве реализаций допускается и изменение <a name=\"keyword121\"></a><span class=\"keyword\">схемы базы данных</span>: определение новых и изменение заголовков существующих <a name=\"keyword122\"></a><span class=\"keyword\">переменных отношений</span>. Это принято называть <strong>эволюцией </strong><a name=\"keyword123\"></a><span class=\"keyword\">схемы базы данных</span>.</p> <div id=\"mark_66\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect5\"></a></h3> <h4>Первичный ключ и интуитивная интерпретация реляционных понятий</h4> <p id=\"id_67\"><a name=\"keyword-context12\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword124\"></a><span class=\"keyword\">первичным ключом</span></span> <a name=\"keyword125\"></a><span class=\"keyword\">переменной отношения</span> является такое подмножество<sup>1</sup> <span class=\"texample\">S</span> множества <a name=\"keyword129\"></a><span class=\"keyword\">атрибутов</span> ее заголовка, что в любое время значение <a name=\"keyword130\"></a><span class=\"keyword\">первичного ключа</span> (составное, если в состав <a name=\"keyword131\"></a><span class=\"keyword\">первичного ключа</span> входит более одного <a name=\"keyword132\"></a><span class=\"keyword\">атрибута</span> ) в любом <a name=\"keyword133\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword134\"></a><span class=\"keyword\">тела отношения</span> отличается от значения <a name=\"keyword135\"></a><span class=\"keyword\">первичного ключа</span> в любом другом <a name=\"keyword136\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword137\"></a><span class=\"keyword\">тела</span> этого <a name=\"keyword138\"></a><span class=\"keyword\">отношения</span>, а никакое собственное подмножество<sup>2</sup><span class=\"texample\">S</span> этим свойством не обладает. В следующем разделе мы покажем, что существование <a name=\"keyword139\"></a><span class=\"keyword\">первичного ключа</span> у любого <a name=\"keyword140\"></a><span class=\"keyword\">значения отношения</span>является следствием одного из фундаментальных свойств <a name=\"keyword141\"></a><span class=\"keyword\">отношений</span>, а именно того свойства, что <a name=\"keyword142\"></a><span class=\"keyword\">тело отношения</span> является множеством<a name=\"keyword143\"></a><span class=\"keyword\">кортежей</span>.</p> <div id=\"mark_67\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_78\">Обычным житейским представлением <a name=\"keyword144\"></a><span class=\"keyword\">отношения</span> является <strong>таблица</strong>, <strong>заголовком</strong> которой является схема <a name=\"keyword145\"></a><span class=\"keyword\">отношения</span>, а <strong>строками</strong> &ndash; <a name=\"keyword146\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword147\"></a><span class=\"keyword\">отношения</span> -экземпляра; в этом случае имена <a name=\"keyword148\"></a><span class=\"keyword\">атрибутов</span> соответствуют именам <strong>столбцов</strong> данной таблицы. Поэтому иногда говорят про \"столбцы таблицы\", имея в виду \" <a name=\"keyword149\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword150\"></a><span class=\"keyword\">отношения</span> \".</p> <div id=\"mark_78\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_79\">Конечно, это достаточно грубая терминология, поскольку у обычных таблиц и строки, и столбцы упорядочены, тогда как <a name=\"keyword151\"></a><span class=\"keyword\">атрибуты</span> и <a name=\"keyword152\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword153\"></a><span class=\"keyword\">отношений</span> являются элементами неупорядоченных множеств. Тем не менее, когда мы перейдем к рассмотрению практических вопросов организации <a name=\"keyword154\"></a><span class=\"keyword\">реляционных баз данных</span> и средств управления, то будем использовать эту \"житейскую\" терминологию. Подобной терминологии придерживаются в большинстве коммерческих реляционных СУБД. Иногда также используются термины <strong>файл</strong> как аналог таблицы, <strong>запись</strong> как аналог строки и <strong>поле</strong> как аналог столбца. Напомню, что этой терминологией мы пользовались в лекции 1.</p>',2,' В этом курсе, главным образом, обсуждаются различные аспекты реляционных баз данных. Принято считать, что реляционный подход к организации баз данных был заложен в конце 1960-х гг. Эдгаром Коддом. В последние десятилетия этот подход является наиболее распространенным (с оговоркой, что в называемых в обиходе реляционными системах баз данных, основанных на языке SQL, в действительности нарушаются некоторые важные принципы классического реляционного подхода). Достоинствами реляционного подхода принято считать следующие свойства: реляционный подход основывается на небольшом числе интуитивно понятных абстракций, на основе которых возможно простое моделирование наиболее распространенных предметных областей; эти абстракции могут быть точно и формально определены; теоретическим базисом реляционного подхода к организации баз данных служит простой и мощный математический аппарат теории множеств и математической логики; реляционный подход обеспечивает возможность ненавигационного манипулирования данными без необходимости знания конкретной физической организации баз данных во внешней памяти. Компьютерный мир далеко не сразу признал реляционные системы. В 70-е года прошлого века, когда уже были получены почти все основные теоретические результаты и даже существовали первые прототипы реляционных СУБД, многие авторитетные специалисты отрицали возможность добиться эффективной реализации таких систем. Однако преимущества реляционного подхода и развитие методов и алгоритмов организации и управления реляционными базами данных привели к тому, что к концу 80-х годов реляционные системы заняли на мировом рынке СУБД доминирующее положение. В этой лекции на сравнительно неформальном уровне вводятся основные понятия реляционных баз данных, а также определяется сущность реляционной модели данных. Основной целью лекции является демонстрация простоты и возможности интуитивной интерпретации этих понятий. В следующих лекциях будут приводиться более формальные определения, на которых основана теория реляционных баз данных.',0), 
('Лекция 6: Элементы теории реляционных баз данных: функциональные зависимости и декомпозиция без потерь',6,'Lecture','<h3>Основные понятия реляционных баз данных</h3> <p id=\"id_1\">Выделим следующие основные понятия <a name=\"keyword1\"></a><span class=\"keyword\">реляционных баз данных</span>: <a name=\"keyword2\"></a><span class=\"keyword\">тип данных</span>, <a name=\"keyword3\"></a><span class=\"keyword\">домен</span>, <a name=\"keyword4\"></a><span class=\"keyword\">атрибут</span>, <a name=\"keyword5\"></a><span class=\"keyword\">кортеж</span>, <a name=\"keyword6\"></a><span class=\"keyword\">отношение</span>, <a name=\"keyword7\"></a><span class=\"keyword\">первичный ключ</span>.</p> <div id=\"mark_1\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_2\">Для начала покажем смысл этих понятий на примере <a name=\"keyword8\"></a><span class=\"keyword\">отношения</span> СЛУЖАЩИЕ, содержащего информацию о служащих некоторого предприятия (<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>).</p> <div id=\"mark_2\" class=\"lecture_mark\">&nbsp;</div> <div id=\"id_3\"><a name=\"image.2.1\"></a> <div><img src=\"http://www.intuit.ru/EDI/14_02_16_4/1455402139-23616/tutorial/157/objects/2/files/2_1.gif\" alt=\"Соотношение основных понятий реляционного подхода\" /></div> <br /><strong>Рис. 2.1. </strong>Соотношение основных понятий реляционного подхода</div> <div id=\"mark_3\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect2\"></a></h3> <h4>Тип данных</h4> <p id=\"id_4\">Значения данных, хранимые в <a name=\"keyword9\"></a><span class=\"keyword\">реляционной базе данных</span>, являются типизированными, т. е. известен тип каждого хранимого значения. Понятие<a name=\"keyword10\"></a><span class=\"keyword\">типа данных</span> в <a name=\"keyword11\"></a><span class=\"keyword\">реляционной модели данных</span> полностью соответствует понятию <a name=\"keyword12\"></a><span class=\"keyword\">типа данных</span> в языках программирования. <a name=\"keyword-context1\"></a>Напомним, что традиционное (нестрогое) определение <span class=\"keyword_def\"><a name=\"keyword13\"></a><span class=\"keyword\">типа данных</span></span> состоит из трех основных компонентов: определение множества значений данного типа; определение набора операций, применимых к значениям типа; определение способа внешнего представления значений типа (литералов).</p> <div id=\"mark_4\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_5\">Обычно в современных <a name=\"keyword14\"></a><span class=\"keyword\">реляционных базах данных</span> допускается хранение символьных, числовых данных (точных и приблизительных), специализированных числовых данных (таких, как \"деньги\"), а также специальных \"темпоральных\" данных (дата, время, временной интервал). Кроме того, в реляционных системах поддерживается возможность определения пользователями собственных <a name=\"keyword15\"></a><span class=\"keyword\">типов данных</span> (более подробно мы обсудим это в лекции 9, курса \"Введение в модель данных SQL\").</p> <div id=\"mark_5\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_6\">В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> мы имеем дело с данными трех <a name=\"keyword16\"></a><span class=\"keyword\">типов</span>: строки символов, целые числа и \"деньги\".</p> <div id=\"mark_6\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect3\"></a></h3> <h4>Домен</h4> <p id=\"id_7\">Понятие <a name=\"keyword17\"></a><span class=\"keyword\">домена</span> более специфично для баз данных, хотя и имеются аналогии с подтипами в некоторых языках программирования (более того, в своем <strong>\"Третьем манифесте\"</strong> Кристофер Дейт и Хью Дарвен вообще ликвидируют различие между <a name=\"keyword18\"></a><span class=\"keyword\">доменом</span> и <a name=\"keyword19\"></a><span class=\"keyword\">типом данных</span> ). В общем виде<a name=\"keyword20\"></a><span class=\"keyword\">домен</span> определяется путем задания некоторого базового <a name=\"keyword21\"></a><span class=\"keyword\">типа данных</span>, к которому относятся элементы <a name=\"keyword22\"></a><span class=\"keyword\">домена</span>, и произвольного логического выражения, применяемого к элементу этого <a name=\"keyword23\"></a><span class=\"keyword\">типа данных</span> ( <span class=\"keyword_def\"><a name=\"keyword24\"></a><span class=\"keyword\">ограничения домена</span></span> ). Элемент данных является элементом <a name=\"keyword25\"></a><span class=\"keyword\">домена</span> в том и только в том случае, если вычисление этого логического выражения дает результат <strong>истина</strong> (для логических значений мы будем попеременно использовать обозначения <strong>истина</strong> и <strong>ложь</strong> или <strong>true</strong> и <strong>false</strong> ). С каждым <a name=\"keyword26\"></a><span class=\"keyword\">доменом</span> связывается имя, уникальное среди имен всех <a name=\"keyword27\"></a><span class=\"keyword\">доменов</span>соответствующей базы данных.</p> <div id=\"mark_7\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_8\"><a name=\"keyword-context3\"></a>Наиболее правильной интуитивной трактовкой понятия <span class=\"keyword_def\"><a name=\"keyword28\"></a><span class=\"keyword\">домена</span></span> является его восприятие как допустимого потенциального, ограниченного подмножества значений данного типа. Например, <a name=\"keyword29\"></a><span class=\"keyword\">домен</span> <span class=\"texample\">ИМЕНА</span> в нашем примере определен на базовом <a name=\"keyword30\"></a><span class=\"keyword\">типе символьных строк</span>, но в число его значений могут входить только те строки, которые могут представлять имена (в частности, для возможности представления русских имен такие строки не могут начинаться с мягкого или твердого знака и не могут быть длиннее, например, 20 символов). Если некоторый <a name=\"keyword31\"></a><span class=\"keyword\">атрибут</span><a name=\"keyword32\"></a><span class=\"keyword\">отношения</span> определяется на некотором <a name=\"keyword33\"></a><span class=\"keyword\">домене</span> (как, например, на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword34\"></a><span class=\"keyword\">атрибут</span> <span class=\"texample\">СЛУ_ИМЯ</span> определяется на <a name=\"keyword35\"></a><span class=\"keyword\">домене</span> <span class=\"texample\">ИМЕНА</span> ), то в дальнейшем <a name=\"keyword36\"></a><span class=\"keyword\">ограничение домена</span> играет роль <a name=\"keyword37\"></a><span class=\"keyword\">ограничения целостности</span>, накладываемого на значения этого <a name=\"keyword38\"></a><span class=\"keyword\">атрибута</span>.</p> <div id=\"mark_8\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_12\">Следует отметить также семантическую нагрузку понятия <a name=\"keyword39\"></a><span class=\"keyword\">домена</span>: данные считаются сравнимыми только в том случае, когда они относятся к одному <a name=\"keyword40\"></a><span class=\"keyword\">домену</span>. В нашем примере значения <a name=\"keyword41\"></a><span class=\"keyword\">доменов</span> <span class=\"texample\">НОМЕРА ПРОПУСКОВ</span> и <span class=\"texample\">НОМЕРА ОТДЕЛОВ</span> относятся к типу целых чисел, но не являются сравнимыми (допускать их сравнение было бы бессмысленно).</p> <div id=\"mark_12\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect4\"></a></h3> <h4>Заголовок отношения, кортеж, тело отношения, значение отношения, переменная отношения</h4> <p id=\"id_15\">Понятие <a name=\"keyword42\"></a><span class=\"keyword\">отношения</span> является наиболее фундаментальным в <a name=\"keyword43\"></a><span class=\"keyword\">реляционном подходе к организации баз данных</span>, поскольку <span class=\"texample\">n</span> -арное<a name=\"keyword44\"></a><span class=\"keyword\">отношение</span> является единственной родовой структурой данных, хранящихся в <a name=\"keyword45\"></a><span class=\"keyword\">реляционной базе данных</span>. Это отражено и в общем названии<a name=\"keyword46\"></a><span class=\"keyword\">подхода</span> &ndash; термин <strong>реляционный (relational)</strong> происходит от <strong>relation (отношение)</strong>. Однако сам термин <a name=\"keyword47\"></a><span class=\"keyword\">отношение</span> является исключительно неточным, поскольку, говоря про любые сохраняемые данные, мы должны иметь в виду <strong>тип</strong> этих данных, <strong>значения</strong> этого <a name=\"keyword48\"></a><span class=\"keyword\">типа</span> и <strong>переменные</strong>, в которых сохраняются значения. Соответственно, для уточнения термина <a name=\"keyword49\"></a><span class=\"keyword\">отношение</span> выделяются понятия <a name=\"keyword50\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword51\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword52\"></a><span class=\"keyword\">переменной отношения</span>. Кроме того, нам потребуется вспомогательное понятие <a name=\"keyword53\"></a><span class=\"keyword\">кортежа</span>.</p> <div id=\"mark_15\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_17\"><a name=\"keyword-context4\"></a>Итак, <span class=\"keyword_def\"><a name=\"keyword54\"></a><span class=\"keyword\">заголовком (или схемой) отношения</span></span> <span class=\"texample\">r</span> ( <span class=\"texample\">Hr</span> ) называется конечное множество упорядоченных пар вида <span class=\"texample\">&lt;A, T&gt;</span>, где <span class=\"texample\">A</span>называется именем <a name=\"keyword55\"></a><span class=\"keyword\">атрибута</span>, а <span class=\"texample\">T</span> обозначает имя некоторого базового <a name=\"keyword56\"></a><span class=\"keyword\">типа</span> или ранее определенного <a name=\"keyword57\"></a><span class=\"keyword\">домена</span> . По определению требуется, чтобы все имена <a name=\"keyword58\"></a><span class=\"keyword\">атрибутов</span> в <a name=\"keyword59\"></a><span class=\"keyword\">заголовке отношения</span> были различны. В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword60\"></a><span class=\"keyword\">заголовком отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> является множество пар <span class=\"texample\">{&lt;слу_номер, номера_пропусков&gt;, &lt;слу_имя, имена&gt;, &lt;слу_зарп, размеры_выплат&gt;, &lt;слу_отд_номер, номера_отделов&gt;}</span>.</p> <div id=\"mark_17\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_25\">Если все <a name=\"keyword61\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword62\"></a><span class=\"keyword\">заголовка отношения</span> определены на разных <a name=\"keyword63\"></a><span class=\"keyword\">доменах</span>, то, чтобы не плодить лишних имен, разумно использовать для именования <a name=\"keyword64\"></a><span class=\"keyword\">атрибутов</span> имена соответствующих <a name=\"keyword65\"></a><span class=\"keyword\">доменов</span> (не забывая, конечно, о том, что это всего лишь удобный способ именования, который не устраняет различия между понятиями <a name=\"keyword66\"></a><span class=\"keyword\">домена</span> и <a name=\"keyword67\"></a><span class=\"keyword\">атрибута</span> ).</p> <div id=\"mark_25\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_26\"><a name=\"keyword-context5\"></a><span class=\"keyword_def\"><a name=\"keyword68\"></a><span class=\"keyword\">Кортежем</span></span> <span class=\"texample\">tr</span>, соответствующим <a name=\"keyword69\"></a><span class=\"keyword\">заголовку</span> <span class=\"texample\">Hr</span>, называется множество упорядоченных триплетов вида <span class=\"texample\">&lt;A, T, v&gt;</span>, по одному такому триплету для каждого <a name=\"keyword70\"></a><span class=\"keyword\">атрибута</span> в <span class=\"texample\">Hr</span> . Третий элемент &ndash; <span class=\"texample\">v</span> &ndash; триплета <span class=\"texample\">&lt;A, T, v&gt;</span> должен являться допустимым значением <a name=\"keyword71\"></a><span class=\"keyword\">типа данных</span>или <a name=\"keyword72\"></a><span class=\"keyword\">домена</span> <span class=\"texample\">T</span>. <a name=\"keyword73\"></a><span class=\"keyword\">Заголовку отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> соответствуют, например, следующие <a name=\"keyword74\"></a><span class=\"keyword\">кортежи</span>: <span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2934&gt;, &lt;слу_имя, имена, Иванов&gt;, &lt;слу_зарп, размеры_выплат, 22.000&gt;, &lt;слу_отд_номер, номера_отделов, 310&gt;}</span>,<span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2940&gt;, &lt;слу_имя, имена, Кузнецов&gt;, &lt;слу_зарп, размеры_выплат, 35.000&gt;, &lt;слу_отд_номер, номера_отделов, 320&gt;}</span>.</p> <div id=\"mark_26\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_37\"><a name=\"keyword-context6\"></a><span class=\"keyword_def\"><a name=\"keyword75\"></a><span class=\"keyword\">Телом</span></span> <span class=\"texample\">Br</span> <a name=\"keyword76\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется произвольное множество <a name=\"keyword77\"></a><span class=\"keyword\">кортежей</span> <span class=\"texample\">tr</span> . Одно из возможных <a name=\"keyword78\"></a><span class=\"keyword\">тел отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">на рис. 2.1</a>. Заметим, что в общем случае, как это демонстрируют, в частности, <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> и пример предыдущего абзаца, могут существовать такие <a name=\"keyword79\"></a><span class=\"keyword\">кортежи</span> <span class=\"texample\">tr</span>, которые соответствуют <span class=\"texample\">Hr</span>, но не входят в <span class=\"texample\">Br</span>.</p> <div id=\"mark_37\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_45\"><a name=\"keyword-context7\"></a><span class=\"keyword_def\"><a name=\"keyword80\"></a><span class=\"keyword\">Значением</span></span> <span class=\"texample\">Vr</span> <a name=\"keyword81\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется пара множеств <span class=\"texample\">Hr</span> и <span class=\"texample\">Br</span> . Одно из допустимых <a name=\"keyword82\"></a><span class=\"keyword\">значений отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано на<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>.</p> <div id=\"mark_45\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_51\">В изменчивой <a name=\"keyword83\"></a><span class=\"keyword\">реляционной базе данных</span> хранятся <a name=\"keyword84\"></a><span class=\"keyword\">отношения</span>, <a name=\"keyword85\"></a><span class=\"keyword\">значения</span> которых изменяются во времени. <a name=\"keyword-context8\"></a><span class=\"keyword_def\"><a name=\"keyword86\"></a><span class=\"keyword\">Переменной</span></span> <span class=\"texample\">VARr</span> называется именованный контейнер, который может содержать любое допустимое <a name=\"keyword87\"></a><span class=\"keyword\">значение</span> <span class=\"texample\">Vr</span> . Естественно, что при определении любой <span class=\"texample\">VARr</span>требуется указывать соответствующий <a name=\"keyword88\"></a><span class=\"keyword\">заголовок отношения</span> <span class=\"texample\">Hr</span>.</p> <div id=\"mark_51\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_56\">Здесь стоит подчеркнуть, что любая принятая на практике операция обновления <a name=\"keyword89\"></a><span class=\"keyword\">базы данных</span> &ndash; <span class=\"texample\">INSERT</span> (вставка <a name=\"keyword90\"></a><span class=\"keyword\">кортежа</span> в <a name=\"keyword91\"></a><span class=\"keyword\">переменную отношения</span> ), <span class=\"texample\">DELETE</span> (удаление <a name=\"keyword92\"></a><span class=\"keyword\">кортежа</span> из значения- <a name=\"keyword93\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword94\"></a><span class=\"keyword\">переменной отношения</span> ) и <span class=\"texample\">UPDATE</span> (модификация <a name=\"keyword95\"></a><span class=\"keyword\">кортежа</span> значения-<a name=\"keyword96\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword97\"></a><span class=\"keyword\">переменной отношения</span> ) &ndash; с модельной точки зрения является операцией присваивания <a name=\"keyword98\"></a><span class=\"keyword\">переменной отношения</span> некоторого нового значения- <a name=\"keyword99\"></a><span class=\"keyword\">отношения</span>. Это совсем не означает, что перечисленные операции должны выполняться именно таким образом в СУБД: главное, чтобы результат операций соответствовал этой модельной семантике.</p> <div id=\"mark_56\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_60\">Заметим, что в дальнейшем в тех случаях, когда точный смысл термина понятен из контекста, мы будем использовать термин <a name=\"keyword100\"></a><span class=\"keyword\">отношение</span> как в смысле <a name=\"keyword101\"></a><span class=\"keyword\">значение отношения</span>, так и в смысле <a name=\"keyword102\"></a><span class=\"keyword\">переменная отношения</span>.</p> <div id=\"mark_60\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_61\"><a name=\"keyword-context9\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword103\"></a><span class=\"keyword\">степенью, или \"арностью\"</span></span>, <a name=\"keyword104\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword105\"></a><span class=\"keyword\">кортежа</span>, соответствующего этому <a name=\"keyword106\"></a><span class=\"keyword\">заголовку</span>, <a name=\"keyword107\"></a><span class=\"keyword\">тела отношения</span>,<a name=\"keyword108\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword109\"></a><span class=\"keyword\">переменной отношения</span> является мощность <a name=\"keyword110\"></a><span class=\"keyword\">заголовка отношения</span> . Например, <a name=\"keyword111\"></a><span class=\"keyword\">степень отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> равна четырем, т. е. оно является 4-арным ( <strong>кватернарным</strong> ).</p> <div id=\"mark_61\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_63\"><a name=\"keyword-context10\"></a>При приведенных определениях разумно считать <span class=\"keyword_def\"><a name=\"keyword112\"></a><span class=\"keyword\">схемой реляционной базы данных</span></span> набор пар <span class=\"texample\">&lt;имя_VARr, Hr&gt;</span>, включающий имена и заголовки всех <a name=\"keyword113\"></a><span class=\"keyword\">переменных отношения</span>, которые определены в <a name=\"keyword114\"></a><span class=\"keyword\">базе данных</span> . <a name=\"keyword-context11\"></a><span class=\"keyword_def\"><a name=\"keyword115\"></a><span class=\"keyword\">Реляционная база данных</span></span> &ndash; это набор пар <span class=\"texample\">&lt;VARr, Hr&gt;</span>(конечно, каждая <a name=\"keyword116\"></a><span class=\"keyword\">переменная отношения</span> в любой момент времени содержит некоторое значение- <a name=\"keyword117\"></a><span class=\"keyword\">отношение</span>, в частности, пустое).</p> <div id=\"mark_63\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_66\">Заметим, что в классических <a name=\"keyword118\"></a><span class=\"keyword\">реляционных базах данных</span> после определения <a name=\"keyword119\"></a><span class=\"keyword\">схемы базы данных</span> могли изменяться только значения<a name=\"keyword120\"></a><span class=\"keyword\">переменных отношений</span>. Однако теперь в большинстве реализаций допускается и изменение <a name=\"keyword121\"></a><span class=\"keyword\">схемы базы данных</span>: определение новых и изменение заголовков существующих <a name=\"keyword122\"></a><span class=\"keyword\">переменных отношений</span>. Это принято называть <strong>эволюцией </strong><a name=\"keyword123\"></a><span class=\"keyword\">схемы базы данных</span>.</p> <div id=\"mark_66\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect5\"></a></h3> <h4>Первичный ключ и интуитивная интерпретация реляционных понятий</h4> <p id=\"id_67\"><a name=\"keyword-context12\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword124\"></a><span class=\"keyword\">первичным ключом</span></span> <a name=\"keyword125\"></a><span class=\"keyword\">переменной отношения</span> является такое подмножество<sup>1</sup> <span class=\"texample\">S</span> множества <a name=\"keyword129\"></a><span class=\"keyword\">атрибутов</span> ее заголовка, что в любое время значение <a name=\"keyword130\"></a><span class=\"keyword\">первичного ключа</span> (составное, если в состав <a name=\"keyword131\"></a><span class=\"keyword\">первичного ключа</span> входит более одного <a name=\"keyword132\"></a><span class=\"keyword\">атрибута</span> ) в любом <a name=\"keyword133\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword134\"></a><span class=\"keyword\">тела отношения</span> отличается от значения <a name=\"keyword135\"></a><span class=\"keyword\">первичного ключа</span> в любом другом <a name=\"keyword136\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword137\"></a><span class=\"keyword\">тела</span> этого <a name=\"keyword138\"></a><span class=\"keyword\">отношения</span>, а никакое собственное подмножество<sup>2</sup><span class=\"texample\">S</span> этим свойством не обладает. В следующем разделе мы покажем, что существование <a name=\"keyword139\"></a><span class=\"keyword\">первичного ключа</span> у любого <a name=\"keyword140\"></a><span class=\"keyword\">значения отношения</span>является следствием одного из фундаментальных свойств <a name=\"keyword141\"></a><span class=\"keyword\">отношений</span>, а именно того свойства, что <a name=\"keyword142\"></a><span class=\"keyword\">тело отношения</span> является множеством<a name=\"keyword143\"></a><span class=\"keyword\">кортежей</span>.</p> <div id=\"mark_67\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_78\">Обычным житейским представлением <a name=\"keyword144\"></a><span class=\"keyword\">отношения</span> является <strong>таблица</strong>, <strong>заголовком</strong> которой является схема <a name=\"keyword145\"></a><span class=\"keyword\">отношения</span>, а <strong>строками</strong> &ndash; <a name=\"keyword146\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword147\"></a><span class=\"keyword\">отношения</span> -экземпляра; в этом случае имена <a name=\"keyword148\"></a><span class=\"keyword\">атрибутов</span> соответствуют именам <strong>столбцов</strong> данной таблицы. Поэтому иногда говорят про \"столбцы таблицы\", имея в виду \" <a name=\"keyword149\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword150\"></a><span class=\"keyword\">отношения</span> \".</p> <div id=\"mark_78\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_79\">Конечно, это достаточно грубая терминология, поскольку у обычных таблиц и строки, и столбцы упорядочены, тогда как <a name=\"keyword151\"></a><span class=\"keyword\">атрибуты</span> и <a name=\"keyword152\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword153\"></a><span class=\"keyword\">отношений</span> являются элементами неупорядоченных множеств. Тем не менее, когда мы перейдем к рассмотрению практических вопросов организации <a name=\"keyword154\"></a><span class=\"keyword\">реляционных баз данных</span> и средств управления, то будем использовать эту \"житейскую\" терминологию. Подобной терминологии придерживаются в большинстве коммерческих реляционных СУБД. Иногда также используются термины <strong>файл</strong> как аналог таблицы, <strong>запись</strong> как аналог строки и <strong>поле</strong> как аналог столбца. Напомню, что этой терминологией мы пользовались в лекции 1.</p>',2,' В этом курсе, главным образом, обсуждаются различные аспекты реляционных баз данных. Принято считать, что реляционный подход к организации баз данных был заложен в конце 1960-х гг. Эдгаром Коддом. В последние десятилетия этот подход является наиболее распространенным (с оговоркой, что в называемых в обиходе реляционными системах баз данных, основанных на языке SQL, в действительности нарушаются некоторые важные принципы классического реляционного подхода). Достоинствами реляционного подхода принято считать следующие свойства: реляционный подход основывается на небольшом числе интуитивно понятных абстракций, на основе которых возможно простое моделирование наиболее распространенных предметных областей; эти абстракции могут быть точно и формально определены; теоретическим базисом реляционного подхода к организации баз данных служит простой и мощный математический аппарат теории множеств и математической логики; реляционный подход обеспечивает возможность ненавигационного манипулирования данными без необходимости знания конкретной физической организации баз данных во внешней памяти. Компьютерный мир далеко не сразу признал реляционные системы. В 70-е года прошлого века, когда уже были получены почти все основные теоретические результаты и даже существовали первые прототипы реляционных СУБД, многие авторитетные специалисты отрицали возможность добиться эффективной реализации таких систем. Однако преимущества реляционного подхода и развитие методов и алгоритмов организации и управления реляционными базами данных привели к тому, что к концу 80-х годов реляционные системы заняли на мировом рынке СУБД доминирующее положение. В этой лекции на сравнительно неформальном уровне вводятся основные понятия реляционных баз данных, а также определяется сущность реляционной модели данных. Основной целью лекции является демонстрация простоты и возможности интуитивной интерпретации этих понятий. В следующих лекциях будут приводиться более формальные определения, на которых основана теория реляционных баз данных.',0), 
('Лекция 7: Проектирование реляционных баз данных на основе принципов нормализации: первые шаги нормализации',7,'Lecture','<h3>Основные понятия реляционных баз данных</h3> <p id=\"id_1\">Выделим следующие основные понятия <a name=\"keyword1\"></a><span class=\"keyword\">реляционных баз данных</span>: <a name=\"keyword2\"></a><span class=\"keyword\">тип данных</span>, <a name=\"keyword3\"></a><span class=\"keyword\">домен</span>, <a name=\"keyword4\"></a><span class=\"keyword\">атрибут</span>, <a name=\"keyword5\"></a><span class=\"keyword\">кортеж</span>, <a name=\"keyword6\"></a><span class=\"keyword\">отношение</span>, <a name=\"keyword7\"></a><span class=\"keyword\">первичный ключ</span>.</p> <div id=\"mark_1\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_2\">Для начала покажем смысл этих понятий на примере <a name=\"keyword8\"></a><span class=\"keyword\">отношения</span> СЛУЖАЩИЕ, содержащего информацию о служащих некоторого предприятия (<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>).</p> <div id=\"mark_2\" class=\"lecture_mark\">&nbsp;</div> <div id=\"id_3\"><a name=\"image.2.1\"></a> <div><img src=\"http://www.intuit.ru/EDI/14_02_16_4/1455402139-23616/tutorial/157/objects/2/files/2_1.gif\" alt=\"Соотношение основных понятий реляционного подхода\" /></div> <br /><strong>Рис. 2.1. </strong>Соотношение основных понятий реляционного подхода</div> <div id=\"mark_3\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect2\"></a></h3> <h4>Тип данных</h4> <p id=\"id_4\">Значения данных, хранимые в <a name=\"keyword9\"></a><span class=\"keyword\">реляционной базе данных</span>, являются типизированными, т. е. известен тип каждого хранимого значения. Понятие<a name=\"keyword10\"></a><span class=\"keyword\">типа данных</span> в <a name=\"keyword11\"></a><span class=\"keyword\">реляционной модели данных</span> полностью соответствует понятию <a name=\"keyword12\"></a><span class=\"keyword\">типа данных</span> в языках программирования. <a name=\"keyword-context1\"></a>Напомним, что традиционное (нестрогое) определение <span class=\"keyword_def\"><a name=\"keyword13\"></a><span class=\"keyword\">типа данных</span></span> состоит из трех основных компонентов: определение множества значений данного типа; определение набора операций, применимых к значениям типа; определение способа внешнего представления значений типа (литералов).</p> <div id=\"mark_4\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_5\">Обычно в современных <a name=\"keyword14\"></a><span class=\"keyword\">реляционных базах данных</span> допускается хранение символьных, числовых данных (точных и приблизительных), специализированных числовых данных (таких, как \"деньги\"), а также специальных \"темпоральных\" данных (дата, время, временной интервал). Кроме того, в реляционных системах поддерживается возможность определения пользователями собственных <a name=\"keyword15\"></a><span class=\"keyword\">типов данных</span> (более подробно мы обсудим это в лекции 9, курса \"Введение в модель данных SQL\").</p> <div id=\"mark_5\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_6\">В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> мы имеем дело с данными трех <a name=\"keyword16\"></a><span class=\"keyword\">типов</span>: строки символов, целые числа и \"деньги\".</p> <div id=\"mark_6\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect3\"></a></h3> <h4>Домен</h4> <p id=\"id_7\">Понятие <a name=\"keyword17\"></a><span class=\"keyword\">домена</span> более специфично для баз данных, хотя и имеются аналогии с подтипами в некоторых языках программирования (более того, в своем <strong>\"Третьем манифесте\"</strong> Кристофер Дейт и Хью Дарвен вообще ликвидируют различие между <a name=\"keyword18\"></a><span class=\"keyword\">доменом</span> и <a name=\"keyword19\"></a><span class=\"keyword\">типом данных</span> ). В общем виде<a name=\"keyword20\"></a><span class=\"keyword\">домен</span> определяется путем задания некоторого базового <a name=\"keyword21\"></a><span class=\"keyword\">типа данных</span>, к которому относятся элементы <a name=\"keyword22\"></a><span class=\"keyword\">домена</span>, и произвольного логического выражения, применяемого к элементу этого <a name=\"keyword23\"></a><span class=\"keyword\">типа данных</span> ( <span class=\"keyword_def\"><a name=\"keyword24\"></a><span class=\"keyword\">ограничения домена</span></span> ). Элемент данных является элементом <a name=\"keyword25\"></a><span class=\"keyword\">домена</span> в том и только в том случае, если вычисление этого логического выражения дает результат <strong>истина</strong> (для логических значений мы будем попеременно использовать обозначения <strong>истина</strong> и <strong>ложь</strong> или <strong>true</strong> и <strong>false</strong> ). С каждым <a name=\"keyword26\"></a><span class=\"keyword\">доменом</span> связывается имя, уникальное среди имен всех <a name=\"keyword27\"></a><span class=\"keyword\">доменов</span>соответствующей базы данных.</p> <div id=\"mark_7\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_8\"><a name=\"keyword-context3\"></a>Наиболее правильной интуитивной трактовкой понятия <span class=\"keyword_def\"><a name=\"keyword28\"></a><span class=\"keyword\">домена</span></span> является его восприятие как допустимого потенциального, ограниченного подмножества значений данного типа. Например, <a name=\"keyword29\"></a><span class=\"keyword\">домен</span> <span class=\"texample\">ИМЕНА</span> в нашем примере определен на базовом <a name=\"keyword30\"></a><span class=\"keyword\">типе символьных строк</span>, но в число его значений могут входить только те строки, которые могут представлять имена (в частности, для возможности представления русских имен такие строки не могут начинаться с мягкого или твердого знака и не могут быть длиннее, например, 20 символов). Если некоторый <a name=\"keyword31\"></a><span class=\"keyword\">атрибут</span><a name=\"keyword32\"></a><span class=\"keyword\">отношения</span> определяется на некотором <a name=\"keyword33\"></a><span class=\"keyword\">домене</span> (как, например, на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword34\"></a><span class=\"keyword\">атрибут</span> <span class=\"texample\">СЛУ_ИМЯ</span> определяется на <a name=\"keyword35\"></a><span class=\"keyword\">домене</span> <span class=\"texample\">ИМЕНА</span> ), то в дальнейшем <a name=\"keyword36\"></a><span class=\"keyword\">ограничение домена</span> играет роль <a name=\"keyword37\"></a><span class=\"keyword\">ограничения целостности</span>, накладываемого на значения этого <a name=\"keyword38\"></a><span class=\"keyword\">атрибута</span>.</p> <div id=\"mark_8\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_12\">Следует отметить также семантическую нагрузку понятия <a name=\"keyword39\"></a><span class=\"keyword\">домена</span>: данные считаются сравнимыми только в том случае, когда они относятся к одному <a name=\"keyword40\"></a><span class=\"keyword\">домену</span>. В нашем примере значения <a name=\"keyword41\"></a><span class=\"keyword\">доменов</span> <span class=\"texample\">НОМЕРА ПРОПУСКОВ</span> и <span class=\"texample\">НОМЕРА ОТДЕЛОВ</span> относятся к типу целых чисел, но не являются сравнимыми (допускать их сравнение было бы бессмысленно).</p> <div id=\"mark_12\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect4\"></a></h3> <h4>Заголовок отношения, кортеж, тело отношения, значение отношения, переменная отношения</h4> <p id=\"id_15\">Понятие <a name=\"keyword42\"></a><span class=\"keyword\">отношения</span> является наиболее фундаментальным в <a name=\"keyword43\"></a><span class=\"keyword\">реляционном подходе к организации баз данных</span>, поскольку <span class=\"texample\">n</span> -арное<a name=\"keyword44\"></a><span class=\"keyword\">отношение</span> является единственной родовой структурой данных, хранящихся в <a name=\"keyword45\"></a><span class=\"keyword\">реляционной базе данных</span>. Это отражено и в общем названии<a name=\"keyword46\"></a><span class=\"keyword\">подхода</span> &ndash; термин <strong>реляционный (relational)</strong> происходит от <strong>relation (отношение)</strong>. Однако сам термин <a name=\"keyword47\"></a><span class=\"keyword\">отношение</span> является исключительно неточным, поскольку, говоря про любые сохраняемые данные, мы должны иметь в виду <strong>тип</strong> этих данных, <strong>значения</strong> этого <a name=\"keyword48\"></a><span class=\"keyword\">типа</span> и <strong>переменные</strong>, в которых сохраняются значения. Соответственно, для уточнения термина <a name=\"keyword49\"></a><span class=\"keyword\">отношение</span> выделяются понятия <a name=\"keyword50\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword51\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword52\"></a><span class=\"keyword\">переменной отношения</span>. Кроме того, нам потребуется вспомогательное понятие <a name=\"keyword53\"></a><span class=\"keyword\">кортежа</span>.</p> <div id=\"mark_15\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_17\"><a name=\"keyword-context4\"></a>Итак, <span class=\"keyword_def\"><a name=\"keyword54\"></a><span class=\"keyword\">заголовком (или схемой) отношения</span></span> <span class=\"texample\">r</span> ( <span class=\"texample\">Hr</span> ) называется конечное множество упорядоченных пар вида <span class=\"texample\">&lt;A, T&gt;</span>, где <span class=\"texample\">A</span>называется именем <a name=\"keyword55\"></a><span class=\"keyword\">атрибута</span>, а <span class=\"texample\">T</span> обозначает имя некоторого базового <a name=\"keyword56\"></a><span class=\"keyword\">типа</span> или ранее определенного <a name=\"keyword57\"></a><span class=\"keyword\">домена</span> . По определению требуется, чтобы все имена <a name=\"keyword58\"></a><span class=\"keyword\">атрибутов</span> в <a name=\"keyword59\"></a><span class=\"keyword\">заголовке отношения</span> были различны. В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword60\"></a><span class=\"keyword\">заголовком отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> является множество пар <span class=\"texample\">{&lt;слу_номер, номера_пропусков&gt;, &lt;слу_имя, имена&gt;, &lt;слу_зарп, размеры_выплат&gt;, &lt;слу_отд_номер, номера_отделов&gt;}</span>.</p> <div id=\"mark_17\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_25\">Если все <a name=\"keyword61\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword62\"></a><span class=\"keyword\">заголовка отношения</span> определены на разных <a name=\"keyword63\"></a><span class=\"keyword\">доменах</span>, то, чтобы не плодить лишних имен, разумно использовать для именования <a name=\"keyword64\"></a><span class=\"keyword\">атрибутов</span> имена соответствующих <a name=\"keyword65\"></a><span class=\"keyword\">доменов</span> (не забывая, конечно, о том, что это всего лишь удобный способ именования, который не устраняет различия между понятиями <a name=\"keyword66\"></a><span class=\"keyword\">домена</span> и <a name=\"keyword67\"></a><span class=\"keyword\">атрибута</span> ).</p> <div id=\"mark_25\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_26\"><a name=\"keyword-context5\"></a><span class=\"keyword_def\"><a name=\"keyword68\"></a><span class=\"keyword\">Кортежем</span></span> <span class=\"texample\">tr</span>, соответствующим <a name=\"keyword69\"></a><span class=\"keyword\">заголовку</span> <span class=\"texample\">Hr</span>, называется множество упорядоченных триплетов вида <span class=\"texample\">&lt;A, T, v&gt;</span>, по одному такому триплету для каждого <a name=\"keyword70\"></a><span class=\"keyword\">атрибута</span> в <span class=\"texample\">Hr</span> . Третий элемент &ndash; <span class=\"texample\">v</span> &ndash; триплета <span class=\"texample\">&lt;A, T, v&gt;</span> должен являться допустимым значением <a name=\"keyword71\"></a><span class=\"keyword\">типа данных</span>или <a name=\"keyword72\"></a><span class=\"keyword\">домена</span> <span class=\"texample\">T</span>. <a name=\"keyword73\"></a><span class=\"keyword\">Заголовку отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> соответствуют, например, следующие <a name=\"keyword74\"></a><span class=\"keyword\">кортежи</span>: <span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2934&gt;, &lt;слу_имя, имена, Иванов&gt;, &lt;слу_зарп, размеры_выплат, 22.000&gt;, &lt;слу_отд_номер, номера_отделов, 310&gt;}</span>,<span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2940&gt;, &lt;слу_имя, имена, Кузнецов&gt;, &lt;слу_зарп, размеры_выплат, 35.000&gt;, &lt;слу_отд_номер, номера_отделов, 320&gt;}</span>.</p> <div id=\"mark_26\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_37\"><a name=\"keyword-context6\"></a><span class=\"keyword_def\"><a name=\"keyword75\"></a><span class=\"keyword\">Телом</span></span> <span class=\"texample\">Br</span> <a name=\"keyword76\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется произвольное множество <a name=\"keyword77\"></a><span class=\"keyword\">кортежей</span> <span class=\"texample\">tr</span> . Одно из возможных <a name=\"keyword78\"></a><span class=\"keyword\">тел отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">на рис. 2.1</a>. Заметим, что в общем случае, как это демонстрируют, в частности, <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> и пример предыдущего абзаца, могут существовать такие <a name=\"keyword79\"></a><span class=\"keyword\">кортежи</span> <span class=\"texample\">tr</span>, которые соответствуют <span class=\"texample\">Hr</span>, но не входят в <span class=\"texample\">Br</span>.</p> <div id=\"mark_37\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_45\"><a name=\"keyword-context7\"></a><span class=\"keyword_def\"><a name=\"keyword80\"></a><span class=\"keyword\">Значением</span></span> <span class=\"texample\">Vr</span> <a name=\"keyword81\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется пара множеств <span class=\"texample\">Hr</span> и <span class=\"texample\">Br</span> . Одно из допустимых <a name=\"keyword82\"></a><span class=\"keyword\">значений отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано на<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>.</p> <div id=\"mark_45\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_51\">В изменчивой <a name=\"keyword83\"></a><span class=\"keyword\">реляционной базе данных</span> хранятся <a name=\"keyword84\"></a><span class=\"keyword\">отношения</span>, <a name=\"keyword85\"></a><span class=\"keyword\">значения</span> которых изменяются во времени. <a name=\"keyword-context8\"></a><span class=\"keyword_def\"><a name=\"keyword86\"></a><span class=\"keyword\">Переменной</span></span> <span class=\"texample\">VARr</span> называется именованный контейнер, который может содержать любое допустимое <a name=\"keyword87\"></a><span class=\"keyword\">значение</span> <span class=\"texample\">Vr</span> . Естественно, что при определении любой <span class=\"texample\">VARr</span>требуется указывать соответствующий <a name=\"keyword88\"></a><span class=\"keyword\">заголовок отношения</span> <span class=\"texample\">Hr</span>.</p> <div id=\"mark_51\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_56\">Здесь стоит подчеркнуть, что любая принятая на практике операция обновления <a name=\"keyword89\"></a><span class=\"keyword\">базы данных</span> &ndash; <span class=\"texample\">INSERT</span> (вставка <a name=\"keyword90\"></a><span class=\"keyword\">кортежа</span> в <a name=\"keyword91\"></a><span class=\"keyword\">переменную отношения</span> ), <span class=\"texample\">DELETE</span> (удаление <a name=\"keyword92\"></a><span class=\"keyword\">кортежа</span> из значения- <a name=\"keyword93\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword94\"></a><span class=\"keyword\">переменной отношения</span> ) и <span class=\"texample\">UPDATE</span> (модификация <a name=\"keyword95\"></a><span class=\"keyword\">кортежа</span> значения-<a name=\"keyword96\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword97\"></a><span class=\"keyword\">переменной отношения</span> ) &ndash; с модельной точки зрения является операцией присваивания <a name=\"keyword98\"></a><span class=\"keyword\">переменной отношения</span> некоторого нового значения- <a name=\"keyword99\"></a><span class=\"keyword\">отношения</span>. Это совсем не означает, что перечисленные операции должны выполняться именно таким образом в СУБД: главное, чтобы результат операций соответствовал этой модельной семантике.</p> <div id=\"mark_56\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_60\">Заметим, что в дальнейшем в тех случаях, когда точный смысл термина понятен из контекста, мы будем использовать термин <a name=\"keyword100\"></a><span class=\"keyword\">отношение</span> как в смысле <a name=\"keyword101\"></a><span class=\"keyword\">значение отношения</span>, так и в смысле <a name=\"keyword102\"></a><span class=\"keyword\">переменная отношения</span>.</p> <div id=\"mark_60\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_61\"><a name=\"keyword-context9\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword103\"></a><span class=\"keyword\">степенью, или \"арностью\"</span></span>, <a name=\"keyword104\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword105\"></a><span class=\"keyword\">кортежа</span>, соответствующего этому <a name=\"keyword106\"></a><span class=\"keyword\">заголовку</span>, <a name=\"keyword107\"></a><span class=\"keyword\">тела отношения</span>,<a name=\"keyword108\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword109\"></a><span class=\"keyword\">переменной отношения</span> является мощность <a name=\"keyword110\"></a><span class=\"keyword\">заголовка отношения</span> . Например, <a name=\"keyword111\"></a><span class=\"keyword\">степень отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> равна четырем, т. е. оно является 4-арным ( <strong>кватернарным</strong> ).</p> <div id=\"mark_61\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_63\"><a name=\"keyword-context10\"></a>При приведенных определениях разумно считать <span class=\"keyword_def\"><a name=\"keyword112\"></a><span class=\"keyword\">схемой реляционной базы данных</span></span> набор пар <span class=\"texample\">&lt;имя_VARr, Hr&gt;</span>, включающий имена и заголовки всех <a name=\"keyword113\"></a><span class=\"keyword\">переменных отношения</span>, которые определены в <a name=\"keyword114\"></a><span class=\"keyword\">базе данных</span> . <a name=\"keyword-context11\"></a><span class=\"keyword_def\"><a name=\"keyword115\"></a><span class=\"keyword\">Реляционная база данных</span></span> &ndash; это набор пар <span class=\"texample\">&lt;VARr, Hr&gt;</span>(конечно, каждая <a name=\"keyword116\"></a><span class=\"keyword\">переменная отношения</span> в любой момент времени содержит некоторое значение- <a name=\"keyword117\"></a><span class=\"keyword\">отношение</span>, в частности, пустое).</p> <div id=\"mark_63\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_66\">Заметим, что в классических <a name=\"keyword118\"></a><span class=\"keyword\">реляционных базах данных</span> после определения <a name=\"keyword119\"></a><span class=\"keyword\">схемы базы данных</span> могли изменяться только значения<a name=\"keyword120\"></a><span class=\"keyword\">переменных отношений</span>. Однако теперь в большинстве реализаций допускается и изменение <a name=\"keyword121\"></a><span class=\"keyword\">схемы базы данных</span>: определение новых и изменение заголовков существующих <a name=\"keyword122\"></a><span class=\"keyword\">переменных отношений</span>. Это принято называть <strong>эволюцией </strong><a name=\"keyword123\"></a><span class=\"keyword\">схемы базы данных</span>.</p> <div id=\"mark_66\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect5\"></a></h3> <h4>Первичный ключ и интуитивная интерпретация реляционных понятий</h4> <p id=\"id_67\"><a name=\"keyword-context12\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword124\"></a><span class=\"keyword\">первичным ключом</span></span> <a name=\"keyword125\"></a><span class=\"keyword\">переменной отношения</span> является такое подмножество<sup>1</sup> <span class=\"texample\">S</span> множества <a name=\"keyword129\"></a><span class=\"keyword\">атрибутов</span> ее заголовка, что в любое время значение <a name=\"keyword130\"></a><span class=\"keyword\">первичного ключа</span> (составное, если в состав <a name=\"keyword131\"></a><span class=\"keyword\">первичного ключа</span> входит более одного <a name=\"keyword132\"></a><span class=\"keyword\">атрибута</span> ) в любом <a name=\"keyword133\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword134\"></a><span class=\"keyword\">тела отношения</span> отличается от значения <a name=\"keyword135\"></a><span class=\"keyword\">первичного ключа</span> в любом другом <a name=\"keyword136\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword137\"></a><span class=\"keyword\">тела</span> этого <a name=\"keyword138\"></a><span class=\"keyword\">отношения</span>, а никакое собственное подмножество<sup>2</sup><span class=\"texample\">S</span> этим свойством не обладает. В следующем разделе мы покажем, что существование <a name=\"keyword139\"></a><span class=\"keyword\">первичного ключа</span> у любого <a name=\"keyword140\"></a><span class=\"keyword\">значения отношения</span>является следствием одного из фундаментальных свойств <a name=\"keyword141\"></a><span class=\"keyword\">отношений</span>, а именно того свойства, что <a name=\"keyword142\"></a><span class=\"keyword\">тело отношения</span> является множеством<a name=\"keyword143\"></a><span class=\"keyword\">кортежей</span>.</p> <div id=\"mark_67\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_78\">Обычным житейским представлением <a name=\"keyword144\"></a><span class=\"keyword\">отношения</span> является <strong>таблица</strong>, <strong>заголовком</strong> которой является схема <a name=\"keyword145\"></a><span class=\"keyword\">отношения</span>, а <strong>строками</strong> &ndash; <a name=\"keyword146\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword147\"></a><span class=\"keyword\">отношения</span> -экземпляра; в этом случае имена <a name=\"keyword148\"></a><span class=\"keyword\">атрибутов</span> соответствуют именам <strong>столбцов</strong> данной таблицы. Поэтому иногда говорят про \"столбцы таблицы\", имея в виду \" <a name=\"keyword149\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword150\"></a><span class=\"keyword\">отношения</span> \".</p> <div id=\"mark_78\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_79\">Конечно, это достаточно грубая терминология, поскольку у обычных таблиц и строки, и столбцы упорядочены, тогда как <a name=\"keyword151\"></a><span class=\"keyword\">атрибуты</span> и <a name=\"keyword152\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword153\"></a><span class=\"keyword\">отношений</span> являются элементами неупорядоченных множеств. Тем не менее, когда мы перейдем к рассмотрению практических вопросов организации <a name=\"keyword154\"></a><span class=\"keyword\">реляционных баз данных</span> и средств управления, то будем использовать эту \"житейскую\" терминологию. Подобной терминологии придерживаются в большинстве коммерческих реляционных СУБД. Иногда также используются термины <strong>файл</strong> как аналог таблицы, <strong>запись</strong> как аналог строки и <strong>поле</strong> как аналог столбца. Напомню, что этой терминологией мы пользовались в лекции 1.</p>',2,' В этом курсе, главным образом, обсуждаются различные аспекты реляционных баз данных. Принято считать, что реляционный подход к организации баз данных был заложен в конце 1960-х гг. Эдгаром Коддом. В последние десятилетия этот подход является наиболее распространенным (с оговоркой, что в называемых в обиходе реляционными системах баз данных, основанных на языке SQL, в действительности нарушаются некоторые важные принципы классического реляционного подхода). Достоинствами реляционного подхода принято считать следующие свойства: реляционный подход основывается на небольшом числе интуитивно понятных абстракций, на основе которых возможно простое моделирование наиболее распространенных предметных областей; эти абстракции могут быть точно и формально определены; теоретическим базисом реляционного подхода к организации баз данных служит простой и мощный математический аппарат теории множеств и математической логики; реляционный подход обеспечивает возможность ненавигационного манипулирования данными без необходимости знания конкретной физической организации баз данных во внешней памяти. Компьютерный мир далеко не сразу признал реляционные системы. В 70-е года прошлого века, когда уже были получены почти все основные теоретические результаты и даже существовали первые прототипы реляционных СУБД, многие авторитетные специалисты отрицали возможность добиться эффективной реализации таких систем. Однако преимущества реляционного подхода и развитие методов и алгоритмов организации и управления реляционными базами данных привели к тому, что к концу 80-х годов реляционные системы заняли на мировом рынке СУБД доминирующее положение. В этой лекции на сравнительно неформальном уровне вводятся основные понятия реляционных баз данных, а также определяется сущность реляционной модели данных. Основной целью лекции является демонстрация простоты и возможности интуитивной интерпретации этих понятий. В следующих лекциях будут приводиться более формальные определения, на которых основана теория реляционных баз данных.',0), 
('Лекция 8: Проектирование реляционных баз данных на основе принципов нормализации: дальнейшая нормализация',8,'Lecture','<h3>Основные понятия реляционных баз данных</h3> <p id=\"id_1\">Выделим следующие основные понятия <a name=\"keyword1\"></a><span class=\"keyword\">реляционных баз данных</span>: <a name=\"keyword2\"></a><span class=\"keyword\">тип данных</span>, <a name=\"keyword3\"></a><span class=\"keyword\">домен</span>, <a name=\"keyword4\"></a><span class=\"keyword\">атрибут</span>, <a name=\"keyword5\"></a><span class=\"keyword\">кортеж</span>, <a name=\"keyword6\"></a><span class=\"keyword\">отношение</span>, <a name=\"keyword7\"></a><span class=\"keyword\">первичный ключ</span>.</p> <div id=\"mark_1\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_2\">Для начала покажем смысл этих понятий на примере <a name=\"keyword8\"></a><span class=\"keyword\">отношения</span> СЛУЖАЩИЕ, содержащего информацию о служащих некоторого предприятия (<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>).</p> <div id=\"mark_2\" class=\"lecture_mark\">&nbsp;</div> <div id=\"id_3\"><a name=\"image.2.1\"></a> <div><img src=\"http://www.intuit.ru/EDI/14_02_16_4/1455402139-23616/tutorial/157/objects/2/files/2_1.gif\" alt=\"Соотношение основных понятий реляционного подхода\" /></div> <br /><strong>Рис. 2.1. </strong>Соотношение основных понятий реляционного подхода</div> <div id=\"mark_3\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect2\"></a></h3> <h4>Тип данных</h4> <p id=\"id_4\">Значения данных, хранимые в <a name=\"keyword9\"></a><span class=\"keyword\">реляционной базе данных</span>, являются типизированными, т. е. известен тип каждого хранимого значения. Понятие<a name=\"keyword10\"></a><span class=\"keyword\">типа данных</span> в <a name=\"keyword11\"></a><span class=\"keyword\">реляционной модели данных</span> полностью соответствует понятию <a name=\"keyword12\"></a><span class=\"keyword\">типа данных</span> в языках программирования. <a name=\"keyword-context1\"></a>Напомним, что традиционное (нестрогое) определение <span class=\"keyword_def\"><a name=\"keyword13\"></a><span class=\"keyword\">типа данных</span></span> состоит из трех основных компонентов: определение множества значений данного типа; определение набора операций, применимых к значениям типа; определение способа внешнего представления значений типа (литералов).</p> <div id=\"mark_4\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_5\">Обычно в современных <a name=\"keyword14\"></a><span class=\"keyword\">реляционных базах данных</span> допускается хранение символьных, числовых данных (точных и приблизительных), специализированных числовых данных (таких, как \"деньги\"), а также специальных \"темпоральных\" данных (дата, время, временной интервал). Кроме того, в реляционных системах поддерживается возможность определения пользователями собственных <a name=\"keyword15\"></a><span class=\"keyword\">типов данных</span> (более подробно мы обсудим это в лекции 9, курса \"Введение в модель данных SQL\").</p> <div id=\"mark_5\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_6\">В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> мы имеем дело с данными трех <a name=\"keyword16\"></a><span class=\"keyword\">типов</span>: строки символов, целые числа и \"деньги\".</p> <div id=\"mark_6\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect3\"></a></h3> <h4>Домен</h4> <p id=\"id_7\">Понятие <a name=\"keyword17\"></a><span class=\"keyword\">домена</span> более специфично для баз данных, хотя и имеются аналогии с подтипами в некоторых языках программирования (более того, в своем <strong>\"Третьем манифесте\"</strong> Кристофер Дейт и Хью Дарвен вообще ликвидируют различие между <a name=\"keyword18\"></a><span class=\"keyword\">доменом</span> и <a name=\"keyword19\"></a><span class=\"keyword\">типом данных</span> ). В общем виде<a name=\"keyword20\"></a><span class=\"keyword\">домен</span> определяется путем задания некоторого базового <a name=\"keyword21\"></a><span class=\"keyword\">типа данных</span>, к которому относятся элементы <a name=\"keyword22\"></a><span class=\"keyword\">домена</span>, и произвольного логического выражения, применяемого к элементу этого <a name=\"keyword23\"></a><span class=\"keyword\">типа данных</span> ( <span class=\"keyword_def\"><a name=\"keyword24\"></a><span class=\"keyword\">ограничения домена</span></span> ). Элемент данных является элементом <a name=\"keyword25\"></a><span class=\"keyword\">домена</span> в том и только в том случае, если вычисление этого логического выражения дает результат <strong>истина</strong> (для логических значений мы будем попеременно использовать обозначения <strong>истина</strong> и <strong>ложь</strong> или <strong>true</strong> и <strong>false</strong> ). С каждым <a name=\"keyword26\"></a><span class=\"keyword\">доменом</span> связывается имя, уникальное среди имен всех <a name=\"keyword27\"></a><span class=\"keyword\">доменов</span>соответствующей базы данных.</p> <div id=\"mark_7\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_8\"><a name=\"keyword-context3\"></a>Наиболее правильной интуитивной трактовкой понятия <span class=\"keyword_def\"><a name=\"keyword28\"></a><span class=\"keyword\">домена</span></span> является его восприятие как допустимого потенциального, ограниченного подмножества значений данного типа. Например, <a name=\"keyword29\"></a><span class=\"keyword\">домен</span> <span class=\"texample\">ИМЕНА</span> в нашем примере определен на базовом <a name=\"keyword30\"></a><span class=\"keyword\">типе символьных строк</span>, но в число его значений могут входить только те строки, которые могут представлять имена (в частности, для возможности представления русских имен такие строки не могут начинаться с мягкого или твердого знака и не могут быть длиннее, например, 20 символов). Если некоторый <a name=\"keyword31\"></a><span class=\"keyword\">атрибут</span><a name=\"keyword32\"></a><span class=\"keyword\">отношения</span> определяется на некотором <a name=\"keyword33\"></a><span class=\"keyword\">домене</span> (как, например, на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword34\"></a><span class=\"keyword\">атрибут</span> <span class=\"texample\">СЛУ_ИМЯ</span> определяется на <a name=\"keyword35\"></a><span class=\"keyword\">домене</span> <span class=\"texample\">ИМЕНА</span> ), то в дальнейшем <a name=\"keyword36\"></a><span class=\"keyword\">ограничение домена</span> играет роль <a name=\"keyword37\"></a><span class=\"keyword\">ограничения целостности</span>, накладываемого на значения этого <a name=\"keyword38\"></a><span class=\"keyword\">атрибута</span>.</p> <div id=\"mark_8\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_12\">Следует отметить также семантическую нагрузку понятия <a name=\"keyword39\"></a><span class=\"keyword\">домена</span>: данные считаются сравнимыми только в том случае, когда они относятся к одному <a name=\"keyword40\"></a><span class=\"keyword\">домену</span>. В нашем примере значения <a name=\"keyword41\"></a><span class=\"keyword\">доменов</span> <span class=\"texample\">НОМЕРА ПРОПУСКОВ</span> и <span class=\"texample\">НОМЕРА ОТДЕЛОВ</span> относятся к типу целых чисел, но не являются сравнимыми (допускать их сравнение было бы бессмысленно).</p> <div id=\"mark_12\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect4\"></a></h3> <h4>Заголовок отношения, кортеж, тело отношения, значение отношения, переменная отношения</h4> <p id=\"id_15\">Понятие <a name=\"keyword42\"></a><span class=\"keyword\">отношения</span> является наиболее фундаментальным в <a name=\"keyword43\"></a><span class=\"keyword\">реляционном подходе к организации баз данных</span>, поскольку <span class=\"texample\">n</span> -арное<a name=\"keyword44\"></a><span class=\"keyword\">отношение</span> является единственной родовой структурой данных, хранящихся в <a name=\"keyword45\"></a><span class=\"keyword\">реляционной базе данных</span>. Это отражено и в общем названии<a name=\"keyword46\"></a><span class=\"keyword\">подхода</span> &ndash; термин <strong>реляционный (relational)</strong> происходит от <strong>relation (отношение)</strong>. Однако сам термин <a name=\"keyword47\"></a><span class=\"keyword\">отношение</span> является исключительно неточным, поскольку, говоря про любые сохраняемые данные, мы должны иметь в виду <strong>тип</strong> этих данных, <strong>значения</strong> этого <a name=\"keyword48\"></a><span class=\"keyword\">типа</span> и <strong>переменные</strong>, в которых сохраняются значения. Соответственно, для уточнения термина <a name=\"keyword49\"></a><span class=\"keyword\">отношение</span> выделяются понятия <a name=\"keyword50\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword51\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword52\"></a><span class=\"keyword\">переменной отношения</span>. Кроме того, нам потребуется вспомогательное понятие <a name=\"keyword53\"></a><span class=\"keyword\">кортежа</span>.</p> <div id=\"mark_15\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_17\"><a name=\"keyword-context4\"></a>Итак, <span class=\"keyword_def\"><a name=\"keyword54\"></a><span class=\"keyword\">заголовком (или схемой) отношения</span></span> <span class=\"texample\">r</span> ( <span class=\"texample\">Hr</span> ) называется конечное множество упорядоченных пар вида <span class=\"texample\">&lt;A, T&gt;</span>, где <span class=\"texample\">A</span>называется именем <a name=\"keyword55\"></a><span class=\"keyword\">атрибута</span>, а <span class=\"texample\">T</span> обозначает имя некоторого базового <a name=\"keyword56\"></a><span class=\"keyword\">типа</span> или ранее определенного <a name=\"keyword57\"></a><span class=\"keyword\">домена</span> . По определению требуется, чтобы все имена <a name=\"keyword58\"></a><span class=\"keyword\">атрибутов</span> в <a name=\"keyword59\"></a><span class=\"keyword\">заголовке отношения</span> были различны. В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword60\"></a><span class=\"keyword\">заголовком отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> является множество пар <span class=\"texample\">{&lt;слу_номер, номера_пропусков&gt;, &lt;слу_имя, имена&gt;, &lt;слу_зарп, размеры_выплат&gt;, &lt;слу_отд_номер, номера_отделов&gt;}</span>.</p> <div id=\"mark_17\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_25\">Если все <a name=\"keyword61\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword62\"></a><span class=\"keyword\">заголовка отношения</span> определены на разных <a name=\"keyword63\"></a><span class=\"keyword\">доменах</span>, то, чтобы не плодить лишних имен, разумно использовать для именования <a name=\"keyword64\"></a><span class=\"keyword\">атрибутов</span> имена соответствующих <a name=\"keyword65\"></a><span class=\"keyword\">доменов</span> (не забывая, конечно, о том, что это всего лишь удобный способ именования, который не устраняет различия между понятиями <a name=\"keyword66\"></a><span class=\"keyword\">домена</span> и <a name=\"keyword67\"></a><span class=\"keyword\">атрибута</span> ).</p> <div id=\"mark_25\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_26\"><a name=\"keyword-context5\"></a><span class=\"keyword_def\"><a name=\"keyword68\"></a><span class=\"keyword\">Кортежем</span></span> <span class=\"texample\">tr</span>, соответствующим <a name=\"keyword69\"></a><span class=\"keyword\">заголовку</span> <span class=\"texample\">Hr</span>, называется множество упорядоченных триплетов вида <span class=\"texample\">&lt;A, T, v&gt;</span>, по одному такому триплету для каждого <a name=\"keyword70\"></a><span class=\"keyword\">атрибута</span> в <span class=\"texample\">Hr</span> . Третий элемент &ndash; <span class=\"texample\">v</span> &ndash; триплета <span class=\"texample\">&lt;A, T, v&gt;</span> должен являться допустимым значением <a name=\"keyword71\"></a><span class=\"keyword\">типа данных</span>или <a name=\"keyword72\"></a><span class=\"keyword\">домена</span> <span class=\"texample\">T</span>. <a name=\"keyword73\"></a><span class=\"keyword\">Заголовку отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> соответствуют, например, следующие <a name=\"keyword74\"></a><span class=\"keyword\">кортежи</span>: <span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2934&gt;, &lt;слу_имя, имена, Иванов&gt;, &lt;слу_зарп, размеры_выплат, 22.000&gt;, &lt;слу_отд_номер, номера_отделов, 310&gt;}</span>,<span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2940&gt;, &lt;слу_имя, имена, Кузнецов&gt;, &lt;слу_зарп, размеры_выплат, 35.000&gt;, &lt;слу_отд_номер, номера_отделов, 320&gt;}</span>.</p> <div id=\"mark_26\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_37\"><a name=\"keyword-context6\"></a><span class=\"keyword_def\"><a name=\"keyword75\"></a><span class=\"keyword\">Телом</span></span> <span class=\"texample\">Br</span> <a name=\"keyword76\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется произвольное множество <a name=\"keyword77\"></a><span class=\"keyword\">кортежей</span> <span class=\"texample\">tr</span> . Одно из возможных <a name=\"keyword78\"></a><span class=\"keyword\">тел отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">на рис. 2.1</a>. Заметим, что в общем случае, как это демонстрируют, в частности, <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> и пример предыдущего абзаца, могут существовать такие <a name=\"keyword79\"></a><span class=\"keyword\">кортежи</span> <span class=\"texample\">tr</span>, которые соответствуют <span class=\"texample\">Hr</span>, но не входят в <span class=\"texample\">Br</span>.</p> <div id=\"mark_37\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_45\"><a name=\"keyword-context7\"></a><span class=\"keyword_def\"><a name=\"keyword80\"></a><span class=\"keyword\">Значением</span></span> <span class=\"texample\">Vr</span> <a name=\"keyword81\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется пара множеств <span class=\"texample\">Hr</span> и <span class=\"texample\">Br</span> . Одно из допустимых <a name=\"keyword82\"></a><span class=\"keyword\">значений отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано на<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>.</p> <div id=\"mark_45\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_51\">В изменчивой <a name=\"keyword83\"></a><span class=\"keyword\">реляционной базе данных</span> хранятся <a name=\"keyword84\"></a><span class=\"keyword\">отношения</span>, <a name=\"keyword85\"></a><span class=\"keyword\">значения</span> которых изменяются во времени. <a name=\"keyword-context8\"></a><span class=\"keyword_def\"><a name=\"keyword86\"></a><span class=\"keyword\">Переменной</span></span> <span class=\"texample\">VARr</span> называется именованный контейнер, который может содержать любое допустимое <a name=\"keyword87\"></a><span class=\"keyword\">значение</span> <span class=\"texample\">Vr</span> . Естественно, что при определении любой <span class=\"texample\">VARr</span>требуется указывать соответствующий <a name=\"keyword88\"></a><span class=\"keyword\">заголовок отношения</span> <span class=\"texample\">Hr</span>.</p> <div id=\"mark_51\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_56\">Здесь стоит подчеркнуть, что любая принятая на практике операция обновления <a name=\"keyword89\"></a><span class=\"keyword\">базы данных</span> &ndash; <span class=\"texample\">INSERT</span> (вставка <a name=\"keyword90\"></a><span class=\"keyword\">кортежа</span> в <a name=\"keyword91\"></a><span class=\"keyword\">переменную отношения</span> ), <span class=\"texample\">DELETE</span> (удаление <a name=\"keyword92\"></a><span class=\"keyword\">кортежа</span> из значения- <a name=\"keyword93\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword94\"></a><span class=\"keyword\">переменной отношения</span> ) и <span class=\"texample\">UPDATE</span> (модификация <a name=\"keyword95\"></a><span class=\"keyword\">кортежа</span> значения-<a name=\"keyword96\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword97\"></a><span class=\"keyword\">переменной отношения</span> ) &ndash; с модельной точки зрения является операцией присваивания <a name=\"keyword98\"></a><span class=\"keyword\">переменной отношения</span> некоторого нового значения- <a name=\"keyword99\"></a><span class=\"keyword\">отношения</span>. Это совсем не означает, что перечисленные операции должны выполняться именно таким образом в СУБД: главное, чтобы результат операций соответствовал этой модельной семантике.</p> <div id=\"mark_56\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_60\">Заметим, что в дальнейшем в тех случаях, когда точный смысл термина понятен из контекста, мы будем использовать термин <a name=\"keyword100\"></a><span class=\"keyword\">отношение</span> как в смысле <a name=\"keyword101\"></a><span class=\"keyword\">значение отношения</span>, так и в смысле <a name=\"keyword102\"></a><span class=\"keyword\">переменная отношения</span>.</p> <div id=\"mark_60\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_61\"><a name=\"keyword-context9\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword103\"></a><span class=\"keyword\">степенью, или \"арностью\"</span></span>, <a name=\"keyword104\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword105\"></a><span class=\"keyword\">кортежа</span>, соответствующего этому <a name=\"keyword106\"></a><span class=\"keyword\">заголовку</span>, <a name=\"keyword107\"></a><span class=\"keyword\">тела отношения</span>,<a name=\"keyword108\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword109\"></a><span class=\"keyword\">переменной отношения</span> является мощность <a name=\"keyword110\"></a><span class=\"keyword\">заголовка отношения</span> . Например, <a name=\"keyword111\"></a><span class=\"keyword\">степень отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> равна четырем, т. е. оно является 4-арным ( <strong>кватернарным</strong> ).</p> <div id=\"mark_61\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_63\"><a name=\"keyword-context10\"></a>При приведенных определениях разумно считать <span class=\"keyword_def\"><a name=\"keyword112\"></a><span class=\"keyword\">схемой реляционной базы данных</span></span> набор пар <span class=\"texample\">&lt;имя_VARr, Hr&gt;</span>, включающий имена и заголовки всех <a name=\"keyword113\"></a><span class=\"keyword\">переменных отношения</span>, которые определены в <a name=\"keyword114\"></a><span class=\"keyword\">базе данных</span> . <a name=\"keyword-context11\"></a><span class=\"keyword_def\"><a name=\"keyword115\"></a><span class=\"keyword\">Реляционная база данных</span></span> &ndash; это набор пар <span class=\"texample\">&lt;VARr, Hr&gt;</span>(конечно, каждая <a name=\"keyword116\"></a><span class=\"keyword\">переменная отношения</span> в любой момент времени содержит некоторое значение- <a name=\"keyword117\"></a><span class=\"keyword\">отношение</span>, в частности, пустое).</p> <div id=\"mark_63\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_66\">Заметим, что в классических <a name=\"keyword118\"></a><span class=\"keyword\">реляционных базах данных</span> после определения <a name=\"keyword119\"></a><span class=\"keyword\">схемы базы данных</span> могли изменяться только значения<a name=\"keyword120\"></a><span class=\"keyword\">переменных отношений</span>. Однако теперь в большинстве реализаций допускается и изменение <a name=\"keyword121\"></a><span class=\"keyword\">схемы базы данных</span>: определение новых и изменение заголовков существующих <a name=\"keyword122\"></a><span class=\"keyword\">переменных отношений</span>. Это принято называть <strong>эволюцией </strong><a name=\"keyword123\"></a><span class=\"keyword\">схемы базы данных</span>.</p> <div id=\"mark_66\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect5\"></a></h3> <h4>Первичный ключ и интуитивная интерпретация реляционных понятий</h4> <p id=\"id_67\"><a name=\"keyword-context12\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword124\"></a><span class=\"keyword\">первичным ключом</span></span> <a name=\"keyword125\"></a><span class=\"keyword\">переменной отношения</span> является такое подмножество<sup>1</sup> <span class=\"texample\">S</span> множества <a name=\"keyword129\"></a><span class=\"keyword\">атрибутов</span> ее заголовка, что в любое время значение <a name=\"keyword130\"></a><span class=\"keyword\">первичного ключа</span> (составное, если в состав <a name=\"keyword131\"></a><span class=\"keyword\">первичного ключа</span> входит более одного <a name=\"keyword132\"></a><span class=\"keyword\">атрибута</span> ) в любом <a name=\"keyword133\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword134\"></a><span class=\"keyword\">тела отношения</span> отличается от значения <a name=\"keyword135\"></a><span class=\"keyword\">первичного ключа</span> в любом другом <a name=\"keyword136\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword137\"></a><span class=\"keyword\">тела</span> этого <a name=\"keyword138\"></a><span class=\"keyword\">отношения</span>, а никакое собственное подмножество<sup>2</sup><span class=\"texample\">S</span> этим свойством не обладает. В следующем разделе мы покажем, что существование <a name=\"keyword139\"></a><span class=\"keyword\">первичного ключа</span> у любого <a name=\"keyword140\"></a><span class=\"keyword\">значения отношения</span>является следствием одного из фундаментальных свойств <a name=\"keyword141\"></a><span class=\"keyword\">отношений</span>, а именно того свойства, что <a name=\"keyword142\"></a><span class=\"keyword\">тело отношения</span> является множеством<a name=\"keyword143\"></a><span class=\"keyword\">кортежей</span>.</p> <div id=\"mark_67\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_78\">Обычным житейским представлением <a name=\"keyword144\"></a><span class=\"keyword\">отношения</span> является <strong>таблица</strong>, <strong>заголовком</strong> которой является схема <a name=\"keyword145\"></a><span class=\"keyword\">отношения</span>, а <strong>строками</strong> &ndash; <a name=\"keyword146\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword147\"></a><span class=\"keyword\">отношения</span> -экземпляра; в этом случае имена <a name=\"keyword148\"></a><span class=\"keyword\">атрибутов</span> соответствуют именам <strong>столбцов</strong> данной таблицы. Поэтому иногда говорят про \"столбцы таблицы\", имея в виду \" <a name=\"keyword149\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword150\"></a><span class=\"keyword\">отношения</span> \".</p> <div id=\"mark_78\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_79\">Конечно, это достаточно грубая терминология, поскольку у обычных таблиц и строки, и столбцы упорядочены, тогда как <a name=\"keyword151\"></a><span class=\"keyword\">атрибуты</span> и <a name=\"keyword152\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword153\"></a><span class=\"keyword\">отношений</span> являются элементами неупорядоченных множеств. Тем не менее, когда мы перейдем к рассмотрению практических вопросов организации <a name=\"keyword154\"></a><span class=\"keyword\">реляционных баз данных</span> и средств управления, то будем использовать эту \"житейскую\" терминологию. Подобной терминологии придерживаются в большинстве коммерческих реляционных СУБД. Иногда также используются термины <strong>файл</strong> как аналог таблицы, <strong>запись</strong> как аналог строки и <strong>поле</strong> как аналог столбца. Напомню, что этой терминологией мы пользовались в лекции 1.</p>',2,' В этом курсе, главным образом, обсуждаются различные аспекты реляционных баз данных. Принято считать, что реляционный подход к организации баз данных был заложен в конце 1960-х гг. Эдгаром Коддом. В последние десятилетия этот подход является наиболее распространенным (с оговоркой, что в называемых в обиходе реляционными системах баз данных, основанных на языке SQL, в действительности нарушаются некоторые важные принципы классического реляционного подхода). Достоинствами реляционного подхода принято считать следующие свойства: реляционный подход основывается на небольшом числе интуитивно понятных абстракций, на основе которых возможно простое моделирование наиболее распространенных предметных областей; эти абстракции могут быть точно и формально определены; теоретическим базисом реляционного подхода к организации баз данных служит простой и мощный математический аппарат теории множеств и математической логики; реляционный подход обеспечивает возможность ненавигационного манипулирования данными без необходимости знания конкретной физической организации баз данных во внешней памяти. Компьютерный мир далеко не сразу признал реляционные системы. В 70-е года прошлого века, когда уже были получены почти все основные теоретические результаты и даже существовали первые прототипы реляционных СУБД, многие авторитетные специалисты отрицали возможность добиться эффективной реализации таких систем. Однако преимущества реляционного подхода и развитие методов и алгоритмов организации и управления реляционными базами данных привели к тому, что к концу 80-х годов реляционные системы заняли на мировом рынке СУБД доминирующее положение. В этой лекции на сравнительно неформальном уровне вводятся основные понятия реляционных баз данных, а также определяется сущность реляционной модели данных. Основной целью лекции является демонстрация простоты и возможности интуитивной интерпретации этих понятий. В следующих лекциях будут приводиться более формальные определения, на которых основана теория реляционных баз данных.',0), 
('Лекция 9: Проектирование реляционных баз данных с использованием семантических моделей: ER-диаграммы',9,'Lecture','<h3>Основные понятия реляционных баз данных</h3> <p id=\"id_1\">Выделим следующие основные понятия <a name=\"keyword1\"></a><span class=\"keyword\">реляционных баз данных</span>: <a name=\"keyword2\"></a><span class=\"keyword\">тип данных</span>, <a name=\"keyword3\"></a><span class=\"keyword\">домен</span>, <a name=\"keyword4\"></a><span class=\"keyword\">атрибут</span>, <a name=\"keyword5\"></a><span class=\"keyword\">кортеж</span>, <a name=\"keyword6\"></a><span class=\"keyword\">отношение</span>, <a name=\"keyword7\"></a><span class=\"keyword\">первичный ключ</span>.</p> <div id=\"mark_1\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_2\">Для начала покажем смысл этих понятий на примере <a name=\"keyword8\"></a><span class=\"keyword\">отношения</span> СЛУЖАЩИЕ, содержащего информацию о служащих некоторого предприятия (<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>).</p> <div id=\"mark_2\" class=\"lecture_mark\">&nbsp;</div> <div id=\"id_3\"><a name=\"image.2.1\"></a> <div><img src=\"http://www.intuit.ru/EDI/14_02_16_4/1455402139-23616/tutorial/157/objects/2/files/2_1.gif\" alt=\"Соотношение основных понятий реляционного подхода\" /></div> <br /><strong>Рис. 2.1. </strong>Соотношение основных понятий реляционного подхода</div> <div id=\"mark_3\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect2\"></a></h3> <h4>Тип данных</h4> <p id=\"id_4\">Значения данных, хранимые в <a name=\"keyword9\"></a><span class=\"keyword\">реляционной базе данных</span>, являются типизированными, т. е. известен тип каждого хранимого значения. Понятие<a name=\"keyword10\"></a><span class=\"keyword\">типа данных</span> в <a name=\"keyword11\"></a><span class=\"keyword\">реляционной модели данных</span> полностью соответствует понятию <a name=\"keyword12\"></a><span class=\"keyword\">типа данных</span> в языках программирования. <a name=\"keyword-context1\"></a>Напомним, что традиционное (нестрогое) определение <span class=\"keyword_def\"><a name=\"keyword13\"></a><span class=\"keyword\">типа данных</span></span> состоит из трех основных компонентов: определение множества значений данного типа; определение набора операций, применимых к значениям типа; определение способа внешнего представления значений типа (литералов).</p> <div id=\"mark_4\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_5\">Обычно в современных <a name=\"keyword14\"></a><span class=\"keyword\">реляционных базах данных</span> допускается хранение символьных, числовых данных (точных и приблизительных), специализированных числовых данных (таких, как \"деньги\"), а также специальных \"темпоральных\" данных (дата, время, временной интервал). Кроме того, в реляционных системах поддерживается возможность определения пользователями собственных <a name=\"keyword15\"></a><span class=\"keyword\">типов данных</span> (более подробно мы обсудим это в лекции 9, курса \"Введение в модель данных SQL\").</p> <div id=\"mark_5\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_6\">В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> мы имеем дело с данными трех <a name=\"keyword16\"></a><span class=\"keyword\">типов</span>: строки символов, целые числа и \"деньги\".</p> <div id=\"mark_6\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect3\"></a></h3> <h4>Домен</h4> <p id=\"id_7\">Понятие <a name=\"keyword17\"></a><span class=\"keyword\">домена</span> более специфично для баз данных, хотя и имеются аналогии с подтипами в некоторых языках программирования (более того, в своем <strong>\"Третьем манифесте\"</strong> Кристофер Дейт и Хью Дарвен вообще ликвидируют различие между <a name=\"keyword18\"></a><span class=\"keyword\">доменом</span> и <a name=\"keyword19\"></a><span class=\"keyword\">типом данных</span> ). В общем виде<a name=\"keyword20\"></a><span class=\"keyword\">домен</span> определяется путем задания некоторого базового <a name=\"keyword21\"></a><span class=\"keyword\">типа данных</span>, к которому относятся элементы <a name=\"keyword22\"></a><span class=\"keyword\">домена</span>, и произвольного логического выражения, применяемого к элементу этого <a name=\"keyword23\"></a><span class=\"keyword\">типа данных</span> ( <span class=\"keyword_def\"><a name=\"keyword24\"></a><span class=\"keyword\">ограничения домена</span></span> ). Элемент данных является элементом <a name=\"keyword25\"></a><span class=\"keyword\">домена</span> в том и только в том случае, если вычисление этого логического выражения дает результат <strong>истина</strong> (для логических значений мы будем попеременно использовать обозначения <strong>истина</strong> и <strong>ложь</strong> или <strong>true</strong> и <strong>false</strong> ). С каждым <a name=\"keyword26\"></a><span class=\"keyword\">доменом</span> связывается имя, уникальное среди имен всех <a name=\"keyword27\"></a><span class=\"keyword\">доменов</span>соответствующей базы данных.</p> <div id=\"mark_7\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_8\"><a name=\"keyword-context3\"></a>Наиболее правильной интуитивной трактовкой понятия <span class=\"keyword_def\"><a name=\"keyword28\"></a><span class=\"keyword\">домена</span></span> является его восприятие как допустимого потенциального, ограниченного подмножества значений данного типа. Например, <a name=\"keyword29\"></a><span class=\"keyword\">домен</span> <span class=\"texample\">ИМЕНА</span> в нашем примере определен на базовом <a name=\"keyword30\"></a><span class=\"keyword\">типе символьных строк</span>, но в число его значений могут входить только те строки, которые могут представлять имена (в частности, для возможности представления русских имен такие строки не могут начинаться с мягкого или твердого знака и не могут быть длиннее, например, 20 символов). Если некоторый <a name=\"keyword31\"></a><span class=\"keyword\">атрибут</span><a name=\"keyword32\"></a><span class=\"keyword\">отношения</span> определяется на некотором <a name=\"keyword33\"></a><span class=\"keyword\">домене</span> (как, например, на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword34\"></a><span class=\"keyword\">атрибут</span> <span class=\"texample\">СЛУ_ИМЯ</span> определяется на <a name=\"keyword35\"></a><span class=\"keyword\">домене</span> <span class=\"texample\">ИМЕНА</span> ), то в дальнейшем <a name=\"keyword36\"></a><span class=\"keyword\">ограничение домена</span> играет роль <a name=\"keyword37\"></a><span class=\"keyword\">ограничения целостности</span>, накладываемого на значения этого <a name=\"keyword38\"></a><span class=\"keyword\">атрибута</span>.</p> <div id=\"mark_8\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_12\">Следует отметить также семантическую нагрузку понятия <a name=\"keyword39\"></a><span class=\"keyword\">домена</span>: данные считаются сравнимыми только в том случае, когда они относятся к одному <a name=\"keyword40\"></a><span class=\"keyword\">домену</span>. В нашем примере значения <a name=\"keyword41\"></a><span class=\"keyword\">доменов</span> <span class=\"texample\">НОМЕРА ПРОПУСКОВ</span> и <span class=\"texample\">НОМЕРА ОТДЕЛОВ</span> относятся к типу целых чисел, но не являются сравнимыми (допускать их сравнение было бы бессмысленно).</p> <div id=\"mark_12\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect4\"></a></h3> <h4>Заголовок отношения, кортеж, тело отношения, значение отношения, переменная отношения</h4> <p id=\"id_15\">Понятие <a name=\"keyword42\"></a><span class=\"keyword\">отношения</span> является наиболее фундаментальным в <a name=\"keyword43\"></a><span class=\"keyword\">реляционном подходе к организации баз данных</span>, поскольку <span class=\"texample\">n</span> -арное<a name=\"keyword44\"></a><span class=\"keyword\">отношение</span> является единственной родовой структурой данных, хранящихся в <a name=\"keyword45\"></a><span class=\"keyword\">реляционной базе данных</span>. Это отражено и в общем названии<a name=\"keyword46\"></a><span class=\"keyword\">подхода</span> &ndash; термин <strong>реляционный (relational)</strong> происходит от <strong>relation (отношение)</strong>. Однако сам термин <a name=\"keyword47\"></a><span class=\"keyword\">отношение</span> является исключительно неточным, поскольку, говоря про любые сохраняемые данные, мы должны иметь в виду <strong>тип</strong> этих данных, <strong>значения</strong> этого <a name=\"keyword48\"></a><span class=\"keyword\">типа</span> и <strong>переменные</strong>, в которых сохраняются значения. Соответственно, для уточнения термина <a name=\"keyword49\"></a><span class=\"keyword\">отношение</span> выделяются понятия <a name=\"keyword50\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword51\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword52\"></a><span class=\"keyword\">переменной отношения</span>. Кроме того, нам потребуется вспомогательное понятие <a name=\"keyword53\"></a><span class=\"keyword\">кортежа</span>.</p> <div id=\"mark_15\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_17\"><a name=\"keyword-context4\"></a>Итак, <span class=\"keyword_def\"><a name=\"keyword54\"></a><span class=\"keyword\">заголовком (или схемой) отношения</span></span> <span class=\"texample\">r</span> ( <span class=\"texample\">Hr</span> ) называется конечное множество упорядоченных пар вида <span class=\"texample\">&lt;A, T&gt;</span>, где <span class=\"texample\">A</span>называется именем <a name=\"keyword55\"></a><span class=\"keyword\">атрибута</span>, а <span class=\"texample\">T</span> обозначает имя некоторого базового <a name=\"keyword56\"></a><span class=\"keyword\">типа</span> или ранее определенного <a name=\"keyword57\"></a><span class=\"keyword\">домена</span> . По определению требуется, чтобы все имена <a name=\"keyword58\"></a><span class=\"keyword\">атрибутов</span> в <a name=\"keyword59\"></a><span class=\"keyword\">заголовке отношения</span> были различны. В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword60\"></a><span class=\"keyword\">заголовком отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> является множество пар <span class=\"texample\">{&lt;слу_номер, номера_пропусков&gt;, &lt;слу_имя, имена&gt;, &lt;слу_зарп, размеры_выплат&gt;, &lt;слу_отд_номер, номера_отделов&gt;}</span>.</p> <div id=\"mark_17\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_25\">Если все <a name=\"keyword61\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword62\"></a><span class=\"keyword\">заголовка отношения</span> определены на разных <a name=\"keyword63\"></a><span class=\"keyword\">доменах</span>, то, чтобы не плодить лишних имен, разумно использовать для именования <a name=\"keyword64\"></a><span class=\"keyword\">атрибутов</span> имена соответствующих <a name=\"keyword65\"></a><span class=\"keyword\">доменов</span> (не забывая, конечно, о том, что это всего лишь удобный способ именования, который не устраняет различия между понятиями <a name=\"keyword66\"></a><span class=\"keyword\">домена</span> и <a name=\"keyword67\"></a><span class=\"keyword\">атрибута</span> ).</p> <div id=\"mark_25\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_26\"><a name=\"keyword-context5\"></a><span class=\"keyword_def\"><a name=\"keyword68\"></a><span class=\"keyword\">Кортежем</span></span> <span class=\"texample\">tr</span>, соответствующим <a name=\"keyword69\"></a><span class=\"keyword\">заголовку</span> <span class=\"texample\">Hr</span>, называется множество упорядоченных триплетов вида <span class=\"texample\">&lt;A, T, v&gt;</span>, по одному такому триплету для каждого <a name=\"keyword70\"></a><span class=\"keyword\">атрибута</span> в <span class=\"texample\">Hr</span> . Третий элемент &ndash; <span class=\"texample\">v</span> &ndash; триплета <span class=\"texample\">&lt;A, T, v&gt;</span> должен являться допустимым значением <a name=\"keyword71\"></a><span class=\"keyword\">типа данных</span>или <a name=\"keyword72\"></a><span class=\"keyword\">домена</span> <span class=\"texample\">T</span>. <a name=\"keyword73\"></a><span class=\"keyword\">Заголовку отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> соответствуют, например, следующие <a name=\"keyword74\"></a><span class=\"keyword\">кортежи</span>: <span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2934&gt;, &lt;слу_имя, имена, Иванов&gt;, &lt;слу_зарп, размеры_выплат, 22.000&gt;, &lt;слу_отд_номер, номера_отделов, 310&gt;}</span>,<span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2940&gt;, &lt;слу_имя, имена, Кузнецов&gt;, &lt;слу_зарп, размеры_выплат, 35.000&gt;, &lt;слу_отд_номер, номера_отделов, 320&gt;}</span>.</p> <div id=\"mark_26\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_37\"><a name=\"keyword-context6\"></a><span class=\"keyword_def\"><a name=\"keyword75\"></a><span class=\"keyword\">Телом</span></span> <span class=\"texample\">Br</span> <a name=\"keyword76\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется произвольное множество <a name=\"keyword77\"></a><span class=\"keyword\">кортежей</span> <span class=\"texample\">tr</span> . Одно из возможных <a name=\"keyword78\"></a><span class=\"keyword\">тел отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">на рис. 2.1</a>. Заметим, что в общем случае, как это демонстрируют, в частности, <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> и пример предыдущего абзаца, могут существовать такие <a name=\"keyword79\"></a><span class=\"keyword\">кортежи</span> <span class=\"texample\">tr</span>, которые соответствуют <span class=\"texample\">Hr</span>, но не входят в <span class=\"texample\">Br</span>.</p> <div id=\"mark_37\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_45\"><a name=\"keyword-context7\"></a><span class=\"keyword_def\"><a name=\"keyword80\"></a><span class=\"keyword\">Значением</span></span> <span class=\"texample\">Vr</span> <a name=\"keyword81\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется пара множеств <span class=\"texample\">Hr</span> и <span class=\"texample\">Br</span> . Одно из допустимых <a name=\"keyword82\"></a><span class=\"keyword\">значений отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано на<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>.</p> <div id=\"mark_45\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_51\">В изменчивой <a name=\"keyword83\"></a><span class=\"keyword\">реляционной базе данных</span> хранятся <a name=\"keyword84\"></a><span class=\"keyword\">отношения</span>, <a name=\"keyword85\"></a><span class=\"keyword\">значения</span> которых изменяются во времени. <a name=\"keyword-context8\"></a><span class=\"keyword_def\"><a name=\"keyword86\"></a><span class=\"keyword\">Переменной</span></span> <span class=\"texample\">VARr</span> называется именованный контейнер, который может содержать любое допустимое <a name=\"keyword87\"></a><span class=\"keyword\">значение</span> <span class=\"texample\">Vr</span> . Естественно, что при определении любой <span class=\"texample\">VARr</span>требуется указывать соответствующий <a name=\"keyword88\"></a><span class=\"keyword\">заголовок отношения</span> <span class=\"texample\">Hr</span>.</p> <div id=\"mark_51\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_56\">Здесь стоит подчеркнуть, что любая принятая на практике операция обновления <a name=\"keyword89\"></a><span class=\"keyword\">базы данных</span> &ndash; <span class=\"texample\">INSERT</span> (вставка <a name=\"keyword90\"></a><span class=\"keyword\">кортежа</span> в <a name=\"keyword91\"></a><span class=\"keyword\">переменную отношения</span> ), <span class=\"texample\">DELETE</span> (удаление <a name=\"keyword92\"></a><span class=\"keyword\">кортежа</span> из значения- <a name=\"keyword93\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword94\"></a><span class=\"keyword\">переменной отношения</span> ) и <span class=\"texample\">UPDATE</span> (модификация <a name=\"keyword95\"></a><span class=\"keyword\">кортежа</span> значения-<a name=\"keyword96\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword97\"></a><span class=\"keyword\">переменной отношения</span> ) &ndash; с модельной точки зрения является операцией присваивания <a name=\"keyword98\"></a><span class=\"keyword\">переменной отношения</span> некоторого нового значения- <a name=\"keyword99\"></a><span class=\"keyword\">отношения</span>. Это совсем не означает, что перечисленные операции должны выполняться именно таким образом в СУБД: главное, чтобы результат операций соответствовал этой модельной семантике.</p> <div id=\"mark_56\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_60\">Заметим, что в дальнейшем в тех случаях, когда точный смысл термина понятен из контекста, мы будем использовать термин <a name=\"keyword100\"></a><span class=\"keyword\">отношение</span> как в смысле <a name=\"keyword101\"></a><span class=\"keyword\">значение отношения</span>, так и в смысле <a name=\"keyword102\"></a><span class=\"keyword\">переменная отношения</span>.</p> <div id=\"mark_60\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_61\"><a name=\"keyword-context9\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword103\"></a><span class=\"keyword\">степенью, или \"арностью\"</span></span>, <a name=\"keyword104\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword105\"></a><span class=\"keyword\">кортежа</span>, соответствующего этому <a name=\"keyword106\"></a><span class=\"keyword\">заголовку</span>, <a name=\"keyword107\"></a><span class=\"keyword\">тела отношения</span>,<a name=\"keyword108\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword109\"></a><span class=\"keyword\">переменной отношения</span> является мощность <a name=\"keyword110\"></a><span class=\"keyword\">заголовка отношения</span> . Например, <a name=\"keyword111\"></a><span class=\"keyword\">степень отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> равна четырем, т. е. оно является 4-арным ( <strong>кватернарным</strong> ).</p> <div id=\"mark_61\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_63\"><a name=\"keyword-context10\"></a>При приведенных определениях разумно считать <span class=\"keyword_def\"><a name=\"keyword112\"></a><span class=\"keyword\">схемой реляционной базы данных</span></span> набор пар <span class=\"texample\">&lt;имя_VARr, Hr&gt;</span>, включающий имена и заголовки всех <a name=\"keyword113\"></a><span class=\"keyword\">переменных отношения</span>, которые определены в <a name=\"keyword114\"></a><span class=\"keyword\">базе данных</span> . <a name=\"keyword-context11\"></a><span class=\"keyword_def\"><a name=\"keyword115\"></a><span class=\"keyword\">Реляционная база данных</span></span> &ndash; это набор пар <span class=\"texample\">&lt;VARr, Hr&gt;</span>(конечно, каждая <a name=\"keyword116\"></a><span class=\"keyword\">переменная отношения</span> в любой момент времени содержит некоторое значение- <a name=\"keyword117\"></a><span class=\"keyword\">отношение</span>, в частности, пустое).</p> <div id=\"mark_63\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_66\">Заметим, что в классических <a name=\"keyword118\"></a><span class=\"keyword\">реляционных базах данных</span> после определения <a name=\"keyword119\"></a><span class=\"keyword\">схемы базы данных</span> могли изменяться только значения<a name=\"keyword120\"></a><span class=\"keyword\">переменных отношений</span>. Однако теперь в большинстве реализаций допускается и изменение <a name=\"keyword121\"></a><span class=\"keyword\">схемы базы данных</span>: определение новых и изменение заголовков существующих <a name=\"keyword122\"></a><span class=\"keyword\">переменных отношений</span>. Это принято называть <strong>эволюцией </strong><a name=\"keyword123\"></a><span class=\"keyword\">схемы базы данных</span>.</p> <div id=\"mark_66\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect5\"></a></h3> <h4>Первичный ключ и интуитивная интерпретация реляционных понятий</h4> <p id=\"id_67\"><a name=\"keyword-context12\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword124\"></a><span class=\"keyword\">первичным ключом</span></span> <a name=\"keyword125\"></a><span class=\"keyword\">переменной отношения</span> является такое подмножество<sup>1</sup> <span class=\"texample\">S</span> множества <a name=\"keyword129\"></a><span class=\"keyword\">атрибутов</span> ее заголовка, что в любое время значение <a name=\"keyword130\"></a><span class=\"keyword\">первичного ключа</span> (составное, если в состав <a name=\"keyword131\"></a><span class=\"keyword\">первичного ключа</span> входит более одного <a name=\"keyword132\"></a><span class=\"keyword\">атрибута</span> ) в любом <a name=\"keyword133\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword134\"></a><span class=\"keyword\">тела отношения</span> отличается от значения <a name=\"keyword135\"></a><span class=\"keyword\">первичного ключа</span> в любом другом <a name=\"keyword136\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword137\"></a><span class=\"keyword\">тела</span> этого <a name=\"keyword138\"></a><span class=\"keyword\">отношения</span>, а никакое собственное подмножество<sup>2</sup><span class=\"texample\">S</span> этим свойством не обладает. В следующем разделе мы покажем, что существование <a name=\"keyword139\"></a><span class=\"keyword\">первичного ключа</span> у любого <a name=\"keyword140\"></a><span class=\"keyword\">значения отношения</span>является следствием одного из фундаментальных свойств <a name=\"keyword141\"></a><span class=\"keyword\">отношений</span>, а именно того свойства, что <a name=\"keyword142\"></a><span class=\"keyword\">тело отношения</span> является множеством<a name=\"keyword143\"></a><span class=\"keyword\">кортежей</span>.</p> <div id=\"mark_67\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_78\">Обычным житейским представлением <a name=\"keyword144\"></a><span class=\"keyword\">отношения</span> является <strong>таблица</strong>, <strong>заголовком</strong> которой является схема <a name=\"keyword145\"></a><span class=\"keyword\">отношения</span>, а <strong>строками</strong> &ndash; <a name=\"keyword146\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword147\"></a><span class=\"keyword\">отношения</span> -экземпляра; в этом случае имена <a name=\"keyword148\"></a><span class=\"keyword\">атрибутов</span> соответствуют именам <strong>столбцов</strong> данной таблицы. Поэтому иногда говорят про \"столбцы таблицы\", имея в виду \" <a name=\"keyword149\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword150\"></a><span class=\"keyword\">отношения</span> \".</p> <div id=\"mark_78\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_79\">Конечно, это достаточно грубая терминология, поскольку у обычных таблиц и строки, и столбцы упорядочены, тогда как <a name=\"keyword151\"></a><span class=\"keyword\">атрибуты</span> и <a name=\"keyword152\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword153\"></a><span class=\"keyword\">отношений</span> являются элементами неупорядоченных множеств. Тем не менее, когда мы перейдем к рассмотрению практических вопросов организации <a name=\"keyword154\"></a><span class=\"keyword\">реляционных баз данных</span> и средств управления, то будем использовать эту \"житейскую\" терминологию. Подобной терминологии придерживаются в большинстве коммерческих реляционных СУБД. Иногда также используются термины <strong>файл</strong> как аналог таблицы, <strong>запись</strong> как аналог строки и <strong>поле</strong> как аналог столбца. Напомню, что этой терминологией мы пользовались в лекции 1.</p>',2,' В этом курсе, главным образом, обсуждаются различные аспекты реляционных баз данных. Принято считать, что реляционный подход к организации баз данных был заложен в конце 1960-х гг. Эдгаром Коддом. В последние десятилетия этот подход является наиболее распространенным (с оговоркой, что в называемых в обиходе реляционными системах баз данных, основанных на языке SQL, в действительности нарушаются некоторые важные принципы классического реляционного подхода). Достоинствами реляционного подхода принято считать следующие свойства: реляционный подход основывается на небольшом числе интуитивно понятных абстракций, на основе которых возможно простое моделирование наиболее распространенных предметных областей; эти абстракции могут быть точно и формально определены; теоретическим базисом реляционного подхода к организации баз данных служит простой и мощный математический аппарат теории множеств и математической логики; реляционный подход обеспечивает возможность ненавигационного манипулирования данными без необходимости знания конкретной физической организации баз данных во внешней памяти. Компьютерный мир далеко не сразу признал реляционные системы. В 70-е года прошлого века, когда уже были получены почти все основные теоретические результаты и даже существовали первые прототипы реляционных СУБД, многие авторитетные специалисты отрицали возможность добиться эффективной реализации таких систем. Однако преимущества реляционного подхода и развитие методов и алгоритмов организации и управления реляционными базами данных привели к тому, что к концу 80-х годов реляционные системы заняли на мировом рынке СУБД доминирующее положение. В этой лекции на сравнительно неформальном уровне вводятся основные понятия реляционных баз данных, а также определяется сущность реляционной модели данных. Основной целью лекции является демонстрация простоты и возможности интуитивной интерпретации этих понятий. В следующих лекциях будут приводиться более формальные определения, на которых основана теория реляционных баз данных.',0), 
('Лекция 10: Проектирование реляционных баз данных с использованием семантических моделей: диаграммы классов языка UML',10,'Lecture','<h3>Основные понятия реляционных баз данных</h3> <p id=\"id_1\">Выделим следующие основные понятия <a name=\"keyword1\"></a><span class=\"keyword\">реляционных баз данных</span>: <a name=\"keyword2\"></a><span class=\"keyword\">тип данных</span>, <a name=\"keyword3\"></a><span class=\"keyword\">домен</span>, <a name=\"keyword4\"></a><span class=\"keyword\">атрибут</span>, <a name=\"keyword5\"></a><span class=\"keyword\">кортеж</span>, <a name=\"keyword6\"></a><span class=\"keyword\">отношение</span>, <a name=\"keyword7\"></a><span class=\"keyword\">первичный ключ</span>.</p> <div id=\"mark_1\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_2\">Для начала покажем смысл этих понятий на примере <a name=\"keyword8\"></a><span class=\"keyword\">отношения</span> СЛУЖАЩИЕ, содержащего информацию о служащих некоторого предприятия (<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>).</p> <div id=\"mark_2\" class=\"lecture_mark\">&nbsp;</div> <div id=\"id_3\"><a name=\"image.2.1\"></a> <div><img src=\"http://www.intuit.ru/EDI/14_02_16_4/1455402139-23616/tutorial/157/objects/2/files/2_1.gif\" alt=\"Соотношение основных понятий реляционного подхода\" /></div> <br /><strong>Рис. 2.1. </strong>Соотношение основных понятий реляционного подхода</div> <div id=\"mark_3\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect2\"></a></h3> <h4>Тип данных</h4> <p id=\"id_4\">Значения данных, хранимые в <a name=\"keyword9\"></a><span class=\"keyword\">реляционной базе данных</span>, являются типизированными, т. е. известен тип каждого хранимого значения. Понятие<a name=\"keyword10\"></a><span class=\"keyword\">типа данных</span> в <a name=\"keyword11\"></a><span class=\"keyword\">реляционной модели данных</span> полностью соответствует понятию <a name=\"keyword12\"></a><span class=\"keyword\">типа данных</span> в языках программирования. <a name=\"keyword-context1\"></a>Напомним, что традиционное (нестрогое) определение <span class=\"keyword_def\"><a name=\"keyword13\"></a><span class=\"keyword\">типа данных</span></span> состоит из трех основных компонентов: определение множества значений данного типа; определение набора операций, применимых к значениям типа; определение способа внешнего представления значений типа (литералов).</p> <div id=\"mark_4\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_5\">Обычно в современных <a name=\"keyword14\"></a><span class=\"keyword\">реляционных базах данных</span> допускается хранение символьных, числовых данных (точных и приблизительных), специализированных числовых данных (таких, как \"деньги\"), а также специальных \"темпоральных\" данных (дата, время, временной интервал). Кроме того, в реляционных системах поддерживается возможность определения пользователями собственных <a name=\"keyword15\"></a><span class=\"keyword\">типов данных</span> (более подробно мы обсудим это в лекции 9, курса \"Введение в модель данных SQL\").</p> <div id=\"mark_5\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_6\">В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> мы имеем дело с данными трех <a name=\"keyword16\"></a><span class=\"keyword\">типов</span>: строки символов, целые числа и \"деньги\".</p> <div id=\"mark_6\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect3\"></a></h3> <h4>Домен</h4> <p id=\"id_7\">Понятие <a name=\"keyword17\"></a><span class=\"keyword\">домена</span> более специфично для баз данных, хотя и имеются аналогии с подтипами в некоторых языках программирования (более того, в своем <strong>\"Третьем манифесте\"</strong> Кристофер Дейт и Хью Дарвен вообще ликвидируют различие между <a name=\"keyword18\"></a><span class=\"keyword\">доменом</span> и <a name=\"keyword19\"></a><span class=\"keyword\">типом данных</span> ). В общем виде<a name=\"keyword20\"></a><span class=\"keyword\">домен</span> определяется путем задания некоторого базового <a name=\"keyword21\"></a><span class=\"keyword\">типа данных</span>, к которому относятся элементы <a name=\"keyword22\"></a><span class=\"keyword\">домена</span>, и произвольного логического выражения, применяемого к элементу этого <a name=\"keyword23\"></a><span class=\"keyword\">типа данных</span> ( <span class=\"keyword_def\"><a name=\"keyword24\"></a><span class=\"keyword\">ограничения домена</span></span> ). Элемент данных является элементом <a name=\"keyword25\"></a><span class=\"keyword\">домена</span> в том и только в том случае, если вычисление этого логического выражения дает результат <strong>истина</strong> (для логических значений мы будем попеременно использовать обозначения <strong>истина</strong> и <strong>ложь</strong> или <strong>true</strong> и <strong>false</strong> ). С каждым <a name=\"keyword26\"></a><span class=\"keyword\">доменом</span> связывается имя, уникальное среди имен всех <a name=\"keyword27\"></a><span class=\"keyword\">доменов</span>соответствующей базы данных.</p> <div id=\"mark_7\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_8\"><a name=\"keyword-context3\"></a>Наиболее правильной интуитивной трактовкой понятия <span class=\"keyword_def\"><a name=\"keyword28\"></a><span class=\"keyword\">домена</span></span> является его восприятие как допустимого потенциального, ограниченного подмножества значений данного типа. Например, <a name=\"keyword29\"></a><span class=\"keyword\">домен</span> <span class=\"texample\">ИМЕНА</span> в нашем примере определен на базовом <a name=\"keyword30\"></a><span class=\"keyword\">типе символьных строк</span>, но в число его значений могут входить только те строки, которые могут представлять имена (в частности, для возможности представления русских имен такие строки не могут начинаться с мягкого или твердого знака и не могут быть длиннее, например, 20 символов). Если некоторый <a name=\"keyword31\"></a><span class=\"keyword\">атрибут</span><a name=\"keyword32\"></a><span class=\"keyword\">отношения</span> определяется на некотором <a name=\"keyword33\"></a><span class=\"keyword\">домене</span> (как, например, на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword34\"></a><span class=\"keyword\">атрибут</span> <span class=\"texample\">СЛУ_ИМЯ</span> определяется на <a name=\"keyword35\"></a><span class=\"keyword\">домене</span> <span class=\"texample\">ИМЕНА</span> ), то в дальнейшем <a name=\"keyword36\"></a><span class=\"keyword\">ограничение домена</span> играет роль <a name=\"keyword37\"></a><span class=\"keyword\">ограничения целостности</span>, накладываемого на значения этого <a name=\"keyword38\"></a><span class=\"keyword\">атрибута</span>.</p> <div id=\"mark_8\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_12\">Следует отметить также семантическую нагрузку понятия <a name=\"keyword39\"></a><span class=\"keyword\">домена</span>: данные считаются сравнимыми только в том случае, когда они относятся к одному <a name=\"keyword40\"></a><span class=\"keyword\">домену</span>. В нашем примере значения <a name=\"keyword41\"></a><span class=\"keyword\">доменов</span> <span class=\"texample\">НОМЕРА ПРОПУСКОВ</span> и <span class=\"texample\">НОМЕРА ОТДЕЛОВ</span> относятся к типу целых чисел, но не являются сравнимыми (допускать их сравнение было бы бессмысленно).</p> <div id=\"mark_12\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect4\"></a></h3> <h4>Заголовок отношения, кортеж, тело отношения, значение отношения, переменная отношения</h4> <p id=\"id_15\">Понятие <a name=\"keyword42\"></a><span class=\"keyword\">отношения</span> является наиболее фундаментальным в <a name=\"keyword43\"></a><span class=\"keyword\">реляционном подходе к организации баз данных</span>, поскольку <span class=\"texample\">n</span> -арное<a name=\"keyword44\"></a><span class=\"keyword\">отношение</span> является единственной родовой структурой данных, хранящихся в <a name=\"keyword45\"></a><span class=\"keyword\">реляционной базе данных</span>. Это отражено и в общем названии<a name=\"keyword46\"></a><span class=\"keyword\">подхода</span> &ndash; термин <strong>реляционный (relational)</strong> происходит от <strong>relation (отношение)</strong>. Однако сам термин <a name=\"keyword47\"></a><span class=\"keyword\">отношение</span> является исключительно неточным, поскольку, говоря про любые сохраняемые данные, мы должны иметь в виду <strong>тип</strong> этих данных, <strong>значения</strong> этого <a name=\"keyword48\"></a><span class=\"keyword\">типа</span> и <strong>переменные</strong>, в которых сохраняются значения. Соответственно, для уточнения термина <a name=\"keyword49\"></a><span class=\"keyword\">отношение</span> выделяются понятия <a name=\"keyword50\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword51\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword52\"></a><span class=\"keyword\">переменной отношения</span>. Кроме того, нам потребуется вспомогательное понятие <a name=\"keyword53\"></a><span class=\"keyword\">кортежа</span>.</p> <div id=\"mark_15\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_17\"><a name=\"keyword-context4\"></a>Итак, <span class=\"keyword_def\"><a name=\"keyword54\"></a><span class=\"keyword\">заголовком (или схемой) отношения</span></span> <span class=\"texample\">r</span> ( <span class=\"texample\">Hr</span> ) называется конечное множество упорядоченных пар вида <span class=\"texample\">&lt;A, T&gt;</span>, где <span class=\"texample\">A</span>называется именем <a name=\"keyword55\"></a><span class=\"keyword\">атрибута</span>, а <span class=\"texample\">T</span> обозначает имя некоторого базового <a name=\"keyword56\"></a><span class=\"keyword\">типа</span> или ранее определенного <a name=\"keyword57\"></a><span class=\"keyword\">домена</span> . По определению требуется, чтобы все имена <a name=\"keyword58\"></a><span class=\"keyword\">атрибутов</span> в <a name=\"keyword59\"></a><span class=\"keyword\">заголовке отношения</span> были различны. В примере на <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> <a name=\"keyword60\"></a><span class=\"keyword\">заголовком отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> является множество пар <span class=\"texample\">{&lt;слу_номер, номера_пропусков&gt;, &lt;слу_имя, имена&gt;, &lt;слу_зарп, размеры_выплат&gt;, &lt;слу_отд_номер, номера_отделов&gt;}</span>.</p> <div id=\"mark_17\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_25\">Если все <a name=\"keyword61\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword62\"></a><span class=\"keyword\">заголовка отношения</span> определены на разных <a name=\"keyword63\"></a><span class=\"keyword\">доменах</span>, то, чтобы не плодить лишних имен, разумно использовать для именования <a name=\"keyword64\"></a><span class=\"keyword\">атрибутов</span> имена соответствующих <a name=\"keyword65\"></a><span class=\"keyword\">доменов</span> (не забывая, конечно, о том, что это всего лишь удобный способ именования, который не устраняет различия между понятиями <a name=\"keyword66\"></a><span class=\"keyword\">домена</span> и <a name=\"keyword67\"></a><span class=\"keyword\">атрибута</span> ).</p> <div id=\"mark_25\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_26\"><a name=\"keyword-context5\"></a><span class=\"keyword_def\"><a name=\"keyword68\"></a><span class=\"keyword\">Кортежем</span></span> <span class=\"texample\">tr</span>, соответствующим <a name=\"keyword69\"></a><span class=\"keyword\">заголовку</span> <span class=\"texample\">Hr</span>, называется множество упорядоченных триплетов вида <span class=\"texample\">&lt;A, T, v&gt;</span>, по одному такому триплету для каждого <a name=\"keyword70\"></a><span class=\"keyword\">атрибута</span> в <span class=\"texample\">Hr</span> . Третий элемент &ndash; <span class=\"texample\">v</span> &ndash; триплета <span class=\"texample\">&lt;A, T, v&gt;</span> должен являться допустимым значением <a name=\"keyword71\"></a><span class=\"keyword\">типа данных</span>или <a name=\"keyword72\"></a><span class=\"keyword\">домена</span> <span class=\"texample\">T</span>. <a name=\"keyword73\"></a><span class=\"keyword\">Заголовку отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> соответствуют, например, следующие <a name=\"keyword74\"></a><span class=\"keyword\">кортежи</span>: <span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2934&gt;, &lt;слу_имя, имена, Иванов&gt;, &lt;слу_зарп, размеры_выплат, 22.000&gt;, &lt;слу_отд_номер, номера_отделов, 310&gt;}</span>,<span class=\"texample\">{&lt;слу_номер, номера_пропусков, 2940&gt;, &lt;слу_имя, имена, Кузнецов&gt;, &lt;слу_зарп, размеры_выплат, 35.000&gt;, &lt;слу_отд_номер, номера_отделов, 320&gt;}</span>.</p> <div id=\"mark_26\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_37\"><a name=\"keyword-context6\"></a><span class=\"keyword_def\"><a name=\"keyword75\"></a><span class=\"keyword\">Телом</span></span> <span class=\"texample\">Br</span> <a name=\"keyword76\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется произвольное множество <a name=\"keyword77\"></a><span class=\"keyword\">кортежей</span> <span class=\"texample\">tr</span> . Одно из возможных <a name=\"keyword78\"></a><span class=\"keyword\">тел отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">на рис. 2.1</a>. Заметим, что в общем случае, как это демонстрируют, в частности, <a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a> и пример предыдущего абзаца, могут существовать такие <a name=\"keyword79\"></a><span class=\"keyword\">кортежи</span> <span class=\"texample\">tr</span>, которые соответствуют <span class=\"texample\">Hr</span>, но не входят в <span class=\"texample\">Br</span>.</p> <div id=\"mark_37\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_45\"><a name=\"keyword-context7\"></a><span class=\"keyword_def\"><a name=\"keyword80\"></a><span class=\"keyword\">Значением</span></span> <span class=\"texample\">Vr</span> <a name=\"keyword81\"></a><span class=\"keyword\">отношения</span> <span class=\"texample\">r</span> называется пара множеств <span class=\"texample\">Hr</span> и <span class=\"texample\">Br</span> . Одно из допустимых <a name=\"keyword82\"></a><span class=\"keyword\">значений отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> показано на<a href=\"http://www.intuit.ru/studies/courses/74/74/lecture/27903?page=1#image.2.1\">рис. 2.1</a>.</p> <div id=\"mark_45\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_51\">В изменчивой <a name=\"keyword83\"></a><span class=\"keyword\">реляционной базе данных</span> хранятся <a name=\"keyword84\"></a><span class=\"keyword\">отношения</span>, <a name=\"keyword85\"></a><span class=\"keyword\">значения</span> которых изменяются во времени. <a name=\"keyword-context8\"></a><span class=\"keyword_def\"><a name=\"keyword86\"></a><span class=\"keyword\">Переменной</span></span> <span class=\"texample\">VARr</span> называется именованный контейнер, который может содержать любое допустимое <a name=\"keyword87\"></a><span class=\"keyword\">значение</span> <span class=\"texample\">Vr</span> . Естественно, что при определении любой <span class=\"texample\">VARr</span>требуется указывать соответствующий <a name=\"keyword88\"></a><span class=\"keyword\">заголовок отношения</span> <span class=\"texample\">Hr</span>.</p> <div id=\"mark_51\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_56\">Здесь стоит подчеркнуть, что любая принятая на практике операция обновления <a name=\"keyword89\"></a><span class=\"keyword\">базы данных</span> &ndash; <span class=\"texample\">INSERT</span> (вставка <a name=\"keyword90\"></a><span class=\"keyword\">кортежа</span> в <a name=\"keyword91\"></a><span class=\"keyword\">переменную отношения</span> ), <span class=\"texample\">DELETE</span> (удаление <a name=\"keyword92\"></a><span class=\"keyword\">кортежа</span> из значения- <a name=\"keyword93\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword94\"></a><span class=\"keyword\">переменной отношения</span> ) и <span class=\"texample\">UPDATE</span> (модификация <a name=\"keyword95\"></a><span class=\"keyword\">кортежа</span> значения-<a name=\"keyword96\"></a><span class=\"keyword\">отношения</span> <a name=\"keyword97\"></a><span class=\"keyword\">переменной отношения</span> ) &ndash; с модельной точки зрения является операцией присваивания <a name=\"keyword98\"></a><span class=\"keyword\">переменной отношения</span> некоторого нового значения- <a name=\"keyword99\"></a><span class=\"keyword\">отношения</span>. Это совсем не означает, что перечисленные операции должны выполняться именно таким образом в СУБД: главное, чтобы результат операций соответствовал этой модельной семантике.</p> <div id=\"mark_56\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_60\">Заметим, что в дальнейшем в тех случаях, когда точный смысл термина понятен из контекста, мы будем использовать термин <a name=\"keyword100\"></a><span class=\"keyword\">отношение</span> как в смысле <a name=\"keyword101\"></a><span class=\"keyword\">значение отношения</span>, так и в смысле <a name=\"keyword102\"></a><span class=\"keyword\">переменная отношения</span>.</p> <div id=\"mark_60\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_61\"><a name=\"keyword-context9\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword103\"></a><span class=\"keyword\">степенью, или \"арностью\"</span></span>, <a name=\"keyword104\"></a><span class=\"keyword\">заголовка отношения</span>, <a name=\"keyword105\"></a><span class=\"keyword\">кортежа</span>, соответствующего этому <a name=\"keyword106\"></a><span class=\"keyword\">заголовку</span>, <a name=\"keyword107\"></a><span class=\"keyword\">тела отношения</span>,<a name=\"keyword108\"></a><span class=\"keyword\">значения отношения</span> и <a name=\"keyword109\"></a><span class=\"keyword\">переменной отношения</span> является мощность <a name=\"keyword110\"></a><span class=\"keyword\">заголовка отношения</span> . Например, <a name=\"keyword111\"></a><span class=\"keyword\">степень отношения</span> <span class=\"texample\">СЛУЖАЩИЕ</span> равна четырем, т. е. оно является 4-арным ( <strong>кватернарным</strong> ).</p> <div id=\"mark_61\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_63\"><a name=\"keyword-context10\"></a>При приведенных определениях разумно считать <span class=\"keyword_def\"><a name=\"keyword112\"></a><span class=\"keyword\">схемой реляционной базы данных</span></span> набор пар <span class=\"texample\">&lt;имя_VARr, Hr&gt;</span>, включающий имена и заголовки всех <a name=\"keyword113\"></a><span class=\"keyword\">переменных отношения</span>, которые определены в <a name=\"keyword114\"></a><span class=\"keyword\">базе данных</span> . <a name=\"keyword-context11\"></a><span class=\"keyword_def\"><a name=\"keyword115\"></a><span class=\"keyword\">Реляционная база данных</span></span> &ndash; это набор пар <span class=\"texample\">&lt;VARr, Hr&gt;</span>(конечно, каждая <a name=\"keyword116\"></a><span class=\"keyword\">переменная отношения</span> в любой момент времени содержит некоторое значение- <a name=\"keyword117\"></a><span class=\"keyword\">отношение</span>, в частности, пустое).</p> <div id=\"mark_63\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_66\">Заметим, что в классических <a name=\"keyword118\"></a><span class=\"keyword\">реляционных базах данных</span> после определения <a name=\"keyword119\"></a><span class=\"keyword\">схемы базы данных</span> могли изменяться только значения<a name=\"keyword120\"></a><span class=\"keyword\">переменных отношений</span>. Однако теперь в большинстве реализаций допускается и изменение <a name=\"keyword121\"></a><span class=\"keyword\">схемы базы данных</span>: определение новых и изменение заголовков существующих <a name=\"keyword122\"></a><span class=\"keyword\">переменных отношений</span>. Это принято называть <strong>эволюцией </strong><a name=\"keyword123\"></a><span class=\"keyword\">схемы базы данных</span>.</p> <div id=\"mark_66\" class=\"lecture_mark\">&nbsp;</div> <h3><a name=\"sect5\"></a></h3> <h4>Первичный ключ и интуитивная интерпретация реляционных понятий</h4> <p id=\"id_67\"><a name=\"keyword-context12\"></a>По определению, <span class=\"keyword_def\"><a name=\"keyword124\"></a><span class=\"keyword\">первичным ключом</span></span> <a name=\"keyword125\"></a><span class=\"keyword\">переменной отношения</span> является такое подмножество<sup>1</sup> <span class=\"texample\">S</span> множества <a name=\"keyword129\"></a><span class=\"keyword\">атрибутов</span> ее заголовка, что в любое время значение <a name=\"keyword130\"></a><span class=\"keyword\">первичного ключа</span> (составное, если в состав <a name=\"keyword131\"></a><span class=\"keyword\">первичного ключа</span> входит более одного <a name=\"keyword132\"></a><span class=\"keyword\">атрибута</span> ) в любом <a name=\"keyword133\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword134\"></a><span class=\"keyword\">тела отношения</span> отличается от значения <a name=\"keyword135\"></a><span class=\"keyword\">первичного ключа</span> в любом другом <a name=\"keyword136\"></a><span class=\"keyword\">кортеже</span> <a name=\"keyword137\"></a><span class=\"keyword\">тела</span> этого <a name=\"keyword138\"></a><span class=\"keyword\">отношения</span>, а никакое собственное подмножество<sup>2</sup><span class=\"texample\">S</span> этим свойством не обладает. В следующем разделе мы покажем, что существование <a name=\"keyword139\"></a><span class=\"keyword\">первичного ключа</span> у любого <a name=\"keyword140\"></a><span class=\"keyword\">значения отношения</span>является следствием одного из фундаментальных свойств <a name=\"keyword141\"></a><span class=\"keyword\">отношений</span>, а именно того свойства, что <a name=\"keyword142\"></a><span class=\"keyword\">тело отношения</span> является множеством<a name=\"keyword143\"></a><span class=\"keyword\">кортежей</span>.</p> <div id=\"mark_67\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_78\">Обычным житейским представлением <a name=\"keyword144\"></a><span class=\"keyword\">отношения</span> является <strong>таблица</strong>, <strong>заголовком</strong> которой является схема <a name=\"keyword145\"></a><span class=\"keyword\">отношения</span>, а <strong>строками</strong> &ndash; <a name=\"keyword146\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword147\"></a><span class=\"keyword\">отношения</span> -экземпляра; в этом случае имена <a name=\"keyword148\"></a><span class=\"keyword\">атрибутов</span> соответствуют именам <strong>столбцов</strong> данной таблицы. Поэтому иногда говорят про \"столбцы таблицы\", имея в виду \" <a name=\"keyword149\"></a><span class=\"keyword\">атрибуты</span> <a name=\"keyword150\"></a><span class=\"keyword\">отношения</span> \".</p> <div id=\"mark_78\" class=\"lecture_mark\">&nbsp;</div> <p id=\"id_79\">Конечно, это достаточно грубая терминология, поскольку у обычных таблиц и строки, и столбцы упорядочены, тогда как <a name=\"keyword151\"></a><span class=\"keyword\">атрибуты</span> и <a name=\"keyword152\"></a><span class=\"keyword\">кортежи</span><a name=\"keyword153\"></a><span class=\"keyword\">отношений</span> являются элементами неупорядоченных множеств. Тем не менее, когда мы перейдем к рассмотрению практических вопросов организации <a name=\"keyword154\"></a><span class=\"keyword\">реляционных баз данных</span> и средств управления, то будем использовать эту \"житейскую\" терминологию. Подобной терминологии придерживаются в большинстве коммерческих реляционных СУБД. Иногда также используются термины <strong>файл</strong> как аналог таблицы, <strong>запись</strong> как аналог строки и <strong>поле</strong> как аналог столбца. Напомню, что этой терминологией мы пользовались в лекции 1.</p>',2,' В этом курсе, главным образом, обсуждаются различные аспекты реляционных баз данных. Принято считать, что реляционный подход к организации баз данных был заложен в конце 1960-х гг. Эдгаром Коддом. В последние десятилетия этот подход является наиболее распространенным (с оговоркой, что в называемых в обиходе реляционными системах баз данных, основанных на языке SQL, в действительности нарушаются некоторые важные принципы классического реляционного подхода). Достоинствами реляционного подхода принято считать следующие свойства: реляционный подход основывается на небольшом числе интуитивно понятных абстракций, на основе которых возможно простое моделирование наиболее распространенных предметных областей; эти абстракции могут быть точно и формально определены; теоретическим базисом реляционного подхода к организации баз данных служит простой и мощный математический аппарат теории множеств и математической логики; реляционный подход обеспечивает возможность ненавигационного манипулирования данными без необходимости знания конкретной физической организации баз данных во внешней памяти. Компьютерный мир далеко не сразу признал реляционные системы. В 70-е года прошлого века, когда уже были получены почти все основные теоретические результаты и даже существовали первые прототипы реляционных СУБД, многие авторитетные специалисты отрицали возможность добиться эффективной реализации таких систем. Однако преимущества реляционного подхода и развитие методов и алгоритмов организации и управления реляционными базами данных привели к тому, что к концу 80-х годов реляционные системы заняли на мировом рынке СУБД доминирующее положение. В этой лекции на сравнительно неформальном уровне вводятся основные понятия реляционных баз данных, а также определяется сущность реляционной модели данных. Основной целью лекции является демонстрация простоты и возможности интуитивной интерпретации этих понятий. В следующих лекциях будут приводиться более формальные определения, на которых основана теория реляционных баз данных.',0); 

INSERT INTO files(files_name, material, files_type) VALUES 
('vidio',1,'mp4'), 
('text',2,'doc'), 
('text',3,'doc'), 
('text',4,'doc'), 
('text',5,'doc'), 
('text',6,'doc'), 
('text',7,'doc'), 
('text',8,'doc'), 
('text',9,'doc'), 
('text',10,'doc'), 
('text',11,'doc'); 

INSERT INTO test(test_name, test_day, test_text, program, test_deleted) VALUES 
('DDL and DML commands.',2,'test',1,0), 
('Тест 1',2,'15 минут 5 заданий',2,0), 
('Тест 2',4,'15 минут 5 заданий',2,0), 
('Тест 3',6,'15 минут 5 заданий',2,0), 
('Экзамен',10,'15 минут 5 заданий',2,0); 

INSERT INTO test_task(test_task_no, test_task_text, test_task_answer, test_task_v1, test_task_v2, test_task_v3, test_task_v4, test_task_ball, test_task_deleted, test) VALUES 
(1,'Whot is comands of DDL?','ALTER','SELECT','INSERT','UPDATE','DELETE',2,0,1), 
(1,'1В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,2), 
(2,'2В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,2), 
(3,'3В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,2), 
(4,'4В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,2), 
(5,'5В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,2), 
(1,'6В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,3), 
(2,'7В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,3), 
(3,'8В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,3), 
(4,'9В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,3), 
(5,'10В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,3), 
(1,'11В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,4), 
(2,'12В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,4), 
(3,'13В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,4), 
(4,'14В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,4), 
(5,'15В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,4), 
(1,'16В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,5), 
(2,'17В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,5), 
(3,'18В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,5), 
(4,'20В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,5), 
(5,'21В чем преимущества дискреционного способа защиты файлов перед мандатным способом?','Ответ','быстрее обрабатывается проверка законности доступа','обеспечивается более высокий уровень защиты','мандатные системы не позволяют моделировать \"группы пользователей\"','4',1,0,5); 

INSERT INTO course(course_date, program, course_public, course_deleted) VALUES 
(now(), 2, 0, 0);

INSERT INTO user_has_course(user, course, user_has_course_datetime, user_has_course_deleted) VALUES 
(2, 1, now(), 0);

INSERT INTO schedule_has_material(material, course, date_time) VALUES 
(2, 1, now()+interval 1 day),
(3, 1, now()+interval 2 day),
(4, 1, now()+interval 3 day),
(5, 1, now()+interval 4 day),
(6, 1, now()+interval 5 day),
(7, 1, now()+interval 6 day),
(8, 1, now()+interval 7 day),
(9, 1, now()+interval 8 day),
(10, 1, now()+interval 9 day),
(11, 1, now()+interval 10 day);

INSERT INTO schedule_has_test(course, test, date_time) VALUES 
(1, 2, date(now())+interval 2 day),
(1, 3, date(now())+interval 4 day),
(1, 4, date(now())+interval 6 day),
(1, 5, date(now())+interval 11 day);
